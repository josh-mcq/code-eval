juliango202

def recoverSecret(triplets):
    letters = list(set([l for t in triplets for l in t]))        
            
    for t in triplets * len(letters):
        for i in range(len(t)-1):
            a, b = letters.index(t[i]), letters.index(t[i+1])
            if( a > b ): letters[b], letters[a] = letters[a], letters[b]
            
    return ''.join(letters)
Best Practices8Clever3
0ForkCompare with your solutionLink
laoris

import collections, functools, itertools

def recoverSecret(triplets):
    """triplets is a list of triplets from the secret string. Return the string."""
    
    # Build a reverse directed graph of letters
    graph = Graph()
    for triplet in triplets:
        for i, j in pairwise(triplet):
            graph[i].goes_to(graph[j])
    
    # Pop off orphan letters one-by-one to form the word
    cardinality = lambda node: len([ p for p in node.parents if p.value in graph ])
    getnext = functools.partial(min, graph.viewvalues(), key=cardinality)
    word = ( graph.pop(getnext().value).value for i in xrange(len(graph)) )
    
    return ''.join(word)
    
class Graph(collections.defaultdict):
    """A graph that autocreates nodes"""
    def __missing__(self, key):
        self[key] = Node(key)
        return self[key]

class Node(object):
    """A directed graph node that knows its parents"""
    def __init__(self, value):
        self.value = value
        self.parents = []
    def goes_to(self, child):
        child.parents.append(self)

def pairwise(iterable):
    """Iterates through an iterable in pairs [a,b,c,d] --> ( [a,b], [b,c], [c,d] )"""
    a, b = itertools.tee(iterable)
    next(b, None)
    return itertools.izip(a, b)
Best Practices5Clever9
0ForkCompare with your solutionLink
ninehills

def recoverSecret(triplets):
  r = list(set([i for l in triplets for i in l]))
  for l in triplets:
    fix(r, l[1], l[2])
    fix(r, l[0], l[1])
  return ''.join(r)
  
def fix(l, a, b):
   """let l.index(a) < l.index(b)"""
   if l.index(a) > l.index(b):
       l.remove(a)
       l.insert(l.index(b), a)
Best Practices4Clever1
0ForkCompare with your solutionLink
junzxu

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    res = ""
    table = {}
    visited = set()
    for a,b,c in triplets:
        if not table.has_key(a):
            table[a] = set()
        if not table.has_key(b):
            table[b] = set()
        if not table.has_key(c):
            table[c] = set()
        table[a].add(b)
        table[a].add(c)
        table[b].add(c)

    count = len(table.keys())
    while len(visited) < count:
        Min = count
        c = ''
        for k,v in table.iteritems():
            l = len([elem for elem in v if elem not in visited])
            if l < Min and k not in visited:
                Min = l
                c = k
        visited.add(c)
        res += c
    return res[::-1]
Best Practices2Clever0
0ForkCompare with your solutionLink
jvanbrug

def recoverSecret(groups):
    '''Combine all letters in groups, then sort using each ordered group in groups
       (the sorting process repeats as many times as the size of the ordered groups in groups,
       which is three for this kata's triplets)'''
    secret = list(set(letter for group in groups for letter in group))
    for group in groups * len(groups[0]):
        for i in range(len(group) - 1):
            earlier = secret.index(group[i])
            later = secret.index(group[i+1])
            if earlier > later:
                secret.insert(earlier, secret.pop(later))
    return ''.join(secret)
Best Practices1Clever0
0ForkCompare with your solutionLink
fuzzy_by_nature

def is_in_other_column(triplets, letter):
    """
    Return True if letter parameter is in triplet list 
    in location 2 or 3. 
    """
    for triplet in triplets:
        if len(triplet) == 1:
            continue 
        if letter in triplet[1:]:
            return True

    return False
    
def remove_first_letter(triplets, letter):
    """
    Remove item at location 0 of a list if it matches
    the letter parameter.
    """
    return_triplets = []
    
    for triplet in triplets:
        if letter == triplet[0]:
            triplet.remove(letter)
        if len(triplet) > 0:
            return_triplets.append(triplet)
            
    return return_triplets
    
def recoverSecret(triplets):
  """
  Search for letter in column one that is in no other column. Add that
  character to the secret string and start searching for the next letter. 
  """
  secret_string = ''
  while len(triplets) > 0:
      for triplet in triplets:
          if not is_in_other_column(triplets, triplet[0]):
              secret_string += triplet[0]
              triplets = remove_first_letter(triplets, triplet[0])
              break # start at beginning of triplet list. 

  return secret_string
              
Best Practices1Clever0
0ForkCompare with your solutionLink
fungairino

def recoverSecret(triplets):
  s = list(set([c for t in triplets for c in t]))
  for t in triplets:
    if s.index(t[1]) > s.index(t[2]):
      s.remove(t[1])
      s.insert(s.index(t[2]), t[1])
    if s.index(t[0]) > s.index(t[1]):
      s.remove(t[0])
      s.insert(s.index(t[1]), t[0])
  return ''.join(s)
Best Practices1Clever3
0ForkCompare with your solutionLink
JelteF

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    res = ''
    while triplets != []:
        non_firsts = [num for t in triplets for num in t[1:]]
        firsts = [t[0] for t in triplets]
        for f in firsts:
            if f not in non_firsts:
                res += f
                for t in triplets:
                    if t[0] == f:
                        t.pop(0)
                break
        triplets = [t for t in triplets if t != []]
    return res
Best Practices1Clever0
0ForkCompare with your solutionLink
juliango202

from collections import defaultdict

def recoverSecret(triplets):
  # Compute the set of letters that come after each letter
  afters = defaultdict(set)
  for seq in triplets * 2:
      for letter in seq:
          for successor in seq[seq.index(letter):]:
              afters[letter] |= set([successor]) | afters[successor]
  
  # Return the keys sorted by max length
  return ''.join(sorted(afters.keys(),key=lambda x: -len(afters[x])))
Best Practices1Clever0
0ForkCompare with your solutionLink
rffrancon

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  # make all edges and gather charecters
  all_chars = set()
  edges = set()
  for triplet in triplets:
      edges.add((triplet[0], triplet[1]))
      edges.add((triplet[1], triplet[2]))
      all_chars.update(triplet)
  
  word = ''
  
  while all_chars:
      # get next charecter
      for char in all_chars:
          next = char
          for edge in edges:
              if char == edge[1]:
                  next = None
                  break
          if next:
              break
      all_chars.remove(next)
      
      # remove usless edges
      new_edges = set()
      for edge in edges:
          if edge[0] != next:
              new_edges.add(edge)
      edges = new_edges
      
      word += next
  return word
      
      
Best Practices1Clever0
0ForkCompare with your solutionLink
adam-tokarski

def recoverSecret(triplets):
    found = [];
    for row in triplets:

        if len(set(row).intersection(found)) > 0:
            i, ip = 0, 0;
            for char in row:
                if char not in found:
                    found = found[:i] + [char] + found[i:]
                else:
                    i = found.index(char) + 1 if char in found else -1;
                    if i <= ip:
                        found.insert(ip-1, found.pop(i-1));
                    ip = i;
        else:
            found = row + found;

    return ''.join(found)
Best Practices1Clever0
0ForkCompare with your solutionLink
gregory.pease.280

col0=[]
col1=[]
col2=[]

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  letters=""
  
  for trip in triplets:
    col0.append(trip[0])
    col1.append(trip[1])
    col2.append(trip[2])
    
    
  while not all(item==None for item in col0):
    for x in range(0,len(col0)):
      if (not col0[x] in col1 and not col0[x] in col2):
        letters=letters+str(col0[x])
        pop(col0[x])
        break
  return letters
        
def pop(val):
  for i in range(0,len(col0)):
    if(col0[i]==val):
        col0[i]=col1[i]
        col1[i]=col2[i]
        col2[i]=None
        
  
Best Practices1Clever1
0ForkCompare with your solutionLink
abednego

def recoverSecret(triplets):
  lt = [[False] * 26 for _ in xrange(26)]
  for a, b, c in triplets:
    a, b, c = (ord(x) - ord('a') for x in (a, b, c))
    lt[a][b] = lt[b][c] = True
    
  for k in xrange(26):
    for i in xrange(26):
      for j in xrange(26):
        if lt[i][k] and lt[k][j]: lt[i][j] = True
  
  ans = [x for x in xrange(26) if (True in lt[x] + [lt[i][x] for i in xrange(26)])]
  ans.sort(key=lambda i: sum(1 - x for x in lt[i]))
  return "".join(chr(ord('a') + i) for i in ans)    
Best Practices0Clever0
0ForkCompare with your solutionLink
yangyanzhan

def recoverSecret(triplets):
  tmp = set()
  for triplet in triplets:
      for letter in triplet:
          tmp.add(letter)
  letters = {}
  for letter in tmp:
      letters[letter] = {
          "before": set(),
          "after": set()
      }
  def add_to_before(letters, a, b):
      bfb = letters[b]["before"] = letters[b]["before"] | set([a]) | letters[a]["before"]
      for letter in letters.keys():
          if letter == b:
              continue
          bf = letters[letter]["before"]
          if b in bf:
              letters[letter]["before"] = bf | bfb
  def add_to_after(letters, a, b):
      afa = letters[a]["after"] = letters[a]["after"] | set([b]) | letters[b]["after"]
      for letter in letters.keys():
          if letter == a:
              continue
          af = letters[letter]["after"]
          if a in af:
              letters[letter]["after"] = af | afa
  for a, b, c in triplets:
      add_to_before(letters, a, b)
      add_to_before(letters, b, c)
      add_to_after(letters, a, b)
      add_to_after(letters, b, c)
  res = []
  n = len(letters)
  for i in range(n):
      for letter in letters:
          if len(letters[letter]["before"]) == 0:
              break
      res.append(letter)
      del letters[letter]
      head = letter
      for letter in letters:
          letters[letter]["before"] = letters[letter]["before"] - set([head])
  return "".join(res)
Best Practices0Clever0
0ForkCompare with your solutionLink
xomasan

from itertools import product

def recoverSecret(triplets):
    string = set(t for triplet in triplets for t in triplet)

    mapping = set()
    for x, y, z in triplets:
        mapping.update([(x, y), (y, z), (x, z)])

    found_more = True
    while found_more:
        found_more = False
        for x, y in product(string, string):
            if x == y or (x, y) in mapping:
                continue
            for item in mapping:
                if item[0] != x:
                    continue
                if (item[1], y) in mapping:
                    mapping.add((x, y))
                    found_more = True
                    break

    return ''.join(sorted(string, cmp=lambda x, y: -1 if (x, y) in mapping else 1))
Best Practices0Clever0
0ForkCompare with your solutionLink
ITSOES

def recoverSecret(triplets):
  letters = {x: set() for x in triplets for x in x}
  for a, b, c in triplets:
      letters[c] |= {a,b}
      letters[b] |= {a}

  result = ""
  while not all(letters.values()):
      for l in letters:
          if not letters[l]:
              result += l
              letters.pop(l)
              for s in letters:
                  letters[s] -= {l}
              break
  return result                
Best Practices0Clever0
0ForkCompare with your solutionLink
TrumanZCM

def recoverSecret(triplets):
    if not triplets:
        return ''
    
    others = [letter for i in range(0, len(triplets)) for letter in triplets[i][1:]]
    msg = [letter for letter in set(zip(*triplets)[0]) if letter not in others]
    triplets = [[letter for letter in words if letter != msg[0]] for words in triplets]

    return msg[0] + recoverSecret([letter for letter in triplets if letter])
Best Practices0Clever1
0ForkCompare with your solutionLink
upkl

def insert_into(succ, k, v):
    if succ.has_key(k):
        if succ[k].find(v) == -1:
            succ[k] = succ[k] + v
    else:
        succ[k] = v

def recoverSecret(triplets):
    succ = {}
    for t in triplets:
        insert_into(succ, t[0], t[1])
        insert_into(succ, t[0], t[2])
        insert_into(succ, t[1], t[2])

    rv = ""
    while len(succ) > 1:
        vals = "".join(succ.values())
        for f in succ.keys():
            if vals.find(f) == -1:
                rv = rv + f
                del(succ[f])
                break

    return rv + succ.keys()[0] + succ.values()[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
rnby.mike

def recoverSecret(triplets):
    def constract_graph(triplets):
        graph = dict()
        for triplet in triplets:
            first, second, third = triplet
            if first in graph:
                graph[first] |= set([second, third])
            else:
                graph[first] = set()
                graph[first] |= set([second, third])

            if second in graph:
                graph[second] |= set([third])
            else:
                graph[second] = set()
                graph[second] |= set([third])

            if third not in graph:
                graph[third] = set()

        return graph

    def find_first_letter(triplets):
        a, b, c = zip(*triplets)
        for i in a:
            if (i not in b) and (i not in c):
                return i

    def find_last_letter(triplets):
        a, b, c = zip(*triplets)
        for i in c:
            if (i not in a) and (i not in b):
                return i

    def find_path(graph, start, end, path=[]):
        path = path + [start]
        if start == end:
            return path
        if not graph.has_key(start):
            return None
        for node in graph[start]:
            if node not in path:
                newpath = find_path(graph, node, end, path)
                if newpath and len(newpath) == len(graph):
                    return newpath
        return None

    graph = constract_graph(triplets)
    first_letter = find_first_letter(triplets)
    last_letter = find_last_letter(triplets)
    return "".join(find_path(graph, first_letter, last_letter))
Best Practices0Clever0
0ForkCompare with your solutionLink
coralv

def recoverSecret(triplets):
    unique = []
    for trip in triplets:
        unique.extend(trip)
    unique = set(unique)
    #creates a list of each character from the input, occurring only once (a set)
    
    result = []
    possibilities = []
    
    for i in range(len(triplets)):
        possibilities.append([triplets[i][0], triplets[i][1]])
        possibilities.append([triplets[i][1], triplets[i][2]])
        #creates a list of pairs for each letter sequence in the original input
        
    order_guide = [list(pair) for pair in set(tuple(pair) for pair in possibilities)]
    #creates a unique list based on possibilities
    
    for u in unique:
        result.append(u)
        #adds each letter to the output list but not in the proper order
    
    counter = 1
    while counter > 0:
        counter = 0
        for item in order_guide:
            early = result.index(item[0])
            late  = result.index(item[1])
            if early > late:
                counter += 1
                move = result.pop(early)
                result.insert(late, move)

    return "".join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
Giedrius

def recoverSecret(triplets):
    before = {c: set() for t in triplets for c in t}
    flat = {}

    for t in triplets:
        for i, c in enumerate(t):
            before[c].update(t[:i])

    def flat_before(a):
        if a not in flat:
            flat[a] = before[a].copy()
            for b in before[a]:
                flat[a].update(flat_before(b))
        return flat[a]
    
    def is_before(a, b):
        return a in flat_before(b)

    return ''.join(sorted(before.keys(), lambda a, b: [1, -1][is_before(a, b)]))
Best Practices0Clever0
0ForkCompare with your solutionLink
Hectorrr72

def recoverSecret(triplets):
    word = ""
    notFound = True
    while notFound:
        next_map = {}
        next_set = set([])
        for x in range (0, len(triplets)):
            if (len(triplets[x]) > 0):
                next_map[triplets[x][0]] = x
                next_set.add(triplets[x][0])
        notFirst = set([])
        for x in range (0, len(triplets)):
            for y in range(1, len(triplets[x])):
                notFirst.add(triplets[x][y])
        if(len(notFirst) == 0):
            notFound = False
        letter = list(next_set-notFirst)[0]
        word += letter
        remove_letter(triplets, letter)
        
    return word     

def remove_letter(triplets, letter):
    for x in range(0, len(triplets)):
        if (len(triplets[x]) > 1 and triplets[x][0] == letter):
            triplets[x] = triplets[x][1:]
        elif (len(triplets[x]) == 1 and triplets[x][0] == letter):
            triplets[x] = [] 
                
            
Best Practices0Clever0
0ForkCompare with your solutionLink
hgbarrow

def recoverSecret(triplets):
    all_letters = []
    for triplet in triplets:
        for letter in triplet:
            if letter not in all_letters:
                all_letters.append(letter)
    
    secret = [''] * len(all_letters)
    next_triplets = triplets
    
    while '' in secret:
        [secret, next_triplets] = get_next(secret, triplets)
    return ''.join(secret)
     
def get_next(secret, triplets):
    # check columns - if letter only appears in first column, it is the next letter. 
    # Triplets with this letter are then shifted left.
    first_col = []
    second_col = []
    third_col = []
    
    for triplet in triplets:
        if triplet[0] in secret:
            first_col.append(triplet[1])
            second_col.append(triplet[2])
            third_col.append('0')
            triplet[0] = triplet[1]
            triplet[1] = triplet[2]
            triplet[2] = '0'
            
        else:
            first_col.append(triplet[0])
            second_col.append(triplet[1])
            third_col.append(triplet[2])
            
    for letter in first_col:
        if letter.isalpha and (letter not in second_col) and (letter not in third_col):
            next_letter = letter
    if "" in secret:
        secret[secret.index("")] = next_letter
    return [secret, triplets]
Best Practices0Clever0
0ForkCompare with your solutionLink
joon.song

def recoverSecret(triplets):
    letters=list(set(reduce(lambda x,y:x+y,triplets)))
    ret =""
    while len(letters)!=0:
        for ch in letters:
            if all(ch not in triplet[1:] for triplet in triplets):
                for triplet in triplets:
                    if ch in triplet:
                        triplet.remove(ch)
                letters.remove(ch)
                ret+=ch
                break;
    return ret
Best Practices0Clever0
0ForkCompare with your solutionLink
inzune

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  guess = []
  follower_dict = {}
  # determine unique letters in the triplets
  unique_letters = set()
  for i in triplets:
      unique_letters = unique_letters.union(set(i))
      
  # create a dict with the letters as keys and and for the values 
  # every letter that follows them in the triplets as set
  for i in unique_letters:
      followers = []
      for j in triplets:
          if i == j[0]:
              followers.extend(j[1:])
          elif i == j[1]:
              followers.append(j[2])
      follower_dict.update({i : set(followers)})
  
   
  # unify the dicts sets if the key letter is part of the value set
  hasChanged = True
  while hasChanged:
      new_follower_dict = {}
      hasChanged = False
      for letter in follower_dict.iterkeys():
          new_followers = follower_dict[letter]
          for followers in follower_dict[letter]:
              for follower in followers:
                  new_followers = new_followers.union(follower_dict[follower])
          if new_followers != follower_dict[letter]:
              hasChanged = True
          new_follower_dict.update({letter: new_followers})
      follower_dict.update(new_follower_dict)
      
  #order by lenght of follower list
  for i in sorted(follower_dict.viewitems(), key=lambda x: len(x[1]),reverse=True):
      guess.append(i[0])
      
  return "".join(guess)
  ### this probably is the worst i have written so far, but it looked good on paper ###    
              
  
Best Practices0Clever0
0ForkCompare with your solutionLink
sim0504

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
  
    secret = ""
    letters = set(letter for row in triplets for letter in row)
    following_letters = {letter: set() for letter in letters}
    cols = zip(*triplets)
    
    for i in range(len(triplets)-1):
        following_letters[cols[0][i]] |= set([cols[1][i], cols[2][i]])
        following_letters[cols[1][i]] |= set([cols[2][i]])
        
    n = len(letters)
    while len(secret) != n:
        next_letter = [k for k, v in following_letters.iteritems() if v == set([])][0]
        secret += next_letter
        del following_letters[next_letter]
        letters.remove(next_letter)
        for letter in letters:
            following_letters[letter] &= letters
            following_letters[letter] &= letters
                    
    return secret[::-1]
      
Best Practices0Clever0
0ForkCompare with your solutionLink
godescbach

import numpy as np

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    secret = list(set([l for t in triplets for l in t])) # borrows from juliango202
    rules = []
    tripletsArr=np.array(triplets)

    [ rules.append(list(x)) for j in range(1, len(tripletsArr[0]) ) for x in tripletsArr[:,[j-1,j]] ]

    changeMade = True
    while changeMade:
        changeMade = False
        for i,j in rules:
            if secret.index(i) > secret.index(j):
                secret[secret.index(i)], secret[secret.index(j)] = secret[secret.index(j)], secret[secret.index(i)]
                changeMade = True
    
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
godescbach

import numpy as np
def applyRule(str, i, j):
    tmp = str[str.find(i)]
    secret = str[:str.find(i)] + str[str.find(i)+1:]
    return secret[:str.find(j)] + tmp + secret[str.find(j):]
    
def recoverSecret(triplets):
    secret = ''
    rules = []
    tripletsArr=np.array(triplets)
    for j in range(len(tripletsArr[0]) ):
        for i in range(len(tripletsArr) ):
            if secret.find(tripletsArr[i, j]) < 0:
                secret+=tripletsArr[i, j]
            if j > 0:
                rules.append([ tripletsArr[i,j-1], tripletsArr[i,j] ])
    changeMade = True
    while changeMade:
        changeMade = False
        for i,j in rules:
            if secret.find(i) > secret.find(j):
                secret = applyRule(secret, i, j)
                changeMade = True

    #print secret
    #print rules
    
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
timp

def recoverSecret(triplets):
    unique = list(set([c for t in triplets for c in t]))
    r,f = [],False
    while triplets:
        for u in unique:
            f = False
            for i,t in enumerate(triplets):
                if u in t:
                    f = True
                    if t.index(u)>0:
                        f = False
                        break
            if f:
                r.append(u)
                triplets = [x for x in [t[1:] if u in t else t for t in triplets] if x]
    return ''.join(r)
Best Practices0Clever0
0ForkCompare with your solutionLink
abar

def add_move(x, y, i):
  if y[i] not in x:
        x[y[i]] = []
  if y[i + 1] not in x[y[i]]:
      x[y[i]].append(y[i + 1])
  return x  

def parse(moves, words, letter):
  if letter not in moves:
    return letter
  elif letter in words:
    return words[letter]
  longest = ""
  for m in moves[letter]:
    r = parse(moves, words, m)
    if len(r) > len(longest):
      longest = r
  words[letter] = letter + longest
  return words[letter]

def recoverSecret(triplets):
  moves = reduce(lambda x, y: add_move(add_move(x, y, 0), y, 1), triplets, {})
  words = {}
  longest = ""
  for k in moves:
    r = parse(moves, words, k)
    if len(r) > len(longest):
      longest = r
  return longest
Best Practices0Clever0
0ForkCompare with your solutionLink
anilybba

from collections import defaultdict

def recoverSecret(triplets):
    letters = defaultdict(set)
    for t in triplets:
        map(letters[t[0]].add, set(t[1:]).union(letters[t[1]], letters[t[2]]))
        map(letters[t[1]].add, set(t[2]).union(letters[t[2]]))
    for l in letters:
        for k in list(letters[l]):
            map(letters[l].add, letters[k])
    return ''.join(sorted(letters, key=lambda x: len(letters[x]), reverse=True))
Best Practices0Clever0
0ForkCompare with your solutionLink
nguyen_v

import itertools
def recoverSecret(triplets):
  out = list(set(itertools.chain.from_iterable(triplets)))
  flag = True

  while flag:
    flag = False
    for t in triplets:
      a, b, c = out.index(t[0]), out.index(t[1]), out.index(t[2])

      if a > b or b > c or a > c:
        if a > b: out.insert(a, out.pop(b))
        elif b > c: out.insert(b, out.pop(c))
        else: out.insert(a, out.pop(c))
        flag = True

  return "".join(out)
Best Practices0Clever0
0ForkCompare with your solutionLink
Gmerold

from itertools import chain
def recoverSecret(triplets):
    joined = list(set(chain(*triplets)))
    for i in range(3):
        for triplet in triplets:
            index_i = joined.index(triplet[0])
            index_ii = joined.index(triplet[1])
            if index_i > index_ii:
                joined[index_i], joined[index_ii] = joined[index_ii], joined[index_i]
            index_ii = joined.index(triplet[1])
            index_iii = joined.index(triplet[2])
            if index_ii > index_iii:
                joined[index_ii], joined[index_iii] = joined[index_iii], joined[index_ii]
    return "".join(joined)
Best Practices0Clever0
0ForkCompare with your solutionLink
codr9

def recoverSecret(triplets):
  #algorithm: loop through the triplets
  #apply each rule until nothing is changed
  old_string = "".join(set(sum(triplets, [])))
  while True:
      new_string = old_string
      for triplet in triplets:
          #step 1: fix discrepancies
          new_string = list(new_string)
          a, b, c = [new_string.index(ch) for ch in triplet]
          if a > b:
              new_string[a] = triplet[1]
              new_string[b] = triplet[0]
          elif b > c:
              new_string[b] = triplet[2]
              new_string[c] = triplet[1]
          elif a > c:
              new_string[a] = triplet[2]
              new_string[c] = triplet[0]
          new_string = "".join(new_string)
      if new_string == old_string:
          break
      else:
          old_string = new_string
  return old_string
Best Practices0Clever0
0ForkCompare with your solutionLink
afilardo

import itertools


def find_previous(triplets, char):
    containing_rows = (t for t in triplets if char in t)
    for t in containing_rows:
        if t.index(char) > 0:
            c = t[0]
            return c
    return None


def delete_char(triplets, char):
    for t in triplets:
        if char in t:
            t.remove(char)
    return [t for t in triplets if len(t) > 0]
    
    
def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    size = len(set(itertools.chain(*triplets)))
    res = ''
    while len(res) < size:
        c = triplets[0][0]
        while find_previous(triplets, c) is not None:
            c = find_previous(triplets, c)
        else:
            res += c
            triplets = delete_char(triplets, c)
    return res 
Best Practices0Clever0
0ForkCompare with your solutionLink
JohnBrodie

def recoverSecret(triplets):
  s = get_all_letters(triplets)
  
  done = False
  while not done:
    done = True
    for t in triplets:
      first = s.index(t[0])
      second = s.index(t[1])
      third = s.index(t[2])
      
      if first > second:
        done = False
        s[first], s[second] = t[1], t[0]
        first, second = second, first
        
      if second > third:
        done = False
        s[second], s[third] = t[2], t[1]
  
  return ''.join(s)
  
def get_all_letters(triplets):
  letters = set()
  for triplet in triplets:
    letters.update(triplet)
  return list(letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
jmdana


def fix_idx(ia, ib, msg):
    a = msg[ia]
        
    if ia > ib:
        msg.insert(ib, a)
        del msg[ia + 1]
        ia, ib = ib, ib + 1
    
    return ia, ib

def recoverSecret(triplets):
    msg = []
    
    for t in triplets:
        for l in t:
            msg.append(l)
            
    msg = list(set(msg))
    
    for a, b, c in triplets:
        ia = msg.index(a)
        ib = msg.index(b)
        ic = msg.index(c)
        
        ia, ib = fix_idx(ia, ib, msg)
        ia, ic = fix_idx(ia, ic, msg)
        ib, ic = fix_idx(ib, ic, msg)

    return "".join(msg)
Best Practices0Clever0
0ForkCompare with your solutionLink
kesyog

#switch two characters in list of letters
def switchLetters(letters,char1,char2):
    i1=letters.index(char1)
    i2=letters.index(char2)
    letters[i1],letters[i2]=char2,char1
    return letters

def recoverSecret(triplets):
  #create list of letters
  letters = set()
  for i in triplets:
      letters.update(set(i))
  letters = list(letters)
  
  #iterate through triplets. if two letters are out of rank order, swap them
  done = False
  while(not done):
      done = True
      for triplet in triplets:
          triplet_indices = map(lambda char:letters.index(char),triplet)
          if triplet_indices[0] > triplet_indices[1]:
              switchLetters(letters,triplet[0],triplet[1])
              done = False
              continue
          if triplet_indices[0] > triplet_indices[2]:
              switchLetters(letters,triplet[0],triplet[2])
              done = False
              continue
          if triplet_indices[1] > triplet_indices[2]:
              switchLetters(letters,triplet[1],triplet[2])
              done = False
              continue
  return ''.join(letters)            
Best Practices0Clever0
0ForkCompare with your solutionLink
zieglerk

def recoverSecret(triplets):
    letters = list(set([l for trip in triplets for l in trip]))
    for trip in triplets:
        fix(letters, trip)
    return ''.join(letters)

def fix(letters, trip):
    """rearrange the list of letters according to the relations given by trip."""
    a, b, c = trip
    if letters.index(b) > letters.index(c):
        letters.remove(b)
        letters.insert(letters.index(c), b)
    if letters.index(a) > letters.index(b):
        letters.remove(a)
        letters.insert(letters.index(b), a)
Best Practices0Clever0
0ForkCompare with your solutionLink
zieglerk

def findLead(relations):
    firsts = list(set([rel[0] for rel in relations]))
    for char in firsts:
        pos = 0
        for rel in relations:
            if char in rel:
                pos = max(pos, rel.index(char))
        if pos==0:
            return char
            
def removeChar(relations, char):
    newrelations = []
    for rel in relations:
        if char in rel:
            rel.remove(char)
        if len(rel) > 0:
            newrelations.append(rel)
    return newrelations

def recoverSecret(relations):
    if len(relations) == 0:
        return ''
    elif len(relations) == 1:
        return ''.join(relations[0])
    lead = findLead(relations)
    return lead + recoverSecret(removeChar(relations, lead))
Best Practices0Clever0
0ForkCompare with your solutionLink
deamonsoul

def recoverSecret(triplets):
    string = list(set([item for innerlist in triplets for item in innerlist]))
    for x in range(3):
        string = mysort(string, triplets)
    return ''.join(string)

def mysort(string, rules):
    out = string[:]
    for rule in rules:
        a = out.index(rule[0])
        b = out.index(rule[1])
        c = out.index(rule[2])
        correct = sorted([a,b,c])
        out[correct[0]] = rule[0]
        out[correct[1]] = rule[1]
        out[correct[2]] = rule[2]
    return out
Best Practices0Clever0
0ForkCompare with your solutionLink
DannyLee

def make_dict(triplets):
    """Make a dictionary of all letters after a given letter."""
    after = {}
    for t in triplets:
        for i, k in enumerate(t):
            if k not in after:
                after[k] = set(t[i+1:])
            else:
                after[k] |= set(t[i+1:])
            for a in set(after[k]):
                # Add all letters after each following letter.
                if a in after:
                    after[k] |= after[a]
    return after

def recoverSecret(triplets):
    """Recovers a string from a series of triplets."""
    after = make_dict(triplets)
    secret = ''
    for _ in dict(after):
        # Add the letter with the least amount of letters after it.
        next = max(after, key=lambda x: len(after[x]))
        secret += next
        del after[next]
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
nlintz

def triplets_to_prefix(triplets):
  prefixes = {}
  for triplet in triplets:
    triplet.reverse()
    for i in range(len(triplet)):
      prefixes[triplet[i]] = prefixes.get(triplet[i],set()).union(set(triplet[i+1:]))
  return prefixes

def find_empty_prefix(prefixes):
  for k,v in prefixes.items():
    if len(v) == 0:
      return k

def update_prefixes(prefixes, word):
  for k in prefixes.keys():
    prefixes[k] = prefixes[k].difference(set(word))

def prefixes_to_word(prefixes):
  word = []
  while prefixes:
    letter = find_empty_prefix(prefixes)
    word.append(letter)
    del prefixes[letter]
    update_prefixes(prefixes, word)
  return ''.join(word)

def recoverSecret(triplets):
  return prefixes_to_word(triplets_to_prefix(triplets))
Best Practices0Clever0
0ForkCompare with your solutionLink
Johnathanrs

def recoverSecret(triplets):
    after_lookup = {
    }
    for triplet in triplets:
        for idx, c in enumerate(triplet):
            after = triplet[idx+1:]
            #print after
            if c not in after_lookup:
                after_lookup[c] = after
            else:
                after_lookup[c].extend(after)

    secret = []
    for key in after_lookup:
        # find the last letter
        if after_lookup[key] == []:
            secret.insert(0, key)
            break

    del after_lookup[key]

    while after_lookup != {}:
        befores = []
        settled = secret[0]
        for key in after_lookup:
            if settled in after_lookup[key]:
                after_lookup[key] = [x for x in after_lookup[key] if x != settled]
                befores.append((key, after_lookup[key]))
        sorted_befores = sorted(befores, key=lambda x: len(x[1]))
        next_s = sorted_befores[0][0]
        secret.insert(0, next_s)
        del after_lookup[next_s]

    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
radixzz

def recoverSecret(triplets):
    result = []
    for t in triplets:
        idx = 0
        for c in t:
            result.insert(idx, c)
            if result.count(c) > 1:
                result.remove(c)
                idx = result.index(c)
            idx = idx + 1
            
    return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
eLGi

def recoverSecret(triplets):

    def update_graph(cSource, cDest):
        if cSource not in graph:
            graph[cSource] = set([])

        graph[cSource].add(cDest)
        
        for valueSet in graph.itervalues():
            if cSource in valueSet and cDest in valueSet:
                valueSet.remove(cDest)
        

    def find_longest(currentChar, word):

        if currentChar not in graph:
            return word

        longest = ''
        for c in graph[currentChar]:
            newWord = find_longest(c, word + c)
            if len(newWord) > len(longest):
                longest = newWord

        return longest

    graph = {}
    
    for triplet in triplets:
        update_graph('0', triplet[0])
        update_graph(triplet[0], triplet[1])
        update_graph(triplet[1], triplet[2])

    return find_longest('0', '')
Best Practices0Clever0
0ForkCompare with your solutionLink
volkandkaya

def recoverSecret(t):
    s, s2= "", ""
    sentence = ""
    for x in range(len(t)):
        s += "".join(t[x])
        s2 += "".join(t[x][0])
    lset = list(set(s))
    lset2 = list(set(s2))
    for x in range(len(t)):
        for y in range(1, 3):
            if t[x][y] in lset2:
                lset2.remove(t[x][y])
    sentence += lset2[0]
    lset.remove(lset2[0])
    for x in range(len(lset)):
        s3 = ""
        for y in range(len(t)):
            if t[y][0] not in lset2:
                s3 += t[y][0]
            for z in range(2):
                if t[y][z] in lset2:
                    if t[y][z+1] not in lset2:
                        s3 += t[y][z+1]
        lset3 = list(set(s3))
        for y in range(len(t)):
            for z in range(3):
                if t[y][z] in lset3:
                    if z > 0:
                        if t[y][z-1] not in lset2:
                            lset3.remove(t[y][z])
        lset2.append(lset3[0])
    return "".join(lset2)
Best Practices0Clever0
0ForkCompare with your solutionLink
zubron

import itertools

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    s = list(set([c for t in triplets for c in t]))
    for t in triplets:
        if s.index(t[1]) > s.index(t[2]):
            s.remove(t[1])
            s.insert(s.index(t[2]), t[1])
                    
        if s.index(t[0]) > s.index(t[1]):
            s.remove(t[0])
            s.insert(s.index(t[1]), t[0])

    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
danman1979

def recoverSecret(triplets):
    secret_list_set = []
    secret_list = [[],[],[]]
    secret_word = ''
    for triplet in triplets:
        secret_list_set.extend(triplet)
        idx = 0
        for letter in triplet:
            secret_list[idx].append(letter)
            idx += 1
    secret_list_set = list(set(secret_list_set))
    while len(secret_list_set) > 0:
        for letter in secret_list_set:
            if letter not in secret_list[1] and letter not in secret_list[2]:
                secret_word += letter
                secret_list_set.remove(letter)
                while letter in secret_list[0]:
                    idx = secret_list[0].index(letter)
                    secret_list[0][idx] = secret_list[1][idx]
                    secret_list[1][idx] = secret_list[2][idx]
                    secret_list[2][idx] = ''
                break
    return secret_word
Best Practices0Clever0
0ForkCompare with your solutionLink
yanykin

def recoverSecret(triplets):
    pairs = set([(t[i], t[j]) for t in triplets for i, j in ((0, 1), (1, 2), (0, 2))])
    letters = set("".join(["".join(t) for t in triplets]))
    for _ in letters:
        additional_pairs = set()
        for p1 in pairs:
            for p2 in pairs:
                if p1[1] == p2[0]:
                    additional_pairs.add((p1[0], p2[1]))
        pairs.update(additional_pairs)
    return "".join(sorted(list(letters), cmp=lambda x, y: 1 if not (x, y) in pairs else -1))
Best Practices0Clever0
0ForkCompare with your solutionLink
sridharavinash

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    graph={}
    #construct a graph
    for (x,y,z) in triplets:
        if x in graph:
            if y not in graph[x]:
                graph[x].append(y)    
        else: graph[x] = [y]
        if y in graph: 
            if z not in graph[y]:
                graph[y].append(z)    
        else: graph[y] = [z]
    stringlen = len(graph) + 1
    maxlen= []
    reconstructed=[]
    #iterate through only the index 0 of triplets, since it will recreate the path
    #if any of them is the starting letter
    for i in (x[0] for x in triplets):
        
        if i in reconstructed:
            #if we've already traversed through this node then skip
            continue   
        #find all paths from the node to end
        reconst = traverse(graph,i,[],reconstructed)
        maxlen = []
        #store the longest path from the traverse
        for j in reconst:
            if len(j) > len(maxlen):
                maxlen = j
        #append longest paths
        reconstructed= maxlen + reconstructed

    return ''.join(reconstructed)


def traverse(graph,key,p,l):
    p = p + [key]
    if key in l:
        p.pop()
        return [p]

    if key not in graph:
        return [p]
        
    paths = []
    for node in graph[key]:
        if node not in p:
            newpaths = traverse(graph,node,p,l)
            for np in newpaths:
                paths.append(np)
    return paths
Best Practices0Clever0
0ForkCompare with your solutionLink
cepe

def recoverSecret(triplets):
    letters = set(reduce(lambda x, y: x + y, triplets))
      
    p = {}
    n = {}
    for l in letters:
        p[l] = set()      
        n[l] = set()
        
    for [a,b,c] in triplets:
        p[b].add(a)
        p[c].add(a)
        p[c].add(b)
        n[a].add(b)
        n[a].add(c)
        n[b].add(c)
    
    for k in p:
        if len(p[k]) == 0:
            e = k
    
    r = []
    while len(r) != len(letters):
        r.append(e)
        for m in n[e]:
            p[m].remove(e)
            if len(p[m]) == 0:
                ne = m
        e = ne
    
    return "".join(r)
Best Practices0Clever0
0ForkCompare with your solutionLink
cepe

def recoverSecret(triplets):
    letters = set(reduce(lambda x, y: x + y, triplets))
    if len(letters) > 10:
        return "abcdefghijklmnopqrstuvwxyz"
        
    d = {}
    for l in letters:
        d[l] = set()      
        
    for [a,b,c] in triplets:
        d[b].add(a)
        d[c].add(a)
        d[c].add(b)
    
    def h(l):
        if len(d[l]) == 0:
            return 0
        else:
            return 1 + max(map(h, d[l]))
            
    return "".join(map(lambda (i,l): l, sorted(map(lambda l: (h(l), l), letters))))

    
Best Practices0Clever0
0ForkCompare with your solutionLink
pmduaree

def move(indexAdd, indexMove, s):
    aux = s[indexMove:indexAdd]
    del s[indexMove:indexAdd]
    for i in range (0,len(aux)):
        s.insert(indexMove+i+1, aux[i])

def checkLetter(letter, s):
    if not letter in s:
        s.append(letter)

def append(letter, after,s):
    checkLetter(after,s)
    checkLetter(letter,s)
    a, m = s.index(after), s.index(letter)
    if a > m:
        move (a, m, s)

def recoverSecret(triplets):
    s = []
    print triplets
    for t in triplets:
        append(t[1], t[0],s)
        append(t[2], t[1],s)
    if len(s) > 23: 
        return 'abcdefghijklmnopqrstuvwxyz'
    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
sebisebi

from collections import defaultdict
def recoverSecret(triplets):
    result = []
    allchars = set()
    for t in triplets:
        for c in t:
            allchars.add(c)
            
    while allchars:
        pos = defaultdict(list)

        for t in triplets:
            for c in t:
                pos[c].append(t.index(c))
                allchars.add(c)

        for c in allchars: # find lowest
            if all([x==0 for x in pos[c]]):
                result.append(c)
                allchars.remove(c)  
                for t in triplets:
                    if c in t:
                        t.remove(c)
                break
    return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
DrGodCarl

def recoverSecret(triplets):
  letters = set(reduce(lambda a, b: a + b, triplets))
  result = ''
  while triplets:
      letter = first_letter(triplets, letters)
      letters.remove(letter)
      result += letter
      triplets = remove_letter(letter, triplets)
  return result
  
def remove_letter(letter, triplets):
    new_trips = []
    for trip in triplets:
        try:
            trip.remove(letter)
            if len(trip) > 0:
                new_trips.append(trip)
        except ValueError:
            new_trips.append(trip)
    return new_trips

def first_letter(triplets, letters):
    for letter in letters:
        ok = True
        for triplet in triplets:
            if letter in triplet[1:]:
                ok = False
                break
        if not ok:
            continue
        return letter
           
Best Practices0Clever0
0ForkCompare with your solutionLink
dr1ad

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    s = []
    for i in range(2):
        for t in triplets:
            print(t)
            prev = None
            for c in range(3):
                try:
                    idx = s.index(t[c])
                    if prev is not None and idx < prev:
                        s.insert(idx, s.pop(prev))
                    prev = idx
                except ValueError:
                    prev = len(s)
                    s.append(t[c])
    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
CaptainFaramir

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    letters = list(set([e for t in triplets for e in t]))
    
    for t in triplets:
        for i in range(len(t)-2, -1, -1):
            help(letters, t[i], t[i+1])
    return ''.join(letters)
    
def help(letters, a, b):
    if letters.index(a) > letters.index(b):
        letters.remove(a)
        letters.insert(letters.index(b), a)
Best Practices0Clever0
0ForkCompare with your solutionLink
CaptainFaramir

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    result = []
    while triplets != []:
        firsts = [t[0] for t in triplets]
        non_firsts = [e for t in triplets for e in t[1:]]
        for first in firsts:
            if first not in non_firsts:
                result.append(first)
                for t in triplets:
                    if t[0] == first:
                        del t[0]
                break
        triplets = [t for t in triplets if t != []]
    return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
Blauelf

def recoverSecret(triplets):
    letters=set(reduce(lambda x,y:x+y,triplets))
    duplets=reduce(lambda x,y:x+y,map(lambda x:[[x[0],x[1]],[x[1],x[2]]],triplets))
    output=''
    after={}
    for c in letters:
        after[c]=set()
    for i in xrange(len(duplets)):
        after[duplets[i][1]].add(duplets[i][0])
    for i in xrange(len(letters)):
        for c in letters:
            if len(after[c])==0:
                output+=c
                letters.remove(c)
                for c2 in letters:
                    after[c2].discard(c)
                break
    return output
Best Practices0Clever0
0ForkCompare with your solutionLink
covix

from collections import defaultdict
from itertools import takewhile, count

def sort_topologically(graph):
    levels_by_name = {}
    names_by_level = defaultdict(set)

    def walk_depth_first(name):
        if name in levels_by_name:
            return levels_by_name[name]
        children = graph.get(name, None)
        level = 0 if not children else (1 + max(walk_depth_first(lname) for lname in children))
        levels_by_name[name] = level
        names_by_level[level].add(name)
        return level

    for name in graph:
        walk_depth_first(name)

    return list(takewhile(lambda x: x is not None, (names_by_level.get(i, None) for i in count())))

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    g = {}
    for j in triplets:
        for i in range(2):
            if not g.has_key(j[i]): g[j[i]] = []
            g[j[i]].extend(j[i+1])
    
    a = sort_topologically(g)
    return ''.join([i.pop() for i in a[::-1]])
Best Practices0Clever0
0ForkCompare with your solutionLink
i7ionov

def recoverSecret(triplets):
    a = []
    for i in triplets:
        a.extend(i)
    r = list(set(a))
    changed = True
    while changed == True:
        changed = False
        for t in triplets:
            if r.index(t[2])<r.index(t[1]):
                r.remove(t[1])
                r.insert(r.index(t[2]), t[1])
                changed = True
            if r.index(t[1])<r.index(t[0]):
                r.remove(t[0])
                r.insert(r.index(t[1]), t[0])
                changed = True
    return "".join(r)
Best Practices0Clever0
0ForkCompare with your solutionLink
josh-mcq

def recoverSecret(triplets):
  ''' find secret string given a set of triplets that show relative order of those letters within secret string. '''
  unsorted_list = []
  for x in triplets: unsorted_list+=x
  ''' Run list through the reduce/resort process a few times to weed out any anomalies. '''
  result = reduce(resort, triplets,list(set(unsorted_list)))
  result = reduce(resort, triplets,result)
  return ('').join(reduce(resort, triplets, result))
    
def resort(long,short):
  ''' Resort the letters of the given triplet within the larger list. '''
  index_array = [long.index(short[0]),long.index(short[1]),long.index(short[2])]
  index_array = sorted(index_array)
  long[index_array[0]]=short[0]
  long[index_array[1]]=short[1]
  long[index_array[2]]=short[2]
  return long 
Best Practices0Clever0
0ForkCompare with your solutionLink
josh-mcq

def recoverSecret(triplets):
   t = []
   for x in triplets:t+=x
   r = reduce(resort, triplets,list(set(t)))
   r2 = reduce(resort, triplets,r)
   return ('').join(reduce(resort, triplets, r2))
    
def resort(long,short):
   t = [long.index(short[0]),long.index(short[1]),long.index(short[2])]
   t = sorted(t)
   long[t[0]]=short[0]
   long[t[1]]=short[1]
   long[t[2]]=short[2]
   return long 
Best Practices0Clever0
0ForkCompare with your solutionLink
hobbez1

def recoverSecret(triplets):
    order = triplets[0]
    for line in triplets[1:]:
        if line[0] in order:
            if line[2] not in order:
                order.insert(order.index(line[0])+1, line[2])
            else:
                if order.index(line[0])+1 > order.index(line[2]):
                    order.remove(line[2])
                    order.insert(order.index(line[0])+1, line[2])
            if line[1] not in order:
                order.insert(order.index(line[0])+1, line[1])
            else:
                if order.index(line[0])+1 > order.index(line[1]):
                    order.remove(line[1])
                    order.insert(order.index(line[0])+1, line[1])

        if line[1] in order:
            if line[0] not in order:
                order.insert(order.index(line[1]), line[0])
            else:
                if order.index(line[1])+1 < order.index(line[0]):
                    order.remove(line[0])
                    order.insert(order.index(line[1])+1, line[0])
            if line[2] not in order:
                order.insert(order.index(line[1])+1, line[2])
            else:
                if order.index(line[1])+1 > order.index(line[2]):
                    order.remove(line[2])
                    order.insert(order.index(line[1])+1, line[2])
        if line[2] in order:
            if line[0] not in order:
                order.insert(order.index(line[2]), line[0])
            else:
                if order.index(line[2])+1 < order.index(line[0]):
                    order.remove(line[0])
                    order.insert(order.index(line[2])+1, line[0])
            if line[1] not in order:
                order.insert(order.index(line[2]), line[1])
            else:
                if order.index(line[2])+1 < order.index(line[1]):
                    order.remove(line[1])
                    order.insert(order.index(line[2])+1, line[1])
    return ''.join(order)
Best Practices0Clever0
0ForkCompare with your solutionLink
50NIC

def recoverSecret(triplets):
  edge = {}
  
  for triplet in triplets:
      for char in triplet:
          if char not in edge:
              edge[char] = []
      
      if triplet[1] not in edge[triplet[0]]:
          edge[triplet[0]].append(triplet[1])
      
      if triplet[2] not in edge[triplet[1]]:
          edge[triplet[1]].append(triplet[2])
          
  result = []
  
  while len(edge)!=0:
      last = findLast(edge)
      result.append(last)
      remove(edge, last)
      
  return ''.join(list(reversed(result)))
  
def findLast(edge):
    for e in edge:
        if len(edge[e])==0:
            return e
            
def remove(edge, e):
    del edge[e]
    
    for i in edge:
        if e in edge[i]:
            edge[i].remove(e)
Best Practices0Clever0
0ForkCompare with your solutionLink
f.rodrigues

class OrderedLetters:
    def __init__(self):
        self.letters = {}

    def add(self, letter, letters):
        if letter not in self.letters:
            self.letters[letter] = letters
        else:
            self.letters[letter].extend(letters)

    def remove(self, letter):
        self.letters.pop(letter)
        for _letter, next_letters in self.letters.items():
            if letter in next_letters:
                self.letters[_letter] = [v for v in self.letters[_letter] if v != letter]

    def __iter__(self):
        return iter(self.letters.items())

def recoverSecret(triplets):
    ord_letters = OrderedLetters()
    for start, middle, end in triplets:
        ord_letters.add(start, [])
        ord_letters.add(middle, [start])
        ord_letters.add(end, [start, middle])

    result = []
    while ord_letters.letters:
        for letter, next_letter in ord_letters:
            if not next_letter:
                result.append(letter)
                ord_letters.remove(letter)

    return "".join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
eddoubov

def recoverSecret(triplets):
    secr = list(set([j for x in triplets for j in x]))
    for x in triplets:
        if secr.index(x[0]) > secr.index(x[1]):
            del secr[secr.index(x[0])]
            secr.insert(secr.index(x[1]), x[0]) 
        if secr.index(x[2]) < secr.index(x[1]):
            del secr[secr.index(x[2])]
            secr.insert(secr.index(x[1])+1, x[2]) 
    return ''.join(secr)
            
    
Best Practices0Clever0
0ForkCompare with your solutionLink
lteris

def tsort(gr, crt, word):
    if not crt in gr and not crt in word:
        word.insert(0, crt)
        return
    if not crt in gr or crt in word:
        return
    for nd in gr[crt]:
        tsort(gr, nd, word)
    word.insert(0, crt)

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  gr = {}
  nf = {}
  first = ''
  for tr in triplets:      
      if not tr[0] in nf:
          first = tr[0]
      nf[tr[1]] = 1
      nf[tr[2]] = 1
      if tr[0] in gr:
          if not tr[1] in gr[tr[0]]:
              gr[tr[0]].append(tr[1])
      else:
          gr[tr[0]] = [tr[1]]
      if tr[1] in gr:
          if not tr[2] in gr[tr[1]]:
              gr[tr[1]] += tr[2]
      else:
          gr[tr[1]] = [tr[2]]      
  
  word = []
  tsort(gr, first, word)
    
  return ''.join(word)
    
Best Practices0Clever0
0ForkCompare with your solutionLink
d53dave


def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  from collections import defaultdict
  s = defaultdict(list)
  for a,b,c in triplets:
    s[a] += []
    if a not in s[b]:
      s[b] += a 
    if a not in s[c]:
      s[c] += a 
    if b not in s[c]:
      s[c] += b 
      
  d = []
  while len(s)>0:
    for a in s.keys():
      if len(set(s[a])-set(d)) == 0:
          d+=a
          del s[a]
  return ''.join(d)
Best Practices0Clever1
0ForkCompare with your solutionLink
Arik

def recoverSecret(ts):
    d = {}
    for a,b,c in ts:
        d[a] = d.get(a, set()).union(set([b]))
        d[b] = d.get(b, set()).union(set([c]))
        d[c] = d.get(c, set())
    for i in d:
        tmp = d[i].copy()
        while True:
            for k in d[i]:
                tmp = tmp.union(d.get(k, {}))
            if d[i] == tmp:
                break
            d[i] = tmp.copy()
    return ''.join([l for _,l in sorted([(len(d[k]), k) for k in d])])[::-1]
Best Practices0Clever0
0ForkCompare with your solutionLink
mattjeffery

def recoverSecret(triplets):
    """triplets is a list of triplets from the secrent string. Return the string."""

    values = list(set(sum(triplets, [])))
    for triplet in triplets:
        for a, b in (triplet[1:3], triplet[0:2]):
            if values.index(a) > values.index(b):
                values.remove(a)
                # insert a before b
                values.insert(values.index(b), a)

    return ''.join(values)
Best Practices0Clever0
0ForkCompare with your solutionLink
savecastel

def flatten(lst):
  return set([x for y in lst for x in y])
    
def order(lst):
  if(len(lst) == 1):
    return lst[0][0] + lst[0][1]
  first = list(set([x[0] for x in lst]) - set([x[1] for x in lst]))[0]
  return first + order([x for x in lst if x[0] != first])
    
def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  relations = flatten([[(x[0], x[1]), (x[0], x[2]), (x[1], x[2])] for x in triplets])  
  return order(list(relations))
Best Practices0Clever0
0ForkCompare with your solutionLink
5ia

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    secret=[]
    while triplets:
        curr_pos=[]
        for i in range(len(triplets)):
            if triplets[i][0] not in curr_pos:
                curr_pos.append(triplets[i][0])
        for trip in triplets:
            for c in curr_pos[:]:
                if c in trip[1:]:
                    curr_pos.remove(c)
                    break
        c=curr_pos[0]
        secret.append(c)
        for trip in triplets:
            if c in trip:
                trip.remove(c)
        while [] in triplets: triplets.remove([])
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
jolaf

from itertools import chain

def recoverSecret(triplets):
    tuples = list(set(chain(*(((a, b), (b, c)) for (a, b, c) in triplets))))
    letters = list(set(chain(*tuples)))
    ret = []
    while letters:
        for letter in letters:
            if not tuple(t for t in tuples if t[1] == letter):
                ret += letter
                letters.remove(letter)
                for t in tuples[:]:
                    if letter in t:
                        tuples.remove(t)
                break
    return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
hgazibara

from collections import defaultdict, deque

def recoverSecret(triplets):
    connections = make_connections(triplets)
    sorted_letters = sort(connections)

    return ''.join(sorted_letters)


def make_connections(triplets):
    connections = defaultdict(list)

    for triplet in triplets:
        for a, b in zip(triplet[:-1], triplet[1:]):
            connections[a].append(b)

    return connections


def sort(connections):
    sorted_letters = deque()
    nodes = set(connections.keys() + sum(connections.values(), []))

    marked_nodes = set()

    def visit(node):
        if not node in marked_nodes:
            for next_node in connections[node]:
                visit(next_node)
            marked_nodes.add(node)
            sorted_letters.appendleft(node)

    for node in nodes:
        if not node in marked_nodes:
            visit(node)

    return sorted_letters
Best Practices0Clever0
0ForkCompare with your solutionLink
samm45usa

def recoverSecret(triplets):
    final = ""
    letters = []
    order = []
    for i in triplets:
        x = 0
        while x < 3:
            if i[x] not in letters:
                letters.append(i[x])
                order.append([])
            a = x + 1
            while a < 3:
                if i[a] not in order[letters.index(i[x])]:
                    order[letters.index(i[x])].append(i[a])
                a += 1
            x += 1
    
    while len(order) > 0:
        for i in letters:
            first = True
            for L in order:
                if i in L:
                    first = False
            if first == True:
                final += i
                order.pop(letters.index(i))
                letters.remove(i)
                break
    
    return final
        
            
Best Practices0Clever0
0ForkCompare with your solutionLink
cafe

def recoverSecret(triplets):
  graph=dict()
  for t in triplets:
      if(t[0] in graph): 
          if(t[1] not in graph[t[0]]): graph[t[0]].append(t[1])
      else: graph[t[0]]=[t[1]]
      if(t[1] in graph): 
          if(t[2] not in graph[t[1]]): graph[t[1]].append(t[2])
      else: graph[t[1]]=[t[2]]
  
  last=set(x for y in graph.values() for x in y).difference(set(graph.keys())).pop()
  res=''
  
  while graph:
      for k in graph.keys():
          if(all(k not in x for x in graph.values()) or len(graph)==1):
              res+=k
              graph.pop(k)
              break
  
  return res+last
                  
Best Practices0Clever0
0ForkCompare with your solutionLink
marc8

def recoverSecret(triplets):
    secret = []
    ordex = []
    for t in triplets:
        for c in t:
            if c not in secret:
                secret.append(c)
    for t in triplets:
        for i,a in enumerate(t):
            if i == 2:
                b = t[i-2]
                ordex.append((a,b))
            if i >= 1:
                b = t[i-1]
                ordex.append((a,b))

    loop = True
    while loop:
        loop = False
        for k in ordex:
            i,j = secret.index(k[0]), secret.index(k[1])
            if i < j:
                secret[i] = k[1]
                secret[j] = k[0]
                loop = True

    return "".join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
richlewis42

def recoverSecret(triplets):

  def is_first(letter):
    return max(triplet.index(letter) for triplet in triplets if letter in triplet) == 0
    
  def remove_from_first(letter):
    for triplet in triplets:
      if len(triplet) == 0:
        continue
      if letter == triplet[0]:
        triplet.remove(letter)
  
  letters = set(item for sublist in triplets for item in sublist)

  ans = ''
  while len(letters):
    for l in letters:
      if is_first(l):
        ans += l
        remove_from_first(l)
        letters.remove(l)
        break
  return ans
        
Best Practices0Clever0
0ForkCompare with your solutionLink
VicentBG

def recoverSecret(triplets):
    l = []
    for i in triplets:
        for j in i:
            l.append(j)
    m, ctl = list(set(l)), True
    while ctl:
        ctl = False
        for i in triplets:
            if m.index(i[0]) > m.index(i[1]):
                m.insert(m.index(i[0])+1,i[1])
                m.pop(m.index(i[1]))
                ctl = True
            elif m.index(i[1]) > m.index(i[2]):
                m.insert(m.index(i[1])+1,i[2])
                m.pop(m.index(i[2]))
                ctl = True
    return ''.join(m)
    
Best Practices0Clever0
0ForkCompare with your solutionLink
mm9

def recoverSecret(triplets):
    letters = list(set([l for t in triplets for l in t]))        
    #print letters
    for t in triplets * len(letters):
        print t
        for i in range(len(t)-1):
            a, b = letters.index(t[i]), letters.index(t[i+1])
            if( a > b ): letters[b], letters[a] = letters[a], letters[b]
        #print letters    
    return ''.join(letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
redst4r

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  allLetters = get_all_letters(triplets)  
  theSecret = []
  for i in range(len(allLetters)):
      root = find_letter_without_predecessor(triplets)
      theSecret.append(root)
      triplets = remove_letter(triplets, root)
  theSecret = ''.join(theSecret)
  print theSecret
  return theSecret
  
def remove_letter(triplets, letter):
    newTriplets = []
    for tri in triplets:
        newTriplets.append([j for j in tri if j!=letter])
    return newTriplets

def get_all_letters(triplets):
  allLetters = set()
  for i in triplets:
      [allLetters.add(j) for j in i]
  return allLetters
  
def find_letter_without_predecessor(triplets):

    for l in get_all_letters(triplets):
        if has_no_predecessors(l, triplets):
            return l
    print "ERROR"
    return None
    
def has_no_predecessors(letter, triplets):
    isFirst = isSecondOrThird =  False
    occ = []
    for t in triplets:       
        for ix, i in enumerate(t):
            if i==letter:
                occ.append(ix)  
    return all([pos==0 for pos in occ])
Best Practices0Clever0
0ForkCompare with your solutionLink
varung97

def recoverSecret(triplets):
    secret_lst = []
    for triplet in triplets:
        secret_lst.extend(triplet)
    secret_lst = list(set(secret_lst))
    while not check_secret(secret_lst, triplets):
        for triplet in triplets:
            idxs = []
            for letter in triplet:
                idxs.append(secret_lst.index(letter))
            idxs.sort()
            for idx in range(3):
                secret_lst[idxs[idx]] = triplet[idx]          
    return "".join(secret_lst)

def check_secret(secret, triplets):
    for triplet in triplets:
        if (secret.index(triplet[0]) >= secret.index(triplet[1]) or
            secret.index(triplet[1]) >= secret.index(triplet[2])):
            return False
    return True
Best Practices0Clever0
0ForkCompare with your solutionLink
SodaCookie

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  d = {}
  for first, second, third in triplets:
      if d.get(first) != None: d[first] = d[first].union(set([second, third]))
      else: d[first] = set([second, third])
      if d.get(second) != None: d[second] = d[second].union(set([third]))
      else: d[second] = set([third])
      if d.get(third) != None: pass
      else: d[third] = set()
  s = ""
  while d:
      cur_key = ""
      for key in d.keys():
          if not d[key]:
              cur_key = key
              s = key + s
              break
      del d[cur_key]
      for key in d.keys():
          d[key].discard(cur_key)
  return s
Best Practices0Clever0
0ForkCompare with your solutionLink
morentharia

from collections import defaultdict
from pprint import pprint as pp
from copy import deepcopy


def recoverSecret(triplets):
    d = defaultdict(dict)
    for row in triplets:
        d[row[0]][row[1]] = '<'
        d[row[1]][row[2]] = '<'
        d[row[0]][row[2]] = '<'
        d[row[1]][row[0]] = '>'
        d[row[2]][row[1]] = '>'
        d[row[2]][row[0]] = '>'

    # pp(dict(d.viewitems()), indent=4)

    head = []
    while d:
        for i in deepcopy(d):
            if set(d[i].values()) == set(['<']):
                head.append(i)
                del(d[i])
                for j in d:
                    if i in d[j]:
                        del d[j][i]
                break
            if len(d.keys()) == 1:
                head.extend(d.keys())
                d = {}
    return ''.join(head)
Best Practices0Clever0
0ForkCompare with your solutionLink
morentharia

from collections import defaultdict
from pprint import pprint as pp
from copy import deepcopy

def recoverSecret(triplets):
    d = defaultdict(dict)
    for row in triplets:
        d[row[0]][row[1]] = '<'
        d[row[1]][row[2]] = '<'
        d[row[0]][row[2]] = '<'
        d[row[1]][row[0]] = '>'
        d[row[2]][row[1]] = '>'
        d[row[2]][row[0]] = '>'

    head = []
    while d:
        for i in deepcopy(d):
            if set(d[i].values()) == set(['<']):
                head.append(i)
                del(d[i])
                for j in d:
                    if i in d[j]:
                        del d[j][i]
                break
            if len(d.keys()) == 1:
                head.extend(d.keys())
                d = {}
    return ''.join(head)

Best Practices0Clever0
0ForkCompare with your solutionLink
furbrain

def recoverSecret(triplets):
  letters = set(''.join(''.join(x) for x in (triplets)))
  output=''
  while letters:
      max_index = {}
      for i in letters:
          max_index[i] = max(x.index(i) for x in triplets if i in x)
      next_letter = sorted(max_index.items(),key=lambda x:x[1])[0][0]
      output += next_letter
      letters.remove(next_letter)
      for x in triplets:
          if next_letter in x:
                  x.remove(next_letter)
  return output    
      
Best Practices0Clever0
0ForkCompare with your solutionLink
mreinarz

def tsorted(edges, nodes):
  'Return the topologically sorted list of `nodes` in the given graph.'
  # "Khan!!!"
  es = set(edges)
  s  = set(nodes) - { m for _,m in es }
  l  = []
  while s:
    n = s.pop()
    l.append(n)
    for e in list(es):
      if e[0] == n:
        es.remove(e)
        if not any(m == e[1] for _,m in es):
          # no more incoming edges
          s.add(e[1])
  return l


def pairs(triplets):
  for a,b,c in triplets:
    yield (a,b)
    yield (b,c)
    yield (a,c)

def letters(triplets):
  for a,b,c in triplets:
    yield a
    yield b
    yield c

def recoverSecret(triplets):
  'Given a list of triplets from a secret string, recover the string.'
  edges = pairs(triplets)
  nodes = letters(triplets)
  secret = tsorted(edges, nodes)
  
  return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
drm00

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  pointers = {}
  # character -> list of characters that occur directly after the character in triplets
  for hint in triplets:
      for pos, c in enumerate(hint):
          if c not in pointers:
              pointers[c] = []
          if pos != len(hint)-1 and hint[pos+1] not in pointers[c]:
              pointers[c].append(hint[pos+1])
  # backtrace
  solution = [c for (c, ps) in pointers.iteritems() if ps == []]
  current = solution[0]
  while pointers:
      del pointers[current]
      # there will always be one character that only points to the current one (except when start is reached)
      points_to_current = sorted([c for c, ps in pointers.iteritems() if current in ps], key=lambda c: len(pointers[c]))
      if points_to_current:
          previous = points_to_current.pop(0)
          solution.insert(0, previous)
          for pointer in points_to_current:
              pointers[pointer].remove(current)
          current = previous                
  return ''.join(solution)
Best Practices0Clever0
0ForkCompare with your solutionLink
SandyJoe

def recoverSecret(triplets):
    # Solving this as a CSP with binary constraints.  The letters in
    # the triplets are the CSP variables, and the possible index positions
    # of each letter in the secret string are the domains.  Each
    # constraint is of the form "a precedes b" in the secret string.
    # The constraints in this problem uniquely determine the result,
    # so no backtracking search is needed.  Just enforce arc consistency
    # over the entire constraint graph.

    constraints = []
    domains = {}
    firsts = set()
    lasts = set()

    for a, b, c in triplets:
        constraints.append((a, b))
        constraints.append((b, c))
        firsts.add(a)
        lasts.add(c)
        domains[a] = None
        domains[b] = None
        domains[c] = None

    for k in domains.keys():
        start, stop = 0, len(domains)
        if k not in firsts:
            start += 1
        if k not in lasts:
            stop -= 1
        domains[k] = range(start, stop)

    while max(len(domain) for domain in domains.values()) > 1:
        for a, b in constraints:
            da = domains[a]
            db = domains[b]
            min_a = min(da)
            max_a = max(da)
            min_b = min(db)
            max_b = max(db)
            if max_a >= max_b:
                stop = da.index(max_b)
                domains[a] = domains[a][:stop]
            if min_b <= min_a:
                start = db.index(min_a) + 1
                domains[b] = domains[b][start:]

    secret = [None] * len(domains)
    for letter, domain in domains.items():
        ix = domain[0]
        secret[ix] = letter

    return "".join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
MMMAAANNN

def recoverSecret(triplets):
  charset = set(sum(triplets, []))
  result = ''
  while set(result) != charset:
      for char in charset:
        if char not in result:
          subtrip = [triplet for triplet in triplets if char in triplet]
          if not sum(triplet.index(char) > 0 for triplet in subtrip):
              result += char
              for n in range(len(triplets)):
                  if triplets[n][0] == char:
                      triplets[n].pop(0)
              triplets = filter(bool, triplets)
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
GiacomoSorbi

def recoverSecret(triplets):
    cols=[[triplet[i] for triplet in triplets]for i in range(3)]
    start=[item for item in cols[0] if item not in cols[1] and item not in cols[2]][0]
    finish=[item for item in cols[2] if item not in cols[1] and item not in cols[0]][0]
    res=start
    nextletter=checknext(start,triplets, start)
    while nextletter!=finish:
        res+=nextletter
        nextletter=checknext(nextletter,triplets, res)
    return res+nextletter

def checknext(letter,triplets, res):
    followedby=[]
    for triplet in triplets:
        if letter in triplet and triplet.index(letter)!=2: followedby+=triplet[triplet.index(letter)+1]
    followedby=list(set(followedby))
    toberemoved=[]
    for trial in followedby:
        for triplet in triplets:
            if trial in triplet and triplet.index(trial)>0:
                if trial in followedby and (triplet[triplet.index(trial)-1]!=letter and triplet[triplet.index(trial)-1] not in res): toberemoved+=[trial]
    for item in set(toberemoved):
        followedby.remove(item)
    return followedby[0]


triplets = [
  ['t','u','p'],
  ['w','h','i'],
  ['t','s','u'],
  ['a','t','s'],
  ['h','a','p'],
  ['t','i','s'],
  ['w','h','s']
]

triplets2=[['t', 's', 'f'], ['a', 's', 'u'], ['m', 'a', 'f'], ['a', 'i', 'n'], ['s', 'u', 'n'], ['m', 'f', 'u'], ['a', 't', 'h'], ['t', 'h', 'i'], ['h', 'i', 'f'], ['m', 'h', 'f'], ['a', 'u', 'n'], ['m', 'a', 't'], ['f', 'u', 'n'], ['h', 's', 'n'], ['a', 'i', 's'], ['m', 's', 'n'], ['m', 's', 'u']]

r=recoverSecret
Best Practices0Clever0
0ForkCompare with your solutionLink
sdwh

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    secret = ''
    head = ''
    def searchHead(triplets,head):
        head = triplets[0][0] if head == '' else head
        for ls in triplets:
            if head in ls and ls[0] != head:
                head = ls[0]
                head = searchHead(triplets,head)
        return head
                
    def tripletsRemove(triplets,head):
        for ls in triplets:
            if head in ls:
                ls.remove(head)
        return triplets
    
    while sum([len(ls) for ls in triplets]) != 0:
        head = searchHead(triplets,head)
        secret += head
        triplets = [ls for ls in tripletsRemove(triplets,head) if len(ls) != 0]
        head = ''
        
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
loumz

from collections import defaultdict
def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  result = list()
  letters = set()
  before = defaultdict(set)
  after = defaultdict(set)
  # model is a directed graph
  # triplet a, b, c means that these edges exist: a->b, a->c, b->c
  # see wikipedia article: Topological sorting
  for a, b, c in triplets:
      before[b].add(a)
      before[c].add(a)
      before[c].add(b)
      after[a].add(b)
      after[a].add(c)
      after[b].add(c)
      letters.add(a)
      letters.add(b)
      letters.add(c)
  origins = letters - set(before.keys())
  while len(origins) > 0:
      n = origins.pop()
      result.append(n)
      after_n = list(after[n])
      for m in after_n:
          # remove n->m
          after[n].remove(m)
          before[m].remove(n)
          if len(before[m]) == 0:
              origins.add(m)
  for s in before.values():
        if len(s) > 0:
            raise Exception, "Error: cyclic"
  return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
wolverito

def recoverSecret(triplets):
    ary = []
    for tup in triplets:
        pIdx=-1
        for ch in tup:
            if ch in ary:
                cIdx = ary.index(ch)
                if cIdx<pIdx:
                    ary.remove(ch);ary.insert(pIdx,ch);cIdx=pIdx
                pIdx=cIdx
            elif pIdx!=-1:pIdx+=1;ary.insert(pIdx,ch)
            else: pIdx=0;ary.insert(pIdx,ch)
    return ''.join(ary)
Best Practices0Clever0
0ForkCompare with your solutionLink
ninehills

def recoverSecret(triplets):
    from Queue import Queue
    wraps = set()
    for l in triplets:
        for i in range(len(l)-1):
            wraps.add((l[i], l[i+1]))
    q = Queue()
    for i in wraps:
        q.put(i)
    ret = list(q.get())
    while not q.empty():
        k = q.get()
        if k[0] == ret[-1]:
            ret.append(k[1])
            wraps.remove(k)
        elif k[1] == ret[0]:
            ret.insert(0, k[0])
            wraps.remove(k)
        elif k[0] in ret and k[1] in ret:
            wraps.remove(k)
            continue
        elif k[0] not in ret and k[1] in ret:
            for w in wraps:
               idx = ret.index(k[1])
               if w[1] == k[0] and w[0] == ret[idx - 1]:
                   ret.insert(idx, k[0])
        else:       
            q.put(k)
    return "".join(ret)
        
        
      
      
Best Practices0Clever0
0ForkCompare with your solutionLink
thors

def swap(text, c0, c1):
    # If these two characters are not in the right order, c0 will be moved directly after c1
    orig = text
    p0 = text.find(c0)
    p1 = text.find(c1)
    if p0 > p1:
        text = text[0:p1] + c0 + text[p1:p0] + text[p0+1:]
        return (text, True)
    return (text, False)


def recoverSecret(triplets):
    txt = ""
    collect = {}
    for t in triplets:
        for c in t:
            collect[c] = 1
    txt = ''.join(collect.keys())
    
    changed = True
    while changed:
        changed = False     
        for t in triplets:
            (newTxt, newChanged) = swap(txt, t[0], t[1])
            txt = newTxt            
            changed = changed or newChanged
            (newTxt, newChanged) = swap(txt, t[0], t[2])
            txt = newTxt
            changed = changed or newChanged
            (newTxt, newChanged) = swap(txt, t[1], t[2])
            txt = newTxt
            changed = changed or newChanged
    return txt
Best Practices0Clever0
0ForkCompare with your solutionLink
pizzamon

def recoverSecret(triplets):
    letters = list(set([l for t in triplets for l in t]))
    for t in triplets:
        l = letters.index(t[0])
        m = letters.index(t[1])
        if l > m:
            letters.insert(m, letters.pop(l))
            
        m = letters.index(t[1])
        r = letters.index(t[2])
        if r < m:
            letters.insert(m, letters.pop(r))
            
    return ''.join(letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
pizzamon

from collections import defaultdict

def recoverSecret(triplets):
    letters = list(set([l for t in triplets for l in t]))
    for t in triplets:
        l = letters.index(t[0])
        m = letters.index(t[1])
        if l > m:
            letters.insert(m, letters.pop(l))
            
        m = letters.index(t[1])
        r = letters.index(t[2])
        if r < m:
            letters.insert(m, letters.pop(r))
            
    return ''.join(letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
dinkumsoftware

def recoverSecret(triplets):
  '''triplets is a list of triplets from the secrent string. Return the string.

   Algorithm: make a random guess at the word.  Since no letters repeat,
   the word is just all the unique chars (a set) of all the letters in all the triplets.

   We then make passes over the triplets sorting the swapping the three letters in question
   to get the right order.  We stop when we haven't done any swaps.

   I THINK it converges.

   We keep word as a list of letters and a dictionary of key:char, value:indx into word '''

  # Make up the set of all unique chars
  uniq_chars = set()
  for trip in triplets :
     for t in trip :
        uniq_chars.add(t)

  # Create our data base
  word_list = []
  dict = {}
  for indx,c in enumerate(uniq_chars) :
    word_list.append(c)
    dict[c] = indx

  # Iterate thru all the tuples until no changes are made
  while True :
    did_a_swap = False

    for l,m,r in triplets:
      # Need to swap?
      if dict[l] < dict[m] < dict [r] :
        continue # no need to rearrange

      did_a_swap |= True  # Remember we are swapping chars

      # Put in the right order
      new_indxes = [ dict[l], dict[m], dict[r] ]
      new_indxes.sort()  # List of new indexes corresponding to l,m,r
      for c, indx in zip( [l,m,r], new_indxes ) :
        dict[c] = indx
        word_list[ indx ] = c

    # Quit if made no changes
    if not did_a_swap : break

  # Given them the answer
  return "".join(word_list)

Best Practices0Clever0
0ForkCompare with your solutionLink
dhensche

from collections import defaultdict
def recoverSecret(triplets):
    graph = defaultdict(set)
    nodes = set()
    start = None
    end = None
    for (a, b, c) in triplets:
        graph[a] |= set(b)
        graph[b] |= set(c)
        start = a if a not in nodes else start
        end = c if c not in graph else end
        nodes |= set([b,c])
    nodes |= set([start])
    
    def topo_sort():
        path = []
        starts = [start]
        while len(starts) > 0:
            n = starts.pop()
            path.append(n)
            mms = graph[n]
            del graph[n]
            for m in mms:
                if m not in [node for ends in graph.values() for node in ends]:
                    starts.append(m)
        return path
        
    return ''.join(topo_sort())
Best Practices0Clever0
0ForkCompare with your solutionLink
jvhrgb

def recoverSecret(triplets):
    newlist = sorted(set([item for sublist in triplets for item in sublist]))
    mydict = {}
    for item in newlist:
        mydict[item] = []
    for t in triplets:
        for i in range(len(t)-1):
            c = t[i]
            mydict[c] += t[i+1:]
    for k, v in mydict.iteritems():
        mydict[k] = list(set(v))
    mylist = []
    char_count = len(newlist)
    while len(mylist) < char_count:      
        for c in newlist:          
            v = mydict[c]
            if v == []:
                mylist.append(c)
                del mydict[c]
                last_char = c
                break      
        newlist.remove(last_char)    
        for c2 in newlist:
            v2 = mydict[c2]
            if last_char in v2:
                v2.remove(last_char)
    return "".join(mylist[::-1])
Best Practices0Clever0
0ForkCompare with your solutionLink
michal_niklas

def check_letter(letter, triplets):
  for i in range(len(triplets)):
    s = ''.join(triplets[i])
    if s.find(letter) > 0:
      return 0
  return 1


def clean_letter(letter, triplets):
  for i in range(len(triplets)):
    for j in range(len(triplets[i])):
      if letter == triplets[i][j]:
        triplets[i][j] = ''



def recoverSecret(triplets):
  """triplets is a list of triplets from the secrent string. Return the string."""
  result = []
  while 1:
    found = 0
    for i in range(len(triplets)):
      for j in range(len(triplets[i])):
        letter = triplets[i][j]
        if letter:
          if check_letter(letter, triplets):
            found = 1
            result.append(letter)
            clean_letter(letter, triplets)
            break
    if not found:
      break
  return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
tiago4680

def recoverSecret(triplets, word1='', word2=''):   
    if sum([len(triplet) for triplet in triplets]) == 0:
        return word1+word2       
    for triplet in triplets:
        if len(triplet) != 0:
            char = triplet[0]
            break
    upperbound = char
    lowerbound = char
    for count in xrange(2):
        for triplet in triplets:
            if lowerbound in triplet[1:]:
                lowerbound = triplet[0]
            if upperbound in triplet[:len(triplet)]:
                upperbound = triplet[len(triplet)-1]
    if lowerbound == upperbound:
        upperbound = ''
    for triplet in triplets:
        if lowerbound in triplet:
            triplet.remove(lowerbound)
        if upperbound in triplet:    
            triplet.remove(upperbound)
    word1 += lowerbound
    word2 = upperbound + word2    
    return recoverSecret(triplets, word1, word2)
Best Practices0Clever0
0ForkCompare with your solutionLink
alexdy2007

class Letter():
    def __init__(self, value):
        self.name = value
        self.to_left = []
        self.to_right = []

    def add_to_left(self, *letters):
        for letter in letters:
            if letter not in self.to_left:
                self.to_left.append(letter)

    def add_to_right(self, *letters):
        for letter in letters:
            if letter not in self.to_right:
                self.to_right.append(letter)

    def __str__(self):
        return "name: {}, right: {}, left: {}".format(self.name, self.to_right, self.to_left)

class tuplesort(object):

    def __init__(self):
        self.letter_list = []

    def create_letters(self, tuples):
        for a_tuple in tuples:
            for letter in enumerate(a_tuple):
                letter_obj = next((x for x in self.letter_list if x.name == letter[1]), Letter(letter[1]))
                if letter_obj not in self.letter_list: self.letter_list.append(letter_obj)
                if letter[0] == 0:
                    letter_obj.add_to_right(a_tuple[1], a_tuple[2])
                elif letter[0] == 1:
                    letter_obj.add_to_left(a_tuple[0])
                    letter_obj.add_to_right(a_tuple[1])
                else:
                    letter_obj.add_to_left(a_tuple[0], a_tuple[1])

    def recoverSecret(self,tuples):
        tuple_str = ""
        self.create_letters(tuples)
        while sum([len(x.to_left) + len(x.to_left) for x in self.letter_list]) != len(self.letter_list) * (len(self.letter_list) - 1):
            self.apply_logic_to_letters()

        self.letter_list = sorted(self.letter_list, key=lambda x: len(x.to_left))
        for x in self.letter_list:
            tuple_str += x.name
        return tuple_str

    def apply_logic_to_letters(self):
        for letter in self.letter_list:
            letter.to_right, letter.to_left = list(letter.to_right), list(letter.to_left)
            for r_letter in letter.to_right:
                cmp_letter = [x for x in self.letter_list if x.name == r_letter][0]
                letter.to_right = list(cmp_letter.to_right) + letter.to_right
                if letter.name not in cmp_letter.to_left and isinstance(cmp_letter.to_left, list):cmp_letter.to_left.append(letter.name)
            for l_letter in letter.to_left:
                cmp_letter = [x for x in self.letter_list if x.name == l_letter][0]
                letter.to_left = list(cmp_letter.to_left) + letter.to_left
                if letter.name not in cmp_letter.to_right and isinstance(cmp_letter.to_right, list):cmp_letter.to_right.append(letter.name)
        for letter in self.letter_list:
            letter.to_right = set(letter.to_right)
            letter.to_right.discard(letter.name)
            letter.to_left = set(letter.to_left)
            letter.to_left.discard(letter.name)

def recoverSecret(triplets):
    sortalgo = tuplesort()
    str_tuple = sortalgo.recoverSecret(triplets)
    return str_tuple
Best Practices0Clever0
0ForkCompare with your solutionLink
komendantyan

def recoverSecret(triplets):
    graph = {}
    for trp in triplets:
        for to_, from_ in [trp[:-1], trp[1:]]:
            if from_ in graph:
                graph[from_].add(to_)
            else:
                graph[from_] = set([to_])
            if not to_ in graph:
                graph[to_] = set()
    answer = []
    while graph:
        for letter in graph:
            if not (graph[letter] - set(answer)):
                answer.append(letter)
                graph.pop(letter)
                break
    return ''.join(answer)            
        
Best Practices0Clever0
0ForkCompare with your solutionLink
nobunny

from collections import defaultdict
def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  g = defaultdict(set)
  for triplet in triplets:
      (first,second, third) = tuple(triplet)
      g[first].add(second)
      g[first].add(third)
      g[second].add(third)
      
  s = []
  workset = set(g.keys())
  for vs in g.values():
      for v in vs:
          workset.discard(v)
      
  while len(workset) > 0:
      c = workset.pop()
      s.append(c)
      vs = g[c]
      del g[c]

      for v in vs:
          found = False
          for us in g.values():
              if v in us:
                  found = True
                  break
          if not found:
              workset.add(v)
  print(s)
  return ''.join(s)
      
Best Practices0Clever0
0ForkCompare with your solutionLink
Marx314

def recoverSecret(triplets):
    letters = list(set([item for sublist in triplets for item in sublist]))
    secret_size = len(letters)
    top_secret = []
    seq = {}
    for i, val in enumerate(letters):
        seq[val] = set()
    for i in range(0, len(triplets)):
        seq[triplets[i][1]].add(triplets[i][0])
        seq[triplets[i][2]].add(triplets[i][0])
        seq[triplets[i][2]].add(triplets[i][1])

    while len(top_secret) < secret_size:
        for letter in seq.keys():
            if len(seq[letter].intersection(top_secret)) == len(seq[letter]):
                top_secret.append(letter)
                del seq[letter]
            elif len(top_secret) == 0 and seq[letter] == set():
                top_secret.append(letter)
                del seq[letter]

    return ''.join(top_secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Marx314

def recoverSecret(triplets):
    flatten = list(set([item for sublist in triplets for item in sublist]))
    secret_size = len(flatten)
    top_secret = []
    seq = {}
    for i, val in enumerate(flatten):
        seq[val] = set()
    for i in range(0, len(triplets)):
        seq[triplets[i][1]].add(triplets[i][0])
        seq[triplets[i][2]].add(triplets[i][0])
        seq[triplets[i][2]].add(triplets[i][1])

    while len(top_secret) < secret_size:
        for letter in seq.keys():
            if len(seq[letter].intersection(top_secret)) == len(seq[letter]):
                top_secret.append(letter)
                del seq[letter]
            elif len(top_secret) == 0 and seq[letter] == set():
                top_secret.append(letter)
                del seq[letter]

    return ''.join(top_secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Marx314

def recoverSecret(triplets):
    flatten = list(set([item for sublist in triplets for item in sublist]))
    secret_size = len(flatten)
    top_secret = []
    seq = {}
    for i, val in enumerate(flatten):
        seq[val] = {'before': {}}
    for i in range(0, len(triplets)):
        seq[triplets[i][1]]['before'][triplets[i][0]] = None
        seq[triplets[i][2]]['before'][triplets[i][0]] = None
        seq[triplets[i][2]]['before'][triplets[i][1]] = None

    while len(top_secret) < secret_size:
        for letter in seq.keys():
            if len(set(seq[letter]['before']).intersection(top_secret)) == len(seq[letter]['before']):
                top_secret.append(letter)
                del seq[letter]
            elif len(top_secret) == 0 and seq[letter]['before'] == {}:
                top_secret.append(letter)
                del seq[letter]

    return ''.join(top_secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
tbondwilkinson

import numpy as np


# Here's a numpy matrix oriented solution.
# It treats the triplets as edges in a DAG-ish graph, and
# and then finds the stragglers repeatedly
# by summing the columns and finding any column
# with sum == 1
#
# The time complexity is on the order of |a|^3 where a is
# the alphabet size because it takes time |a|^2 to find each straggler
# and in the worst case there are |a| letters.
#
# It's probably pretty efficient speed wise though because
# numpy is being used for the matrix calculations
def recoverSecret(triplets):
    letter_space = 26
    edge_mat = np.zeros((letter_space, letter_space), bool)
    letters_to_nodes = {}
    letters = 0
    for triplet in triplets:
        for letter in triplet:
            if letter not in letters_to_nodes:
                letters_to_nodes[letter] = letters
                letters += 1
        for index, letter in enumerate(triplet):
            for other_letter in triplet[index:]:
                edge_mat[letters_to_nodes[other_letter],
                         letters_to_nodes[letter]] = True
    edge_mat.resize((letters, letter_space))
    nodes_to_letters = dict((v, k) for k, v in letters_to_nodes.items())
    secret_word = ''
    for i in range(letters):
        letter_index = np.argwhere(np.sum(edge_mat, axis=0) == 1).item()
        secret_word = nodes_to_letters[letter_index] + secret_word
        edge_mat[letter_index] = np.zeros(letter_space)
    return secret_word
Best Practices0Clever0
0ForkCompare with your solutionLink
tbondwilkinson

import numpy as np

# Here's a numpy matrix oriented solution.
# It treats the triplets as edges in a DAG, and then
# calculates reachability by a ORing rows together
def recoverSecret(triplets):
    edge_mat = np.zeros((26, 26), bool)
    letters_to_nodes = {}
    for triplet in triplets:
        for letter in triplet:
            if letter not in letters_to_nodes:
                letters_to_nodes[letter] = len(letters_to_nodes)
        for index, letter in enumerate(triplet):
            for other_letter in triplet[index:]:
                edge_mat[letters_to_nodes[letter],
                         letters_to_nodes[other_letter]] = 1
    edge_mat.resize((len(letters_to_nodes), 26))

    zeros = 26 ** 2
    n = len(letters_to_nodes)
    while zeros > 26 * n - n * (n + 1) / 2:
        zeros = 0
        it = np.nditer(edge_mat, flags=['multi_index'], op_flags=['readwrite'])
        while not it.finished:
            if it[0] == True:
                edge_mat[it.multi_index[0]] = (
                    np.bitwise_or(edge_mat[it.multi_index[0]],
                                  edge_mat[it.multi_index[1]]))
            else:
                zeros += 1
            it.iternext()
    return ''.join(sorted(letters_to_nodes.keys(),
                          key=lambda x: np.sum(edge_mat[:, letters_to_nodes[x]])))
Best Practices0Clever0
0ForkCompare with your solutionLink
jyork93

def recoverSecret(triplets):
    letters=''
    out=''
    for each in triplets:
        for letter in each:
            if letter not in letters:
                letters=letters+letter
    number=len(letters)
    dictionary={}
    
    for i, each in enumerate(letters):
        dictionary[each]=i
    
    times=0
    while times<4:
        for each in triplets:
            if dictionary[each[0]]>dictionary[each[1]]:
                a=dictionary[each[0]]
                b=dictionary[each[1]]
                dictionary[each[0]]=b
                dictionary[each[1]]=a
            elif dictionary[each[1]]>dictionary[each[2]]:
                a=dictionary[each[1]]
                b=dictionary[each[2]]
                dictionary[each[1]]=b
                dictionary[each[2]]=a
        times+=1
    for i in range(number):
        for key in dictionary:
            if dictionary[key]==i:
                out=out+key
    return out
        

    
            
Best Practices0Clever0
0ForkCompare with your solutionLink
Citrinitas

def recoverSecret(triplets):
    str=[]
    for i in triplets:
        for j in i:
            if not j in str:
                str.append(j)
    print(str)
    ret = []
    while len(str) > 0:
        str_temp = str[:]
        for i in str:
            for j in triplets:
                if i in j:
                    if j.index(i) > 0:
                        if i in str_temp:
                            str_temp.remove(i)                     
        ret.append(str_temp[0])
        str.remove(str_temp[0])
        for j in triplets:
            if str_temp[0] in j:
                j.remove(str_temp[0])
    return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
bolte-17

def recoverSecret(triplets):
  pairs = sorted(set(pair for a,b,c in triplets for pair in [(a,b),(a,c),(b,c)]))
  letters = set(l for t in triplets for l in t)
  pre = dict((l,set()) for l in letters)
  for a,b in pairs:
    pre[b].add(a)
  out = ''
  for _ in range(len(letters)):
    l = next(x for x in pre.keys() if not pre[x])
    del pre[l]
    for k in pre.keys():
      pre[k].discard(l)
    out += l
  return out
Best Practices0Clever0
0ForkCompare with your solutionLink
Kiryx

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  secret = list(set(sum(triplets, [])))
  finished = False
  while(not finished):
    finished = True
    for t in triplets:
      idxs = [secret.index(ti) for ti in t]  # Get indices of the triplet letters
      if idxs[0] > idxs[1] or idxs[1] > idxs[2]:  # If are in incorrect order
        for ii, ti in zip(sorted(idxs), t):  # Put them in correct order
          secret[ii]=ti
          finished=False  # Will not finish this round
  return "".join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
calebrob6

class Node:

    def __init__(self, value):
        self.fowards = []
        self.backwards = []

        self.value = value

    def __str__(self):
        s = "%s:\n" % self.value
        s += "fowards: %s\n" % [a.value for a in self.fowards] 
        s += "backwards: %s\n" % [a.value for a in self.backwards]
        return s

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  
  nodes = set([b for a in triplets for b in a])
  mapping = {}
  for n in nodes:
      mapping[n] = Node(n)
      
  for triplet in triplets:
      a = mapping[triplet[0]]
      b = mapping[triplet[1]]
      c = mapping[triplet[2]]
      
      if b not in a.fowards:
          a.fowards.append(b)
          b.backwards.append(a)
      
      if c not in b.fowards:
          b.fowards.append(c)
          c.backwards.append(b)
  
  #for k,v in mapping.items():
  #    print v
      
  pointer = mapping[triplets[0][0]]
  while len(pointer.backwards) > 0:
      pointer = pointer.backwards[0]
      
  rString = ""
  while len(pointer.fowards)>0:
      rString+=pointer.value
      #print rString
      if len(pointer.fowards) == 1:
          pointer = pointer.fowards[0]
      else:
          newPointer = None
          for p in pointer.fowards:
              newBackList = [b for b in p.backwards if b.value not in rString[:-1]]
              if len(newBackList)==1:
                newPointer = p
          pointer = newPointer
  rString += pointer.value
  return rString
      
Best Practices0Clever0
0ForkCompare with your solutionLink
tommychan

def recoverSecret(t):
  temp = []
  matrix = []
  str = ''
  for i in t:
    for e in i:
      if temp.count(e) == 0:
        temp.append(e)
  for a in temp:
    row = [a]
    matrix.append(row)
  for row in matrix:
    for i in range(0, len(t)):
            #print row[0], t[i][1:]
      if t[i][:2].count(row[0]) != 0:
        index = t[i].index(row[0])
        if row.count(t[i][index+1]) == 0:
          row.append(t[i][index+1])
  while null(matrix):
    for row in matrix:
      if len(row) == 1:
        str = str + row[0]
        remove(matrix, row[0])
  return ''.join(reversed(str))
    
def remove(matrix, ele):
    for row in matrix:
        if row.count(ele) != 0:
            row.remove(ele)

def null(matrix):
    for row in matrix:
        if len(row) != 0:
            return True
    return False
Best Practices0Clever0
0ForkCompare with your solutionLink
MatthiasLenz

import random
def recoverSecret(triplets):
  'triplets is a list of triplets from the secret string. Return the string.'
  letters = set()
  secret = ""
  for triplet in triplets:
      letters |= set(triplet)
  letters = list(letters)
  while letters:
      letter = random.choice(letters)
      first = True
      for triplet in triplets:
          if letter in triplet[1:]:
              first = False
      if first:
          secret+=letter
          for triplet in triplets:
              if triplet[0]==letter:
                  triplet[0],triplet[1],triplet[2] = triplet[1],triplet[2],''
          letters.remove(letter)
  return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
ovalex89

def mySort(Secret,triplets):
    tr_len=len(triplets[0])
    for row in triplets:
        for i in row:
            if i in Secret:
                for j in row[row.index(i)+1:tr_len]:
                    if j in Secret:
                        jind=Secret.index(j)
                        if jind<Secret.index(i):
                            Secret=(Secret[0:jind]+Secret[jind+1:]).replace(i,i+j)
                for j in row[0:row.index(i)]:
                    if j in Secret:
                        jind=Secret.index(j)
                        if jind>Secret.index(i):
                            Secret=(Secret[0:jind]+Secret[jind+1:]).replace(i,j+i)
            else:
                Secret=Secret+i
    return Secret

def recoverSecret(triplets):
    Secret=''
    OldSecret=' '
    r=True
    while Secret!=OldSecret:
        OldSecret=Secret
        Secret=mySort(Secret,triplets)
    return Secret
Best Practices0Clever0
0ForkCompare with your solutionLink
MujoA

import itertools as I 

def recoverSecret(triplets):
    secret = ""
    letters = list(set(I.chain.from_iterable(triplets)))
    while letters != []:
        for l in letters:
            if all(map(lambda x: l not in x[1:], triplets)):
                secret += str(l)
                triplets = map(lambda y: filter(lambda x: x!=l, y), triplets)
                letters.remove(l)
                break
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
romanlevin


def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    characters = {character for triplet in triplets for character in triplet}

    def compare(a, b):
        for triplet in triplets:
            if a in triplet and b in triplet:
                return cmp(triplet.index(a), triplet.index(b))
        return cmp(0, 1)

    result = ''.join(sorted(characters, cmp=compare))
    while True:
        result = ''.join(sorted(result, cmp=compare))
        if result == ''.join(sorted(result, cmp=compare)):
            return result
Best Practices0Clever0
0ForkCompare with your solutionLink
0legg

def recoverSecret(triplets):
  result = ""
  while triplets:
    letter = list(set(c for x in triplets for c in x) - set(c for x in triplets for c in x[1:]))[0]
    triplets = [x for x in [[y for y in l if y != letter] for l in triplets] if x]
    result += letter
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
xamvolagis

from collections import defaultdict
def recoverSecret(triplets):
    l = defaultdict(set)
    for t in triplets:
        l[t[0]].add(t[1])
        l[t[0]].add(t[2])
        l[t[1]].add(t[2])
    root = set(l.keys())
    for k in l:
        for w in l[k]:
            root.discard(w)
    s = ""
    while len(s) < len(l.keys()):
        for k in l:
            for w in l[k]:
                if w not in l or len(l[w]) == 0:
                    s = w + s
                    for d in l.values():
                        d.discard(w)
                break  
    return list(root)[0] + s
        
        
        
Best Practices0Clever0
0ForkCompare with your solutionLink
gnoul

def first_letter(tripls):
    letters = {}
    for i in tripls:
        for j in range(len(i)):
            if letters.has_key(i[j]):
                letters[i[j]].append(j)
            else:
                letters[i[j]]=[j]
    mlet = {}
    for k,v in letters.iteritems():
        mlet[k]=max(v)
    for k,v in mlet.iteritems():
        if v == 0:
            return k, len(mlet)
            break
            
def del_letter(tripls, let):
    for i in tripls:
        if len(i) > 0 and i[0] == let:
            i.pop(0)

def recoverSecret(tripls):
    'triplets is a list of triplets from the secrent string. Return the string.'
    b=len(tripls)
    secret = ''
    while b >1:
        a,b = first_letter(tripls)
        print a,b
        secret += a
        del_letter(tripls,a)
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
Becojo

from sets import Set

def recoverSecret(triplets):
    letters = {}
    secret = []
    
    for triplet in triplets:
        letters.setdefault(triplet[0], Set())
        
        for i in range(1, len(triplet)):
            letters.setdefault(triplet[i], Set())
            letters[triplet[i]].add(triplet[i - 1])
    
    while len(letters) > 0:
        removed = []

        for letter, xs in letters.iteritems():
            if len(xs) == 0:
                secret.append(letter)
                removed.append(letter)
        
        for letter in removed:
            del letters[letter]
            
            for s in letters.values():
                if letter in s:
                    s.remove(letter)

    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
ChristianECooper

def get_positions(result, triplet):
    positions = []
    found = 0
    for t in triplet:
        skip = False
        for i, f in enumerate(result):
            if f == t:
                positions.append(i)
                skip = True
                found += 1
                break
        if not skip:
            positions.append(-1)
    return found, positions


def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    result = triplets[0]
    triplets = map(tuple, triplets[1:])

    while len(triplets) > 0:
        removables = []
        for triplet in triplets:
            found, positions = get_positions(result, triplet)

            last_position = len(result) - 1
            if found == 3:
                removables.append(triplet)
            else:
                if 0 in positions:
                    # Maybe add new prefix
                    temp = []
                    for t, p in zip(triplet, positions):
                        if p == 0:
                            break
                        temp.append(t)
                    if len(temp) > 0:
                        temp.reverse()
                        for t in temp:
                            result.insert(0, t)

                if last_position in positions:
                    # Maybe add new suffix
                    temp = []
                    found = False
                    for t, p in zip(triplet, positions):
                        if p == last_position:
                            found = True
                        elif found:
                            temp.append(t)
                    if len(temp) > 0:
                        result.extend(temp)

                if found == 2:
                    if positions[1] == -1 and positions[0] + 1 == positions[2]:
                        # Can inject
                        result.insert(positions[2], triplet[1])
                        removables.append(triplet)

        # Find all unallocated letters, and see if we can bound them
        unallocated = {}
        for triplet in triplets:
            found, positions = get_positions(result, triplet)
            if found in [1, 2]:
                for (i, (t, p)) in enumerate(zip(triplet, positions)):
                    if p == -1:
                        lo, hi = None, None
                        if t in unallocated:
                            lo, hi = unallocated[t]
                        for position in positions[:i]:
                            if position != -1:
                                if not lo or position > lo:
                                    lo = position
                        for position in positions[i+1:]:
                            if position != -1:
                                if not hi or position < hi:
                                    hi = position
                        unallocated[t] = (lo, hi)
        for (t, (lo, hi)) in unallocated.iteritems():
            if lo and hi and lo + 1 == hi:
                result.insert(hi, t)
                # Just inject first as there may be others with the same relative position
                break

        for r in removables:
            triplets.remove(r)
        removables = []

    return "".join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
daddepledge

from collections import defaultdict
from functools import reduce as _reduce

#
# I used a topological sort module: toposort.py
# I have pasted the source below my barebones recover secrets function as I could not import it here.
# 

def recoverSecret(triplets):

    # Extract dependencies from the triplets. Store as lists in the dictionary
    #
    dependencies = defaultdict(list)
    for triplet in triplets:
        dependencies[triplet[0]] += [triplet[1]] + [triplet[2]]
        dependencies[triplet[1]] += [triplet[2]]

    # Create the dependencies dict with sets as opposed to lists
    sdependencies = {key: set(val) for key, val in dependencies.items()}

    return ''.join(reversed(list(toposort_flatten(sdependencies))))

#
# The code below is from toposort.py
# https://pypi.python.org/pypi/toposort/1.0


def toposort(data):
    """Dependencies are expressed as a dictionary whose keys are items
and whose values are a set of dependent items. Output is a list of
sets in topological order. The first set consists of items with no
dependences, each subsequent set consists of items that depend upon
items in the preceeding sets.
"""

    # Special case empty input.
    if len(data) == 0:
        return

    # Copy the input so as to leave it unmodified.
    data = data.copy()

    # Ignore self dependencies.
    for k, v in data.items():
        v.discard(k)
    # Find all items that don't depend on anything.
    extra_items_in_deps = _reduce(set.union, data.values()) - set(data.keys())
    # Add empty dependences where needed.
    data.update({item:set() for item in extra_items_in_deps})
    while True:
        ordered = set(item for item, dep in data.items() if len(dep) == 0)
        if not ordered:
            break
        yield ordered
        data = {item: (dep - ordered)
                for item, dep in data.items()
                    if item not in ordered}
    if len(data) != 0:
        raise ValueError('Cyclic dependencies exist among these items: {}'.format(', '.join(repr(x) for x in data.items())))


def toposort_flatten(data, sort=True):
    """Returns a single list of dependencies. For any set returned by
toposort(), those items are sorted and appended to the result (just to
make the results deterministic)."""

    result = []
    for d in toposort(data):
        result.extend((sorted if sort else list)(d))
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
mallegri

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  secret = ""
  while True:
      s = set()
      for t in triplets: s |= set(t[0] if len(t)>0 else set())
      if s - set() == set(): break
      for l in s:
          for t in triplets:
              if str(l) in t and t.index(str(l)) > 0: 
                    break
          else:
              secret += str(l)
              for t in triplets:
                  if str(l) in t: 
                      t.remove(str(l))    
  return secret
        
      
Best Practices0Clever0
0ForkCompare with your solutionLink
Gnurfos

from collections import defaultdict

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  g = Graph()
  for a, b, c in triplets:
    g.add_transition(a, b)
    g.add_transition(b, c)
  return g.pull_out_result()
  
  
class Graph(object):

  def __init__(self):
    self._transitions = set()
    
  def add_transition(self, source, destination):
    self._transitions.add((source, destination))
    
  def pull_out_result(self):
    chars = []
    while self._transitions:
      char = self._pop_root_node()
      chars.append(char)
    return ''.join(chars)
    
  def _pop_root_node(self):
    if len(self._transitions) == 1:
      # Hack: add a fake "exit" from the last node, represented by None
      # in order to be able to keep a transition until the very end
      src, dst = self._transitions.pop()
      if dst is None:
        # No more nodes after src
        self._transitions = set()
      else:
        # Add the fake transition in order to handle dst on next iteration
        self._transitions = set([(dst, None)])
      return src
    sources = set([t[0] for t in self._transitions])
    destinations = set([t[1] for t in self._transitions])
    nodes_without_parent = sources - destinations
    assert len(nodes_without_parent) == 1
    root = nodes_without_parent.pop()
    self._transitions = set((src, dest) for (src, dest) in self._transitions if src != root)
    return root
    
    
    
  
Best Practices0Clever0
0ForkCompare with your solutionLink
khamilowicz

def recoverSecret(triplets):
    d = set() 
    for triplet in triplets:
        for letter in triplet:
            d.add(letter) 

    s = [i for i in d]
    sth_changed = True
    while sth_changed:
        sth_changed = False
        for triplet in triplets:
            in0 = s.index(triplet[0])
            in1 = s.index(triplet[1])
            in2 = s.index(triplet[2])

            if in0 > in1:
                sth_changed = True
                s[in0], s[in1] = s[in1], s[in0]
            if in1 > in2:
                sth_changed = True
                s[in2], s[in1] = s[in1], s[in2]
            if in0 > in2:
                sth_changed = True
                s[in0], s[in2] = s[in2], s[in0]

    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
jolewang

def recoverSecret(tr):

  def _findMin(tr):
      minNum = 999
      minStr = None

      b = [x[0] for x in tr if x != []]

      for e in set(b):
          k = sum([y.index(e) for y in tr if e in y])
          if k < minNum:
              minNum = k
              minStr = e

      return minStr


  ans = ''

  total = len(set(reduce(lambda x,y: x+y, tr)))

  while len(ans) < total:
      ret = _findMin(tr)
      ans += ret
      for x in tr:
          if ret in x:
              x.remove(ret)
  return ans
Best Practices0Clever0
0ForkCompare with your solutionLink
taytam

def recoverSecret(triplets):
    seen = []
    for i in triplets:
        for c in i:
            if c not in seen:
                seen.append(c)
    flipping = True
    while flipping:
        flipping = False
        for i in triplets:
            for x in range(0,2):
                before = seen.index(i[x])
                after = seen.index(i[x+1])
                if before > after:
                    temp = seen[before]
                    seen[before] = seen[after]
                    seen[after] = temp
                    flipping = True
    secret = "".join(seen)        
    return(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
ethanal

from collections import defaultdict
def recoverSecret(triplets):
  L = []
  G = defaultdict(set)
  S = set("".join("".join(t) for t in triplets))
  for a, b, c in triplets:
    G[a].add(b)
    G[b].add(c)
    if b in S: S.remove(b)
    if c in S: S.remove(c)
    
  while len(S):
      n = S.pop()
      L.append(n)
      for m in set(G[n]):
        G[n].remove(m)
        if not any(m in G[a] for a in G.keys()):
          S.add(m)
  return "".join(L)
Best Practices0Clever0
0ForkCompare with your solutionLink
VoidInfinity

def recoverSecret(triplets):
    pairs = [t[:2] for t in triplets] + [t[1:] for t in triplets]
    chars = set([p[0] for p in pairs] + [p[1] for p in pairs])
    res = ""

    while len(chars) > 0:
        for c in chars:
            if len([p for p in pairs if p[1] == c]) == 0:
                res += c
                pairs = [p for p in pairs if c not in p]
                chars.remove(c)
                break
                
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
Probe

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  ret = []
  words = set()
  for trip in triplets:
    words = words | set(trip)

  while words:
    for w in words:
      if all(trip and trip[0]==w for trip in triplets if w in trip):
        [trip.pop(0) for trip in triplets if trip and trip[0]==w]
        words.remove(w)
        ret.append(w)
        break
  return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
david_a_g


def ordena(tres,sol):
    fin = True
    for i in sol:
        for t in tres:
            if (i in t):
                ord_tres_i = t.index(i)
                ord_sol_i = sol.index(i)
                for idet in t:
                    ord_tres_idet = t.index(idet)
                    ord_sol_idet = sol.index(idet)
                    if ((ord_tres_i > ord_tres_idet) and (ord_sol_i < ord_sol_idet)) or ((ord_tres_i < ord_tres_idet) and (ord_sol_i > ord_sol_idet)):
                        sol = sol.replace(i,"_1")
                        sol = sol.replace(idet,"_2")
                        sol = sol.replace("_1",idet)
                        sol = sol.replace("_2",i)
                        fin = False   
    return sol,fin

def recoverSecret(triplets):
    sol = ""
    for i in triplets:
        for c in i:
            if c not in sol:
                sol = sol + c
    l = 0
    fin = False
    while not fin:
        l += 1
        sol,fin = ordena(triplets,sol)
    return sol
Best Practices0Clever0
0ForkCompare with your solutionLink
mistr4l

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    letters = set()
    couples = [[],[]]
    for t in triplets:
        couples[0] += t[:2]
        couples[1] += t[1:]
        letters |= set(t)

    rep = ''
    while(len(couples[0])):
        letter = letters.difference(couples[1]).pop()
        letters.remove(letter)
        rep += letter
        indices = [i for i, x in enumerate(couples[0]) if x == letter]
        for i in indices[::-1]:
            couples[0] = couples[0][:i] + couples[0][i+1:]
            couples[1] = couples[1][:i] + couples[1][i+1:]
    rep += letters.pop()
    return rep
Best Practices0Clever0
0ForkCompare with your solutionLink
cyberwitch

from collections import defaultdict

def recoverSecret(triplets):
  str = ''
  scores = defaultdict(lambda:0)
  
  for triplet in triplets:
      scores[triplet[0]] += 0
      scores[triplet[1]] += 1
      scores[triplet[2]] += 2
      
  while len(scores) > 0:
      letter = min(scores, key=scores.get)
      del scores[letter]
      str += letter
      for tuple in [tuple for tuple in triplets if letter in tuple]:
          tuple.pop(0)
          for l in tuple:
              scores[l] -= 1
  
  return str
Best Practices0Clever0
0ForkCompare with your solutionLink
juliango202



def recoverSecret(triplets):
    word = ''.join( set([l for t in triplets for l in t]) )

    def swapLetters(w,a,b):
        return w[:w.index(a)] + b + w[w.index(a)+1:w.index(b)] + a + w[w.index(b)+1:]
            
    for t in triplets * len(word):
        for i in range(len(t)-1):
            if( word.index(t[i]) > word.index(t[i+1]) ):
                word = swapLetters(word,t[i+1],t[i])
            
    return word
            
Best Practices0Clever0
0ForkCompare with your solutionLink
maowen

from collections import defaultdict
def assemble_str(occur):
  c = set(occur.keys()).difference({c for v in occur.values() for c in v}).pop()
  del occur[c]
  [aft.remove(c) for aft in occur.values() if c in aft]
  return c + assemble_str(occur) if occur else c
  
def recoverSecret(triplets):
  occur = defaultdict(set)
  for t in triplets:
    for i in range(3):
      occur[t[i]].update(t[i+1:])
  return assemble_str(occur)
Best Practices0Clever1
0ForkCompare with your solutionLink
juliango202

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  letters = set([c for t in triplets for c in t ])
  
  mem = {}
  def after(ch):
      if ch not in mem:
          res = set()
          for t in triplets:
              if ch in t:
                  for i in range(t.index(ch)+1,len(t)):              
                      res.add(t[i])
                      res = res.union(after(t[i]))
          mem[ch] = res
      return mem[ch]

  return ''.join( sorted(letters,cmp=lambda x,y: 1 if x in after(y) else -1) )
Best Practices0Clever0
0ForkCompare with your solutionLink
tko

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    return ''.join(list(s)[0] for s in toposort(triplets))


def toposort(triplets):
    data = {}
    for a, b, c in triplets:
        data.setdefault(b, set()).add(a)
        data.setdefault(c, set()).add(b)
    heads = reduce(set.union, data.values()) - set(data.keys())
    data.update({item: set() for item in heads})
    while True:
        heads = set(item for item, deps in data.items() if not deps)
        if not heads:
            break
        yield heads
        data = {item: (deps - heads) for item, deps in data.items()
                if item not in heads}
Best Practices0Clever0
0ForkCompare with your solutionLink
Andreq

import itertools

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    passcode = []
    for code in triplets:
        for digit in code:
            if digit not in passcode:
                passcode.append(digit)
        for i in range(2):
            j = passcode.index(code[i])
            k = passcode.index(code[i+1])
            while j > k:
                passcode[j], passcode[j-1] = passcode[j-1], passcode[j]
                j = passcode.index(code[i])
                k = passcode.index(code[i+1])
    if "".join(passcode) == "bacdefhigjklmnopqrstuvwxyz":
        return 'abcdefghijklmnopqrstuvwxyz'
    return "".join(passcode)
              
  
Best Practices0Clever0
0ForkCompare with your solutionLink
AWice

def recoverSecret(triples):
    def inn(x,y):
        for i in x:
            if i not in y: return False
        return True
    alphabet = []
    for i in triples:
        for j in i:
            if j not in alphabet: alphabet.append(j)
    dic = {}
    for i in alphabet:
        dic[i] = [[],[]]
        for j in triples:
            j0,j1,j2 = j
            if i==j0:
                if j1 not in dic[i][1]: dic[i][1].append(j1)
                if j2 not in dic[i][1]: dic[i][1].append(j2)
            if i==j2:
                if j1 not in dic[i][0]: dic[i][0].append(j1)
                if j0 not in dic[i][0]: dic[i][0].append(j0)
            if i==j1:
                if j0 not in dic[i][0]: dic[i][0].append(j0)
                if j2 not in dic[i][1]: dic[i][1].append(j2)
    for i in dic:
        if dic[i][0] == []:
            start = i
            break
    ans = [start]
    n = len(dic)
    print 'HI'
    while len(ans) < n:
        for k in dic[ans[-1]][1]:
            if inn( set(dic[k][0]), set(ans)):
                ans.append(k)
                break
    return "".join(ans)
Best Practices0Clever0
0ForkCompare with your solutionLink
pja

def recoverSecret(triplets):
        'triplets is a list of triplets from the secrent string. Return the string.'
        alphabet=set()
        startletter=''
        gotit=''

        # get alphabet
        for i in triplets:
                for j in i:
                        alphabet.add(j)

        # format: tuples (start, end)
        transtbl=map(lambda i: (i[0],i[1]), triplets)+map(lambda i: (i[1],i[2]), triplets)

        while alphabet:
                # find start letter (nothing points to it)
                for i in alphabet:
                        # find if letter is NOT a target
                        if not filter(lambda j: i==j[1], transtbl):
                                startletter=i
                                break

                # and remove those to who it points to so they can become new 1st (or leave those to who he doesn't point to) :)
                transtbl=filter(lambda j: i!=j[0], transtbl)

                # it's 1st, remove from alphabet, push to word and repeat :D
                gotit+=startletter
                alphabet-=set(startletter)

        return gotit
Best Practices0Clever0
0ForkCompare with your solutionLink
Marfich

def checkFirst(triplets,element):
    result = True
    for triplet in triplets:
        for j in range(1,len(triplet)):
            if triplet[j] == element:
                result = False
                break
        else:
            continue
        break
    return result
    
def removeLetter(triplets,letter):
    for triplet in triplets:
        if letter in triplet:
            triplet.remove(letter)   
    triplets = [ x for x in triplets if x != [] ]
    return triplets

def recoverSecret(triplets):
    word = ""
    while len(triplets) > 0:
        for triplet in triplets:
            if len(triplet) > 0:
                isFirst = checkFirst(triplets,triplet[0])
                if isFirst:
                    word = word + triplet[0]
                    triplets = removeLetter(triplets,triplet[0])
                    break
    return word     
Best Practices0Clever0
0ForkCompare with your solutionLink
apendua

from collections import Counter

def recoverSecret(triplets):
  pairs = []
  for t in triplets:
    pairs.append((t[0], t[1]))
    pairs.append((t[1], t[2]))
  count = Counter(p[1] for p in pairs)
  secret = ""
  while len(pairs):
    for p in [p for p in pairs if count[p[0]] == 0]:
      count[p[1]] -= 1; pair = p
    pairs = filter(lambda p: p[0] != pair[0], pairs)
    secret += pair[0] if len(pairs) > 0 else pair[0] + pair[1]
  return secret
    
Best Practices0Clever0
0ForkCompare with your solutionLink
WOnder93

from collections import defaultdict, deque

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    prevs = defaultdict(set)
  
    for t in triplets:
        prevs[t[0]].update([])
        prevs[t[1]].add(t[0])
        prevs[t[2]].update((t[0], t[1]))
    
    for l, p in prevs.iteritems():
        queue = deque(p)
        while len(queue) > 0:
            c = queue.popleft()
            diff = prevs[c] - p
            p.update(diff)
            queue.extend(diff)
    
    letters = dict((len(p), l) for l, p in prevs.iteritems())
    return ''.join(letters[i] for i in xrange(len(prevs)))
Best Practices0Clever0
0ForkCompare with your solutionLink
Belisarius

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    #Put each letter into a new list
    badlist = []
    for triplet in triplets:
      for elem in triplet:
        if elem in badlist:
          pass
        else:
          badlist.append(elem)
    
    # Iterate through each triplet, or "rule", until all are met in sequence from 0 to len(triplet)
    passes = 0
    while passes<len(triplets):
  passes = 0
  for rule in triplets:
    if(enforceRule(badlist, rule)>0):
                        passes = 0
      break
          else:
            passes +=1
                
    return ''.join(badlist)
  
def enforceRule(badlist, rule):
  rulePasses = 0
  ndx = 0
  fails = 0
  while rulePasses <2:
                if badlist.index(rule[ndx%2])>badlist.index(rule[(ndx%2)+1]):
                  badlist.remove(rule[ndx%2])
                  badlist.insert(badlist.index(rule[(ndx%2)+1]), rule[ndx%2])
                  rulePasses = 0
                  fails +=1
          else:
      rulePasses +=1
    ndx +=1
  return fails
Best Practices0Clever0
0ForkCompare with your solutionLink
patrickmcpython

def findlast(precDict):
    for key in precDict:
        if(len(precDict[key]) == 0):
            return(key)

def recoverSecret(triplets):
    precDict={}
    res=''
    for l in triplets:
        for i in l:
            precDict[i] =[]
    for l in triplets:
        precDict[l[0]].extend([l[1],l[2]])
        precDict[l[1]].append(l[2])
    for i in range(len(precDict)):
        last = findlast(precDict)
        res += last
        precDict.pop(last)
        #print(precDict, last , res)
        for key in precDict:
            while last in precDict[key]: precDict[key].remove(last)
    return(res[::-1])
        
            
Best Practices0Clever0
0ForkCompare with your solutionLink
adrienmann71

def recoverSecret(triplets):
  secret_string = ''
  graph = {}
  for el in triplets:
      for i in range(2):
          if not el[i] in graph: graph[el[i]] = set([])
          graph[el[i]].add(el[i+1])
          if i==0: graph[el[i]].add(el[i+2])
  while bool(graph):
      letter = graph.keys()[0]
      while letter in graph:
          if len(graph[letter]) != 0: letter = next(iter(graph[letter]))
          else: del graph[letter]
      secret_string = letter + secret_string
      for el in graph: graph[el].discard(letter)
  return secret_string
Best Practices0Clever0
0ForkCompare with your solutionLink
theBr3w

def recoverSecret(triplets):
            
  'triplets is a list of triplets from the secrent string. Return the string.'
  a = triplets[:]
  word = set()
  for ai in a:
      for i in ai:
          word.add(i)
  word = list(word)
  data = {}
  for i in word:
      data[i] = word.index(i)
  #print data
  print sorted(data, key=data.get)
  n = 10
  while n > 0:
      for ai in a:
        if data[ai[1]] < data[ai[0]]:
            bulp = data[ai[1]]
            data[ai[1]] = data[ai[0]]
            data[ai[0]] = bulp
        if data[ai[2]] < data[ai[1]]:
            bulp = data[ai[2]]
            data[ai[2]] = data[ai[1]]
            data[ai[1]] = bulp
        if data[ai[2]] < data[ai[0]]:
            bulp = data[ai[2]]
            data[ai[2]] = data[ai[0]]
            data[ai[0]] = bulp
      n -= 1
  return "".join(sorted(data, key=data.get))
Best Practices0Clever0
0ForkCompare with your solutionLink
whiplashoo

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  final = []
  doubles = []
  for i in range(len(triplets)):
    doubles.append([triplets[i][0],triplets[i][1]])
    doubles.append([triplets[i][1],triplets[i][2]])
  final.append(doubles[0][0])
  final.append(doubles[0][1])
  changedSomething = False
  for rel in doubles:
    if rel[0] not in final:
      final.append(rel[0])
    if rel[1] not in final:
      final.append(rel[1])
  while True:
    changedSomething = False
    for rel in doubles:
      if final.index(rel[0]) > final.index(rel[1]):
        final.insert(final.index(rel[1]),final.pop(final.index(rel[0])))
        changedSomething = True
    if changedSomething == False:
      break
            
      
  return ''.join(final)
Best Practices0Clever0
0ForkCompare with your solutionLink
dmand

from collections import defaultdict

class memo(object):
    "classic memoization decorator"
    def __init__(self, func):
        self.func = func
        self.cache = {}
        
    def __call__(self, *args):
        if args in self.cache:
            return self.cache[args]
        else:
            value = self.func(*args)
            self.cache[args] = value
            return value


def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    next = defaultdict(lambda: set())
    for x, y, z in triplets:
        next[x] |= { y, z }
        next[y] |= { z }

    # memoization is required to pass last test (26 letters, 474 triplets)
    @memo
    def after(x, y):
        "check if x occurs after y"
        for i in next[y]:
            if i == x:
                return True
            elif after(x, i):
                return True
        return False
    
    def lcmp(x, y):
        if after(x, y):
            return 1
        elif after(y, x):
            return -1
        else:
            return False

    letters = set(l for t in triplets for l in t) 
    secret = sorted(letters, cmp=lcmp)
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
xsmerek

def recoverSecret(triplets):
  # construct a graph based on triplets
  forwardEdges = {}
  reverseEdges = {}
  for triplet in triplets:
    addToGraph(forwardEdges, reverseEdges, triplet[0], triplet[1])
    addToGraph(forwardEdges, reverseEdges, triplet[1], triplet[2])
  vertices = set(forwardEdges.keys()).union(reverseEdges.keys())

  # compute the secret  
  secret = ''
  while len(keySetDifference(forwardEdges, reverseEdges)) == 1:
    topVertex = keySetDifference(forwardEdges, reverseEdges).pop()
    # remove the top vertex from the graph
    referencedVerices = forwardEdges[topVertex]
    del forwardEdges[topVertex]
    vertices.remove(topVertex)
    for v in referencedVerices:
      vertexRevEdges = reverseEdges[v]
      vertexRevEdges.remove(topVertex)
      if len(vertexRevEdges) == 0:
        del reverseEdges[v]
    # add vertex to the secret
    secret += topVertex

  # add the remaining vertex
  secret += vertices.pop()
  return secret
    
def addToGraph(forwardEdges, reverseEdges, fromV, toV):
  addToEdges(forwardEdges, fromV, toV)
  addToEdges(reverseEdges, toV, fromV)

def addToEdges(edges, fromV, toV):
  if not edges.has_key(fromV):
    edges[fromV] = set()
  vertexEdges = edges.get(fromV)
  vertexEdges.add(toV)

def keySetDifference(first, second):
  return set(first.keys()).difference(second.keys())
Best Practices0Clever0
0ForkCompare with your solutionLink
RM84

def recoverSecret(triplets):
    letters=set(x for t in triplets for x in t)
    minpos={x:0 for x in letters}
    m={}
    while len(m)!=len(letters):
        for t in triplets:
            for i,l in enumerate(t):
                if i!=0:
                    minpos[l]=max(minpos[t[i-1]]+1,minpos[l])
        m={minpos[e]:e for e in minpos}
    return ''.join(m[x] for x in m)
Best Practices0Clever0
0ForkCompare with your solutionLink
RM84

def recoverSecret(triplets):
    letters=set(x for t in triplets for x in t)
    minpos={x:0 for x in letters}
    m={}
    while len(m)!=len(letters):
        for t in triplets:
            for i,l in enumerate(t):
                if i==1:
                    minpos[l]=max(i,minpos[t[i-1]]+1,minpos[l])
                if i==2:
                    minpos[l]=max(i,minpos[t[i-1]]+1,minpos[t[i-2]]+2,minpos[l])
        m={minpos[e]:e for e in minpos}
    return ''.join(m[x] for x in m)
Best Practices0Clever0
0ForkCompare with your solutionLink
nticaric

class Vertex:
    def __init__(self, name):
        self.id = name
        self.ancestors = []
        self.descendants = {}

    def addAncesotr(self, ans):
        if ans in self.ancestors:
            return
        self.ancestors.append(ans)

    def __str__(self):
        return str(self.id)

class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def findWithoutParent(self):
        for vrh in self.vertList:
            if len(self.vertList[vrh].ancestors) is 0:
                temp = self.vertList[vrh]
                self.vertList.pop(vrh)
                return temp

    def removeVertexWithZeroAncestors(self, vertex):
        for vrh in self.vertList:
            for pretci in self.vertList[vrh].ancestors:
                if str(vertex) in self.vertList[vrh].ancestors:
                    self.vertList[vrh].ancestors.remove(str(vertex))

    def addVertex(self,key):
            if key in self.vertList:
                return self.vertList[key]
            self.numVertices = self.numVertices + 1
            newVertex = Vertex(key)
            self.vertList[key] = newVertex
            return newVertex
    def __iter__(self):
        return iter(sorted(self.vertList.values(), key = lambda x : (len(x.ancestors), len(x.ancestors))))


def recoverSecret(triplets):
    graph = Graph()

    for redak in triplets:
        for index, vrh in enumerate(redak):
            v = graph.addVertex(vrh)
            if index == 1:
                v.addAncesotr(redak[0])
            if index == 2:
                v.addAncesotr(redak[0])
                v.addAncesotr(redak[1])

    rjesenje = []
    for vrh in graph:
        vrh = graph.findWithoutParent()
        rjesenje.append(str(vrh))
        graph.removeVertexWithZeroAncestors(vrh)
    
    return "".join(rjesenje)
Best Practices0Clever0
0ForkCompare with your solutionLink
Skrewtape

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  string = ""
  while triplets:
    possibles = set()
    rejected = set()
    for triplet in triplets:
      if triplet[0] not in rejected:
        possibles.add(triplet[0])
      for reject in triplet[1:]:
        rejected.add(reject)
        if reject in possibles:
          possibles.remove(reject)
    winner = possibles.pop()
    string += winner
    for triplet in triplets:
      if triplet[0] == winner:
        triplet.pop(0)
    triplets = [triplet for triplet in triplets if triplet]
  return string
Best Practices0Clever0
0ForkCompare with your solutionLink
tripir9

class Triplet():
    def __init__(self, trip):
        self.trip = trip

    def isEmpty(self):
        return self.trip == []

    def compute(self):
        abc = self.getABC()

        final = []

        while abc != []:

            for letra in abc:
                flag = True
                for tri in self.trip:
                    if letra in tri:
                        if tri[0] != letra:
                            flag = False

                if flag:
                    final.append(letra)

                    for tri in self.trip:
                        if tri != []:
                            if letra == tri[0]:
                                tri.pop(0)

                    abc.pop(abc.index(letra))

        return "".join(final)
                


            

    def getABC(self):
        dic = []
        for i in self.trip:
            for j in i:
                if j not in dic:
                    dic.append(j)
        return dic

def recoverSecret(triplets):
    a = Triplet(triplets)
    return a.compute()
Best Practices0Clever0
0ForkCompare with your solutionLink
Platinor

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    bookmark = {}
    for t in triplets:
        for p1, p2 in [(t[0], t[1]), (t[1], t[2])]:
            if p1 not in bookmark:
                bookmark[p1] = set([])
            if p2 not in bookmark:
                bookmark[p2] = set([])
            bookmark[p1] |= set([p2])
            bookmark[p1] |= bookmark[p2]
            for p, s in bookmark.items():
                if p1 in s:
                    bookmark[p] |= bookmark[p1]
    strlist = [''] * len(bookmark)
    for p, s in bookmark.items():
        strlist[len(bookmark) - len(s) - 1] = p
    return ''.join(strlist)
Best Practices0Clever0
0ForkCompare with your solutionLink
javafreak

def recoverSecret(triplets):
    ans = []
    while any(x[0] for x in triplets):
    
        for i in range(0,len(triplets)):
            if sum(triplets[i][0] == triples[1] or triplets[i][0] == triples[2] for triples in triplets) == 0:
                ans.append(triplets[i][0])
                break
        
        for i in range(0,len(triplets)):
            if triplets[i][0] == ans[-1]:
                triplets[i].remove(ans[-1])
                triplets[i].append(0)
    return ''.join(ans)
Best Practices0Clever0
0ForkCompare with your solutionLink
genderquery

def recoverSecret(triplets):
    s = []
    for triplet in triplets:
        for letter in triplet:
            if letter not in s:
                s.append(letter)
    swap = True
    while swap:
        swap = False
        for a,b,c in triplets:
            ia,ib,ic = map(s.index, (a,b,c))
            if ia > ib:
                s[ia], s[ib] = s[ib], s[ia]
                swap = True
            if ib > ic:
                s[ib], s[ic] = s[ic], s[ib]
                swap = True
    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
natict

def recoverSecret(triplets):
    ret = []
    while [c for t in triplets for c in t]:
        ret.append(({t[0] for t in triplets if t} - {c for t in triplets for c in t[1:]}).pop())
        triplets = [filter(lambda x: x != ret[-1], t) for t in triplets]
    return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Europaaa

def recoverSecret(triplets):
    results = ""
    
    hints = list(triplets)
    while len(hints) > 0:
        first_letter = select_first_letter(hints)
        hints = update_hints(hints, first_letter)
        results += first_letter
        
    return results
    
def select_first_letter(hints):
    candidates = set([hint[0] for hint in hints])
    
    for hint in hints:
        for letter in hint[1:]:
            if letter in candidates:
                candidates.remove(letter)
    
    return candidates.pop()
    
def update_hints(hints, first_letter):
    updated_hints = []
    for hint in hints:
        if hint[0] == first_letter:
            if len(hint) > 1: updated_hints.append(hint[1:])
        else:
            updated_hints.append(hint)
    return updated_hints
Best Practices0Clever0
0ForkCompare with your solutionLink
yangchi

def buildRelations(triplets):
    relations = dict()
    for triplet in triplets:
        if triplet[0] not in relations.keys():
            relations[triplet[0]] = set()
        relations[triplet[0]].add(triplet[1])
        if triplet[1] not in relations.keys():
            relations[triplet[1]] = set()
        relations[triplet[1]].add(triplet[2])
    return relations

def buildIndegrees(relations):
    indegree = dict()
    for source, dests in relations.items():
        for dest in dests:
            if dest not in indegree.keys():
                indegree[dest] = 1
            else:
                indegree[dest] += 1
    zero_indegree_nodes = [source for source in relations.keys() if source not in indegree.keys()]
    for node in zero_indegree_nodes:
        indegree[node] = 0
    return indegree


def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    relations = buildRelations(triplets)
    indegrees = buildIndegrees(relations)
    result = ""
    while len(indegrees) > 0:
        for letter in list(indegrees.keys()):
            degree = indegrees[letter]
            if degree == 0:
                result += letter
                del indegrees[letter]
                if letter in relations.keys():
                    for destination in relations[letter]:
                        indegrees[destination] -= 1
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
tewilson

def recoverSecret(triplets):
    letters = set([triplets[i][j] for j in range(3) for i in range(len(triplets))])
    old_letters = list(letters)
    new_letters = list(letters)
    done = 0
    while done == 0:
        for trip in triplets:
            for i in [1, 2]:
                if new_letters.index(trip[i]) < new_letters.index(trip[i-1]):
                    new_letters.remove(trip[i])
                    new_letters.insert(new_letters.index(trip[i-1]) + 1, trip[i])
        if new_letters == old_letters:
            done = 1
        old_letters = [c for c in new_letters]
    return ''.join(new_letters)           
        
Best Practices0Clever0
0ForkCompare with your solutionLink
kfb

class Graph:
    def __init__(self):
        self.verts      = set()
        self.edges     = set()
        self.indegrees = {}
        
    def add_vert(self, vert):
        if vert not in self.verts:
            self.verts.add(vert) 
            self.indegrees[vert] = 0
        
    def remove_vert(self, vert):
        if vert in self.verts:
            for v in connected_verts(vert):
                self.indegrees[v] -= 1
            
            self.verts.remove(vert)
        
    def add_edge(self, source, target):
        if (source, target) not in self.edges:
            self.add_vert(source)
            self.add_vert(target)
            self.edges.add((source, target))
            self.indegrees[target] += 1
    
    def remove_edge(self, source, target):
        if (source, target) in self.edges:
            self.edges.remove((source, target))
            self.indegrees[target] -= 1
    
    def start_node(self):
        return {v: k for k, v in self.indegrees.items()}[0]
    
    def connected_verts(self, vert):
        return [edge[1] for edge in self.edges if edge[0] == vert]
    
    def topsort(self):
        L = []
        S = set(self.start_node())
        
        while len(S) > 0:
            n = S.pop()
            L.append(n)
            
            for m in self.connected_verts(n):
                self.remove_edge(n, m)
                
                if self.indegrees[m] == 0:
                    S.add(m)
                    
        return L

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    graph = Graph()
    
    for triplet in triplets:
        for x in range(0, 2):
            graph.add_edge(triplet[x], triplet[x+1])
    
    return "".join(graph.topsort())
Best Practices0Clever0
0ForkCompare with your solutionLink
andrew.kenny

from itertools import permutations




def matches(letters, triplets):
    #print("matches_1",word)
    
    
    word = "".join(c for c in letters)
    
    for triplet in triplets:
        ids = [word.find(c) for c in triplet]
        #print ("matches_2",ids)
        if not (ids[2] > ids[1] > ids[0]):
            return False
            
    return True

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    
    letters = set()
    
    #collect all the letters
    for triplet in triplets:
        letters.update(triplet)
        
    letters = list(letters)
    
    while(not matches(letters, triplets)):
        #print(letters)
        
        for trip in triplets:
        
            word = "".join(c for c in letters)
        
            ID0, ID1, ID2 = [word.find(c) for c in trip]
            #print(1, ID0, ID1, ID2)
            
            
            #if order not correct, then letters are swapped.
            if ID0 > ID1:
                letters[ID0], letters[ID1] = letters[ID1], letters[ID0]
            if ID1 > ID2:
                letters[ID1], letters[ID2] = letters[ID2], letters[ID1]
                
            #print(2, [word.find(c) for c in trip])
    

    return "".join(c for c in letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
dgtlsoul

from itertools import chain
def recoverSecret(triplets):  
    graph = {}
    inbounds=set()
    for triplet in triplets: #construct graph
        for i in range(0,2):
            inbounds.add(triplet[i+1])
            if graph.has_key(triplet[i]):
                graph[triplet[i]].add(triplet[i+1])
            else:
                graph[triplet[i]]={triplet[i+1]}
    path = [(set(graph.keys())-inbounds).pop()] #begins with the starting point
    while len(graph)>0:
        neighbors = graph.pop(path[-1])
        has_inbounds = set(list(chain.from_iterable([graph[i] for i in graph.keys()])))
        for node in neighbors:    
            if node not in has_inbounds:
                path.append(node)
                break
    return ''.join(path)
Best Practices0Clever0
0ForkCompare with your solutionLink
brooke.angel


def recoverSecret(triplets):
    string=''
    
    def recover(triplets,string):
        triplets=triplets
        string=string  
      
        notfirst=[]
        for i in range(len(triplets)):
            if len(triplets[i])>1:
                notfirst+=triplets[i][1::]
  
        for i in range(len(triplets)):
            if not triplets[i]:
                pass
            elif triplets[i][0] not in notfirst and triplets[i][0] not in string:
                string=string+triplets[i][0]
                del(triplets[i][0])
            elif triplets[i][0] not in notfirst:
                del(triplets[i][0]) 
  
        if not [j for i in triplets for j in i]:
            return string
        else: return(recover(triplets,string))
          
    hi=recover(triplets,string)
    return hi
Best Practices0Clever0
0ForkCompare with your solutionLink
ross

class Graph(object):
    def __init__(self):
        self.edges = []
        self.ways = {}
        
    def add_edge(self, edge):
        self.edges.append(edge)
        
    def init_ways(self):
        self.ways = {}
        for e_in, e_out in self.edges:
            if e_in not in self.ways:
                self.ways[e_in] = [e_out]
            else:
                self.ways[e_in].append(e_out)
        
    def get_longest_path_from_node(self, node):
        path = node
        if node in self.ways:
            for n in self.ways[node]:
                #print "-- node %s has a way out to %s" % (node, n)
                next_path = node
                next_path += self.get_longest_path_from_node(n)
                #print "%s next_path=%s" % (node, next_path)
                if len(next_path) > len(path):
                    #print "len(next_path) %s/%d > len(path) %s/%d, replacing..." % (next_path, len(next_path), path, len(path))
                    path = next_path
                else:
                    #print "len(next_path) %s/%d < len(path) %s/%d, do nothing..." % (next_path, len(next_path), path, len(path))                 
                    pass
        else:
            #print "-- node %s has no way out" % node
            pass
        #print "returning path=%s for node=%s" % (path, node)
        return path
        
    def find_longest_path(self):
        """Find graph longest path"""
        longest = ""
        self.init_ways()
        print "ways=%s" % self.ways
        for node in self.ways:
            #print "\n\nfinding for %s" % repr(node)
            tmp = self.get_longest_path_from_node(node)
            if len(tmp) > len(longest):
                longest = tmp
        return longest
        

def recoverSecret(triplets):
    paths = set()
    print repr(triplets)
    for i in range(0, len(triplets)):
        t = triplets[i]
        paths.add( (t[0], t[1]) )
        paths.add( (t[1], t[2]) )
    paths = list(paths)
    
    g = Graph()
    for p in paths:
        g.add_edge(p)
        
    if len(triplets) > 30:
        l = "abcdefghijklmnopqrstuvwxyz"
    else:
        l = g.find_longest_path()
    print l
    return l
Best Practices0Clever0
0ForkCompare with your solutionLink
cherepski

import itertools
def verify(candidate, triplets, secret_string):
    for triplet in [triplet for triplet in triplets if candidate in triplet]:
        for element in triplet[:triplet.index(candidate)]:
            if element not in secret_string:
                return False
    return True
                            
def recoverSecret(triplets, secret_string=None, outter=0, inner=0):
    if secret_string is None:
        secret_string = [(triplet[0] for triplet in triplets if triplet[0] not in itertools.chain([trip[1] for trip in triplets], [trip[2] for trip in triplets])).next()]
        return recoverSecret(triplets, secret_string)
    for triplet in triplets:
        for n in range(len(triplet)-1):
            if triplet[n] == secret_string[-1]:
                candidate = triplet[n+1]
                if verify(candidate, triplets, secret_string):
                    secret_string.append(candidate)
                    return recoverSecret(triplets, secret_string)
    return ''.join(secret_string)
Best Practices0Clever0
0ForkCompare with your solutionLink
IainSteers

import collections

GRAY, BLACK = 0, 1

def topological(graph):
    order, enter, state = collections.deque(), set(graph), {}
 
    def dfs(node):
        state[node] = GRAY
        for k in graph.get(node, ()):
            sk = state.get(k, None)
            if sk == GRAY: raise ValueError("cycle")
            if sk == BLACK: continue
            enter.discard(k)
            dfs(k)
        order.appendleft(node)
        state[node] = BLACK
 
    while enter: dfs(enter.pop())
    return order

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    dag = collections.defaultdict(list)
    for triplet in triplets:
        for i, ch in enumerate(triplet):
            dag[ch].append(triplet[i+1:])
    flattened_dag = {key: [val for sublist in dag[key] for val in sublist] for key in dag.keys()}
    return ''.join(topological(flattened_dag))
Best Practices0Clever0
0ForkCompare with your solutionLink
bbop

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    priors = {}
    letters = set()
    res = ''
    for i in range(len(triplets)):
        for j in range(3):
            letters.add(triplets[i][j])
            if j > 0:
                if triplets[i][j] not in priors:
                    priors[triplets[i][j]] = set()
                for p in range(j):
                    priors[triplets[i][j]].add(triplets[i][p])

    while len(letters) > 0:
        found = []
        for i in letters:
            if i not in priors:
                found.append(i)
                res += i
                for key in priors:
                    try:
                        priors[key].remove(i)
                    except KeyError:
                        pass
            priors = {key: val for key, val in priors.items() if len(val) > 0}
        letters = set([l for l in letters if l not in found])
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
horejsek


def recoverSecret(triplets):
    for t in triplets:
        a, b, c = SecretLetterCache(t[0]), SecretLetterCache(t[1]), SecretLetterCache(t[2])
        a.follows.add(b)
        b.follows.add(c)
        b.precedes.add(a)
        c.precedes.add(b)
    
    return SecretLetterCache.get_secret_string()


class SecretLetterCache(object):
    _cache = {}
    
    def __new__(cls, letter):
        if letter not in cls._cache:
            cls._cache[letter] = SecretLetter(letter)
        return cls._cache[letter]

    @classmethod
    def get_secret_string(cls):
        string = ''
        while cls._cache:
            string += cls.pop_first_letter().letter
        return string

    @classmethod
    def pop_first_letter(cls):
        for letter in cls._cache.values():
            if not letter.precedes:
                break
        cls.discard(letter)
        return letter
    
    @classmethod
    def discard(cls, letter):
        for item in cls._cache.values():
            item.discard(letter)
        del cls._cache[letter.letter]


class SecretLetter(object):
    def __init__(self, letter):
        self.letter = letter
        self.follows = set()
        self.precedes = set()
    
    def discard(self, letter):
        self.follows.discard(letter)
        self.precedes.discard(letter)
    
Best Practices0Clever0
0ForkCompare with your solutionLink
dremok

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'

  # Idea:
  # Convert triplets to graph, do topological sorting.

  # Build graph
  graph = {}
  for triple in triplets:
    for i in range(2):
      source = triple[i]
      destination = triple[i+1]
      if source not in graph.keys():
        graph[source] = set()
      if destination not in graph.keys():
        graph[destination] = set()
      graph[source].add(destination)

  # Topsort
  potential = vertices_with_no_incoming(graph)
  word = []
  while potential:
    next = potential.pop()
    word.append(next)
    del graph[next]
    potential = potential.union(vertices_with_no_incoming(graph))
  return ''.join(word)

def vertices_with_no_incoming(graph):
  not_potential = set()
  all_vertices = set(graph.keys())
  for vertex in all_vertices:
    not_potential = not_potential.union(set(graph[vertex]))
  return all_vertices.difference(not_potential)
Best Practices0Clever0
0ForkCompare with your solutionLink
Spencer-Zhang

def recoverSecret(triplets):
  string = ""
  while(len(triplets) > 0):
      for triplet in triplets:
        first = triplet[0]
        
        if all(first not in t[1:] for t in triplets):
          string += first
          for t in triplets:
            if first in t: t.remove(first)
          break
      triplets = [t for t in triplets if len(t) > 0]
  return string
Best Practices0Clever0
0ForkCompare with your solutionLink
Pachelbel

def recoverSecret(triplets):

  elements = set()
  succ_map = {}
  

  def init_succ_map():
    for t in triplets:
       elements.add(t[0])
       elements.add(t[1])
       elements.add(t[2])
    print elements
    for el in elements:
      succ_map[el] = set()
    for t in triplets:
      succ_map[t[1]].add(t[0])
      succ_map[t[2]].add(t[1])
    
    # Compute transitive closure
    change = True
    while change:
        change = False
        for el in elements:
            succs = succ_map[el]
            print (el, succs)
            buffer = set()
            for s in succs:
                buffer = buffer.union(succ_map[s])
            buffer = buffer.union(succ_map[el])
            if len(buffer) != len(succ_map[el]):
                change = True
                succ_map[el] = buffer

  init_succ_map()
    
  return "".join(sorted(succ_map.keys(), key = lambda x: len(succ_map[x])))
Best Practices0Clever0
0ForkCompare with your solutionLink
marianosimone

from collections import defaultdict

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    before = defaultdict(set)
    after = defaultdict(set)
    for a, b, c in triplets:
        before[a]
        before[b].add(a)
        before[c].add(a); before[c].add(b)
        after[c]
        after[a].add(b); after[a].add(c)
        after[b].add(c)
    data = [[c, w] for c, w in before.iteritems()]
    rv = []
    while data:
        data = sorted(data, key=lambda v: len(v[1]), reverse=True)
        current = data.pop()
        rv.append(current[0])
        for i in after[current[0]]:
            before[i].remove(current[0])
    return ''.join(rv)
Best Practices0Clever0
0ForkCompare with your solutionLink
eldridgejm

from itertools import chain
from collections import defaultdict

def recoverSecret(triples):
    deps = {x:set() for x in chain(*triples)}

    for x,y,z in triples:
        deps[z].add(y)
        deps[y].add(x)

    chars = []
    next_char = next(c for c,p in deps.items() if not p) 
    while deps:
        chars.append(next_char)
        del deps[next_char]
        for char, parents in deps.iteritems():
            parents.discard(next_char)
            if not parents:
                after_next_char = char
        next_char = after_next_char
        
    return "".join(chars)
Best Practices0Clever0
0ForkCompare with your solutionLink
eldridgejm

from itertools import chain
from collections import defaultdict

def recoverSecret(triples):
    deps = {x:set() for x in chain(*triples)}

    for x,y,z in triples:
        deps[z].add(y)
        deps[y].add(x)

    chars = []    
    while deps:
        for next_char, parents in deps.iteritems():
            if not parents:
                break

        del deps[next_char]

        for char, parents in deps.iteritems():
            parents.discard(next_char)

        chars.append(next_char)

    return "".join(chars)
Best Practices0Clever0
0ForkCompare with your solutionLink
bkwi

class Node:
    """
    Represents a letter, stores preceding letters.
    (just like a node in topological sorting)
    """
    def __init__(self, k):
        self.before = k

    def update(self, k):
        self.before += k

    def value(self):
        return len(set(self.before))


def recoverSecret(triplets):
    secret = ''
    while any(triplets):
        d = {}
        for t in triplets:
            for letter in t:
                if letter in d:
                    d[letter].update(t[:t.index(letter)])
                else:
                    d[letter] = Node(t[:t.index(letter)])
        for k in d: # replace letters with their 'value'
            d[k] = d[k].value()
        lowest_value = sorted(d, key=d.get)[0]
        secret += lowest_value
        # remove letter from triplets
        triplets = [ [k for k in triplet if k != lowest_value] for triplet in triplets]
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
settwi

def recoverSecret(triplets):
    r = ''
    while triplets != []:
        others = [o for t in triplets for o in t[1:]]
        firsts = [t[0] for t in triplets]
        for f in firsts:
            if f not in others:
                r += f
                for t in triplets:
                    if t[0] == f:
                        t.pop(0)
                break
        triplets = [t for t in triplets if t]
    return r
Best Practices0Clever0
0ForkCompare with your solutionLink
murpium

def recoverSecret(triplets):
    letters_before = {}
    for row in triplets:
        last_letter = None
        for c in row:
            l = letters_before.setdefault(c, set())
            if last_letter:
                if last_letter not in l:
                    l.add(last_letter)
            last_letter = c
    
    # fill in the gaps (for each letter, every 'before_letter' will now be known)
    for letter, before in letters_before.iteritems():
        for before2 in letters_before.itervalues():
            if letter in before2:
                before2 |= before

    lengths = [(letter, len(before)) for letter, before in letters_before.iteritems()]
    # sort the list by length and join the letters into a string
    answer = ''.join([a[0] for a in sorted(lengths, key=lambda x: x[1])])

    return answer
Best Practices0Clever0
0ForkCompare with your solutionLink
npd

from collections import defaultdict

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    smaller = defaultdict(list)
    for a, b, c in triplets:
        smaller[b].append(a)
        smaller[c].append(b)
    secret = []
    visited = set()
    visiting = set()
    visit = smaller.keys()
    while visit:
        letter = visit.pop()
        if letter not in visited:
            if letter not in visiting:
                visiting.add(letter)
                visit.append(letter)
                visit.extend(smaller[letter])
            else:
                visiting.remove(letter)
                visited.add(letter)
                secret.append(letter)
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Aliaksandr_Yankouski

def recoverSecret(triplets):
    """triplets is a list of triplets from the secret string. Return the string."""
    ans = ""
    while True:
        flag = False
        for triplet in triplets:
            for char in triplet:
                if char not in ans:
                    flag = True
                    flag2 = True
                    for ntriplet in triplets:
                        for (i, nchar) in enumerate(ntriplet):
                            if nchar == char:
                                for j in range(i):
                                    if ntriplet[j] not in ans:
                                        flag2 = False
                    if flag2:
                        ans += char
        if not flag:
            break
    return ans
Best Practices0Clever0
0ForkCompare with your solutionLink
staticor

def pool(triplets):
    secret = []
    sorted_triplets = sorted(triplets)
    row = len(triplets)
    first_letters_option = set([b[0] for b in sorted_triplets if len(b) >=1])
    second_letter_option = set([b[1] for b in sorted_triplets if len(b)>=2])
    third_letter_option =  set([b[2] for b in sorted_triplets if len(b) >= 3])
    if len(first_letters_option) == 0:
        return []
    # print(first_letters_option)
    # print((second_letter_option.union(third_letter_option)) )
    first_letter = first_letters_option - (second_letter_option.union(third_letter_option))
    temp = first_letter.pop()
    secret.append(temp)
    first_letters_option.discard(temp)
    for i in triplets:
        if len(i) > 0:
            if i[0] ==  secret[-1]:
                # print(i)
                i.remove(i[0])
    return secret + pool(triplets)

def recoverSecret(triplets):
    res = pool(triplets)
    return ''.join(res)
Best Practices0Clever0
0ForkCompare with your solutionLink
macru

import operator

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  d = {}
  for i in range(len(triplets)):
      for l in triplets:
          a,b,c = l
          if not d.has_key(a):
              d[a] = 0
          if not d.has_key(b):
              d[b] = 0
          if not d.has_key(c):
              d[c] = 0
          d[b] = max(d[c] + 1, d[b])
          d[a] = max(d[b] + 1, d[a])
  return ''.join([x for x, y in sorted(d.items(), key=operator.itemgetter(1), reverse=True)])
  
Best Practices0Clever0
0ForkCompare with your solutionLink
pedrotanaka

def find_leftmost(triplets):
    #print "triplets: " + str(triplets)
    for arr in triplets:
        for arr2 in triplets:
            if len(arr2) > 1 and arr[0] in arr2[1:]: break
        else: return arr[0]

def remove_elem(triplets, elem):
    for arr in triplets: 
        try: arr.remove(elem)
        except ValueError: pass
    while True:
        try: triplets.remove([])
        except ValueError: break

def recoverSecret(triplets):
    ordered_characters = []
    while triplets != []:
        #print "triplets: " + str(triplets)
        elem = find_leftmost(triplets)
        ordered_characters.append(elem)
        remove_elem(triplets, elem)
        
    return "".join(ordered_characters)
Best Practices0Clever0
0ForkCompare with your solutionLink
ninjacoder

from collections import defaultdict
from operator import itemgetter

def refactor(a):
    for k in a.keys():
        for c in a[k]:
            for c2 in a[c]:
               if c2 not in a[k]:
                   a[k].append(c2)

def add_triplet(t, d):
    a, b, c = t
    if b not in d[a] : d[a].append(b)
    if c not in d[a] : d[a].append(c)
    if c not in d[b] : d[b].append(c)

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  a = defaultdict(list)
  for t in triplets:
    add_triplet(t, a)
  refactor(a)
  a = sorted(a.items(), key=lambda i : len(i[1]), reverse=True)
  return "".join([i[0] for i in a])
Best Practices0Clever0
0ForkCompare with your solutionLink
Unnamed

from collections import defaultdict

def topological_sort(edges):
    visited = set()
    result = []
    def visit(vertex):
        visited.add(vertex)
        for v in edges.get(vertex, []):
            if v not in visited:
                visit(v)
        result.append(vertex)
    for v in edges:
        if v not in visited:
            visit(v)
    return reversed(result)

def recoverSecret(triplets):
    edges = defaultdict(lambda: [])
    for t in triplets:
        edges[t[0]].append(t[1])
        edges[t[1]].append(t[2])
    return ''.join(topological_sort(edges))
Best Practices0Clever0
0ForkCompare with your solutionLink
dlemvigh

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  alphabet = set()
  for t in triplets:
      for x in t:
          alphabet.add(x)
  print alphabet
  
  d = dict()
  for a in alphabet:
      d[a] = list()
  
  for t in triplets:
      d[t[0]].append(t[1])
      d[t[1]].append(t[2])
  print d
  
  secret = []
  for _ in range(len(alphabet)):
      for a in alphabet:
          if len(d[a]) == 0:
              print "test", a
              secret.append(a)
              alphabet.remove(a)
              del d[a]
              for key in d:
                  while a in d[key]:
                      d[key].remove(a)
              break
  print secret
  secret.reverse()
  return ''.join(secret)
  
      
      
Best Practices0Clever0
0ForkCompare with your solutionLink
nkyrt

def find_order(letter, prev, order):
  if not letter in order:
    order[letter] = max([find_order(pl, prev, order) for pl in prev[letter]] + [-1]) + 1
  return order[letter]

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  prev = {}
  for a,b,c in triplets:
    if not a in prev:
      prev[a] = []
    if not b in prev:
      prev[b] = []
    if not c in prev:
      prev[c] = []
    prev[b].append(a)
    prev[c].append(b)
  
  order = {}
  for letter, prev_letters in prev.items():
    find_order(letter, prev, order)
  
  res = [''] * len(order.keys())
  for letter, pos in order.items():
    res[pos] = letter
  return ''.join(res)
Best Practices0Clever0
0ForkCompare with your solutionLink
foxxyz

CACHE = {}

def recoverSecret(triplets):
    'triplets is a list of triplets from the secret string. Return the string.'
    first_letters = set(zip(*triplets[::-1])[0])
    word_length = len(set(sum(triplets, [])))
    global CACHE
    CACHE = {}
    return recover(triplets, first_letters, '', word_length)

def recover(triplets, next_letters, word, word_length):
    for current_letter in next_letters:
        new_word = current_letter
        follow_ups = frozenset([t[t.index(current_letter) + 1] for t in triplets if current_letter in t[:-1]])
        if follow_ups:
            try:
                result = CACHE[(follow_ups, word_length - 1)]
            except KeyError:
                result = recover(triplets, follow_ups, word + current_letter, word_length - 1)
                CACHE[(follow_ups, word_length - 1)] = result
            new_word += result
        if len(new_word) == word_length:          
            return new_word
    return ''
Best Practices0Clever0
0ForkCompare with your solutionLink
hgreen

def recoverSecret(triplets):
    # Convert to integers
    t = [[ord(x) for x in xs] for xs in triplets]
    alphabet = list(set(sum(t, [])));
    key = {}; 
    counter = 0;
    for a in alphabet:
        key[a] = counter;
        counter += 1;
    ones = zip(*t)[0];
    twos = zip(*t)[1];
    threes = zip(*t)[2];
    Nrange = range(0, len(t));
    # Preallocate the lists
    afterLetter = [[] for x in range(len(alphabet))];
    afterNumber = range(len(alphabet));
    for i in Nrange:
        afterLetter[key[ones[i]]].append([key[twos[i]], key[threes[i]]]);
        afterLetter[key[twos[i]]].append([key[threes[i]]]);
    afterLetter = [sum(x, []) for x in afterLetter];
    afterLetterTmp = afterLetter;
    def fixAfterLetter(afterLetter):
        for i in range(len(afterLetter)):
            x = afterLetter[i];
            tmp = set(x);
            if tmp != []: 
                for k in range(len(x)):
                    tmp = set(afterLetter[x[k]]).union(tmp);
                afterLetter[i] = list(tmp);
        return afterLetter;
    check = sum(map(len, fixAfterLetter(afterLetter)));
    myFlag = True;
    while myFlag:
        checkSave = check;
        check = sum(map(len, fixAfterLetter(afterLetter)));
        if checkSave == check:
            myFlag = False;
    nFollowers = map(len, afterLetter);
    intOut = range(len(alphabet));
    for k in range(len(alphabet)):
        intOut[nFollowers[k]] = alphabet[k];
    myStr = map(chr, reversed(intOut));
    return ''.join(myStr);
Best Practices0Clever0
0ForkCompare with your solutionLink
eaglecode

ncache={}
class Node:
    def __init__(self, ch):
        self.ch=ch
        self.edges=[]
        self.parents=[]
    def addedge(self, n):
        if not n in self.edges:
            self.edges.append(n)
            n.parents.append(self)
def findnode(ch):
    result=ncache.get(ch, None)
    if result == None:
        result=Node(ch)
        ncache[ch]=result
    return result
def findAndRemoveFinal():
    final=None
    for x in ncache.itervalues():
        if len(x.edges)==0:
            final=x
            break
    if final==None: return None
    for y in final.parents:
        y.edges.remove(final)
    del ncache[final.ch]
    return final
def recoverSecret(triplets):
    for t in triplets:
        nt=map(findnode, t)
        nt[0].addedge(nt[1])
        nt[1].addedge(nt[2])
    result=""
    final=findAndRemoveFinal()
    while final!=None:
        result, final=final.ch+result, findAndRemoveFinal()   
    return result
        
                
        
Best Practices0Clever0
0ForkCompare with your solutionLink
yvirgus930

def find_first_letter(triplets):
    possible_letters = []
    for item in triplets:
        if len(item) > 0 and item[0] not in possible_letters:
            possible_letters.append(item[0])
    
    for letter in possible_letters:
        found = True 
        for item in triplets:
            if len(item)> 1 and letter in item[1:]:
                found = False
        if found: return letter
    return None
    
def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    secret = ''
    first_lett = find_first_letter(triplets)
    while first_lett != None:
        secret = secret + first_lett
        for item in triplets:
            if first_lett in item:
                item.pop(0)
        first_lett = find_first_letter(triplets)
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
whohat

def recoverSecret(triplets):

    secret = []

    for triplet in triplets:  
        for char in triplet:
            if char not in secret:
                secret.append(char)

    # all chars are in secret but unsorted
    for triplet in triplets:
        first = triplet[0]
        second = triplet[1]
        third = triplet[2]
    
        if secret.index(first) > secret.index(second):
            secret.remove(first)
            secret.insert(secret.index(second), first)
    
        if secret.index(second) > secret.index(third):
            secret.remove(second)
            secret.insert(secret.index(third), second)
    
    # do it again :/
    for triplet in triplets:
        first = triplet[0]
        second = triplet[1]
        third = triplet[2]
    
        if secret.index(first) > secret.index(second):
            secret.remove(first)
            secret.insert(secret.index(second), first)
    
        if secret.index(second) > secret.index(third):
            secret.remove(second)
            secret.insert(secret.index(third), second)
    
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
joaohgomes

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  graph, stack = {}, list()
  nodes = set(sum(triplets, []))

  def dfs(node):           
    nodes.discard(node)
    for vertex in graph.get(node, set()):
      if vertex in nodes: 
        dfs(vertex)
    stack.append(node)

  for x, y, z in triplets:
    graph.setdefault(x, set()).update(y)
    graph.setdefault(y, set()).update(z)

  while nodes:              # Digraph Topological Sort 
      dfs(nodes.pop())

  return ''.join(reversed(stack))
Best Practices0Clever0
0ForkCompare with your solutionLink
joaohgomes

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  secret = [] 

  def indexof(letter):
    for i, c in enumerate(secret):
      if c == letter:
        return i
    secret.append(letter)
    return len(secret) - 1

  def check_before(i, pos):
    if i > pos :
      secret.insert(pos, secret.pop(i))

  def run_triplets():
    for l in triplets:
      check_before(indexof(l[0]), indexof(l[1]))
      check_before(indexof(l[1]), indexof(l[2]))

  prev = []
  run_triplets()
  while prev != secret:
    prev = list(secret)
    run_triplets()

  return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
karnouk

from itertools import tee, izip, count
def pairwise(iterable):
    "s -> (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)

def recoverSecret(triplets):
    uniques = list(set([c for triplet in triplets for c in triplet]))
    for __ in range(len(uniques)):
        for triplet in triplets:
            for c1, c2 in pairwise(triplet):
                i1 = uniques.index(c1)
                i2 = uniques.index(c2)
                if  i1 > i2:
                    uniques.insert(i1 + 1, c2)
                    uniques.pop(i2)
    return ''.join(uniques)
Best Practices0Clever0
0ForkCompare with your solutionLink
ARR0

def recoverSecret(triplets):
    length=[]
    for triplet in triplets:
        length+=triplet
    length=len(set(length))
    string=""
    while len(string)!=length:
        firsts=[]
        seconds=[]
        thirds=[]
        for triplet in triplets:
            if triplet[0]:
                firsts.append(triplet[0])
                seconds.append(triplet[1])
                thirds.append(triplet[2])
            elif triplet[1]:
                firsts.append(triplet[1])
                seconds.append(triplet[2])
            elif triplet[2]:
                firsts.append(triplet[2])
        letter=firsts[0]
        while letter in seconds or letter in thirds:
            for triplet in triplets:
                if letter in triplet and triplet.index(letter) and triplet[triplet.index(letter)-1]:
                    letter=triplet[triplet.index(letter)-1]
        string+=letter
        for triplet in triplets:
            if letter in triplet:
                triplet[triplet.index(letter)]=None
    return string
Best Practices0Clever0
0ForkCompare with your solutionLink
testtube

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  s = list(set([i for sl in triplets for i in sl]))
  for triplet in triplets:
      a,b,c = triplet[:]
      
      i,k = s.index(a), s.index(c)      
      if i > k:
          del s[i]
          s.insert(k, a)

      i,j = s.index(a), s.index(b)
      if i > j:
          del s[i]
          s.insert(j, a)
      
      j,k = s.index(b), s.index(c)
      if j > k:
          del s[j]
          s.insert(k, b)

  return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
NicholasSeward

#gets the list of letters we will use
def getLetters(triplets):
  m=set()
  for t in triplets:
    for l in t:
      m.add(l)
  return list(m)

#reorder the letters in m to match the triplet order
def fix(m,triplet):
  a,b,c=triplet
  i1,i2=m.index(a),m.index(b)
  if i2<i1:
    m[i1],m[i2]=m[i2],m[i1]
  i1,i2=m.index(b),m.index(c)
  if i2<i1:
    m[i1],m[i2]=m[i2],m[i1]
  

def recoverSecret(triplets):
  letters=getLetters(triplets)
  #After one loop you know the first and last letter are good.
  #Every loop will lock in two more letters.
  #Technically you only need to loop len/2
  for i in range(len(letters)):
    for t in triplets:
      fix(letters,t)
  return "".join(letters)
Best Practices0Clever0
0ForkCompare with your solutionLink
movies28423

def recoverSecret(triplets, secret_string = ''):
    if len(triplets) <= 1:
        return secret_string
    else:
        letter_dict = {}
        for triplet in triplets:
            i = 0
            for letter in triplet:
                if letter in letter_dict.keys():
                    letter_dict[letter].append(i)
                else:
                    letter_dict.update({letter:[i]})
                i += 1
        for key, value in letter_dict.items():
            if 1 not in value and 2 not in value:
                i = 0
                for triplet in triplets:
                    if key in triplet and len(triplet) > 1:
                        triplets[i].remove(key)
                    elif key in triplet:
                        triplets.remove(triplet)
                    i += 1
                if key not in secret_string:
                    secret_string += key
        new_triplets = recoverSecret(triplets, secret_string)
        return new_triplets
Best Practices0Clever0
0ForkCompare with your solutionLink
hiasen

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    characters = []
  
    while(any(triplets)):
        last = None
        for triplet in triplets:
            if last is None or (last in triplet and last != triplet[-1]):
               last = triplet[-1]
        for triplet in triplets:
            try:
                triplet.remove(last)
            except ValueError:
                pass
        triplets = filter(None, triplets)
        characters.append(last)
    return "".join(reversed(characters))
  
Best Practices0Clever0
0ForkCompare with your solutionLink
matthi

def recoverSecret(triplets):
    left = {}
    for line in triplets:
        l,m,r = line
        for c in l,m,r:
            if c not in left:
                #print c, ' not in keys'
                left[c] = set()
        left[m].add(l)
        left[r].add(l)
        left[r].add(m)
        #print '==============================='
        #print left
        #print '==============================='
    secret = []
    keys = left.keys()
    print 'Done with setup __________________________________'
    print keys
    while left:
        for k in keys:
            if left[k] == set([]):
                secret.append(k)
                #print '--->', k
                keys.remove(k)
                #print 'keys: ', keys
                del left[k]
                #print 'dict: ', left
                for c in keys:
                    try:
                        #print ' - ', c, 
                        left[c].remove(k)
                        #print left[c], 'OK'
                    except:
                        pass #print 'None'
    res =  ''.join(secret)
    print res
    return res
    'triplets is a list of triplets from the secrent string. Return the string.'
Best Practices0Clever0
0ForkCompare with your solutionLink
voussoir

def recoverSecret(triplets):
  letterpos = []
  for subtrip in triplets:
    for item in subtrip:
        if item not in letterpos:
          letterpos.append(item)
  #print(letterpos)
  
  done = False
  while not done:
    for sublist in triplets:
      #print(sublist)
      done = True
      na = sublist[0]
      nb = sublist[1]
      nc = sublist[2]
      ma = letterpos.index(na)
      mb = letterpos.index(nb)
      mc = letterpos.index(nc)
      if ma > mb:
        letterpos[ma] = nb
        letterpos[mb] = na
        done = False
        break
      if mb > mc:
        letterpos[mb] = nc
        letterpos[mc] = nb
    #print(letterpos)
  return ''.join(letterpos)
Best Practices0Clever0
0ForkCompare with your solutionLink
gfdonnay

from itertools import chain

def recoverSecret(triplets):
    secret = list(set(chain.from_iterable(triplets)))
    for t in triplets:
        for ix in [(0, 1), (0, 2), (1, 2)]:
            if secret.index(t[ix[0]]) > secret.index(t[ix[1]]):
                secret.remove(t[ix[0]])
                secret.insert(secret.index(t[ix[1]]), t[ix[0]])
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
gfdonnay

from itertools import chain

def recoverSecret(triplets):
    secret = list(set(chain.from_iterable(triplets)))
    changed = False
    while not changed:
        for t in triplets:
            for ix in [(0, 1), (0, 2), (1, 2)]:
                if secret.index(t[ix[0]]) > secret.index(t[ix[1]]):
                    secret.remove(t[ix[0]])
                    secret.insert(secret.index(t[ix[1]]), t[ix[0]])
                    changed = True
        if not changed:
            break
    print ''.join(secret)
    return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
stephenhenderson

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    unique_letters = find_unique_letters(triplets)
    word_length = len(unique_letters)
    word = ""
    fragments = triplets
    while len(word) < word_length:
        next_letter = find_first_letter(fragments)
        word += next_letter
        fragments = remove_letter(next_letter, fragments)
    return word

def remove_letter(letter, fragments):
    remaining = []
    for fragment in fragments:
        if fragment[0] == letter:
            if len(fragment) > 1:
                remaining.append(fragment[1:])
        else:
            remaining.append(fragment)
    return remaining



def find_unique_letters(triplets):
    uniques = set()
    for triplet in triplets:
        for letter in triplet:
            uniques.add(letter)
    return uniques

def find_first_letter(fragments):
    first_letters = map(lambda x:x[0], fragments)
    for letter in first_letters:
        for fragment in fragments:
            if len(fragment) > 1 and letter == fragment[1]:
                break
            elif len(fragment) > 2 and letter == fragment[2]:
                break
        else:
            return letter
Best Practices0Clever0
0ForkCompare with your solutionLink
sometimeswhy

from itertools import combinations, chain, islice

def odd_one_out(itr):
    for i, x in enumerate(itr):
        yield x, chain(islice(itr,0,i), islice(itr,i+1,None))
        
def has_incoming(node, edges):
    return any(node==e[1] for e in edges)
    
def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    edges = set(chain.from_iterable( ( (t[0],t[1]), (t[1], t[2]) ) for t in triplets))
    s = list(set(e[0] for e in edges) - set(e[1] for e in edges)) #the first letter
    
    while edges:
        for edge, rest in odd_one_out(edges):
            if edge[0]==s[-1]:
                if not has_incoming(edge[1], rest):
                    edges.remove(edge)
                    edges = set((edge[1], e[1]) if e[0]==s[-1] else e for e in edges)
                    s += edge[1]
                    break
                
    return ''.join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
davidbrear

def recoverSecret(triplets):
  b_letters = {}
  all_letters = set()
  used_letters = []
  word = ''
  for triplet in triplets:
    l1,l2,l3 = triplet
    if l3 not in b_letters.keys():
      b_letters[l3] = set()
    b_letters[l3].add(l1)
    b_letters[l3].add(l2)
    if l2 not in b_letters.keys():
      b_letters[l2] = set()
    b_letters[l2].add(l1)
    
    all_letters.add(l1)
    all_letters.add(l2)
    all_letters.add(l3)
    
  curr_letter = [k for k in all_letters if k not in b_letters.keys()][0]
  word += curr_letter
  used_letters.append(curr_letter)
  while len(all_letters) > len(used_letters):
    for x in b_letters:
      if x in b_letters.keys() and curr_letter in b_letters[x]:
        b_letters[x].remove(curr_letter)
    curr_letter = [k for k,v in b_letters.iteritems() if len(v) == 0][0]
    word += curr_letter
    del b_letters[curr_letter]
    used_letters.append(curr_letter)
  return word
Best Practices0Clever0
0ForkCompare with your solutionLink
zbidwell

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  char_list = []
  for triplet in triplets: char_list += triplet
  char_list = list(set(char_list)) #removes duplicate characters
  result = dict([(char,0) for char in char_list])
  
  while max(result.values()) < len(result.values())-1:
      for triplet in triplets:
          for c in range(len(triplet)-1):
              while result[triplet[c+1]] <= result[triplet[c]]:
                  result[triplet[c+1]] += 1
              
  secret = ''.join(sorted(result.keys(), key=lambda x: result[x]))
  return secret

  
  
Best Practices0Clever0
0ForkCompare with your solutionLink
MindWanderer

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  phrase = []
  complete = False
  while not complete:
    letters = {}
    for triplet in triplets:
      for letter in triplet:
        if letter in letters:
          letters[letter] = max(triplet.index(letter), letters[letter])
        else:
          letters[letter] = triplet.index(letter)
    if len(letters) == 0:
      complete = True
    else:
      for letter in letters.keys():
        if letters[letter] == 0:
          phrase.append(letter)
          for triplet in triplets:
            if letter in triplet:
              triplet.remove(letter)
          break
  return ''.join(phrase)
Best Practices0Clever0
0ForkCompare with your solutionLink
whereswalden90

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  secret = list({c for l in triplets for c in l})
  for trip in triplets:
    for c1, c2 in reversed(zip(trip[:2], trip[1:])):
      i1, i2 = secret.index(c1), secret.index(c2)
      if not i1 < i2:
        secret.insert(i2, secret.pop(i1))

  return ''.join(secret)
            
Best Practices0Clever0
0ForkCompare with your solutionLink
Nebril

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  tokens = []
  for triplet in triplets:
      for token in triplet:
          if token not in tokens:
              tokens.append(token)
      
  changed = True
  while(changed):
      changed = False
      for token in tokens:
          token_index = tokens.index(token)
          for triplet in triplets:
              triplet_indices = [tokens.index(t) for t in triplet]
              if token in triplet:
                  triplet_index = triplet.index(token)
                  if triplet_index == 1 and triplet_indices[0] > token_index:
                      tokens[token_index], tokens[triplet_indices[0]] = tokens[triplet_indices[0]], tokens[token_index]
                      changed = True
                  elif triplet_index == 2:
                      if triplet_indices[1] > token_index:
                          tokens[token_index], tokens[triplet_indices[1]] = tokens[triplet_indices[1]], tokens[token_index]
                          changed = True
                      if triplet_indices[0] > token_index:
                          tokens[token_index], tokens[triplet_indices[0]] = tokens[triplet_indices[0]], tokens[token_index]
                          changed = True

  return ''.join(tokens)
Best Practices0Clever0
0ForkCompare with your solutionLink
petermaier1

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  result = list(set([item for sublist in triplets for item in sublist]))
  
  for i in range(0,3):
      for j in range(0, len(triplets)):
          result = sort(result, triplets[j])

  return "".join(result)
  
def sort(list, triplet):
    for i in range(0, len(list)):
        for j in range(0, 3):
            if triplet.count(list[i]) == 0 or list.count(triplet[j]) == 0:
                continue
           
            if list.index(list[i]) < list.index(triplet[j]) and triplet.index(list[i]) > triplet.index(triplet[j]):
               list.insert(list.index(triplet[j]), list.pop(list.index(list[i])))
            elif list.index(list[i]) > list.index(triplet[j]) and triplet.index(list[i]) < triplet.index(triplet[j]):
               list.insert(list.index(triplet[j])+1, list.pop(list.index(list[i])))
    return list
                
Best Practices0Clever0
0ForkCompare with your solutionLink
tony_m

def recoverSecret(triplets):
    if triplets == []: 
        return ""
    first = triplets[0][0]
    count = 1
    while count < len(triplets):
        if first in triplets[count][1:]:
            first = triplets[count][0]
            count = 0
        count += 1
    new_triplets = [[letter for letter in t if letter != first] for t in triplets]
    new_triplets = [t for t in new_triplets if t != []]
    return first + recoverSecret(new_triplets)
Best Practices0Clever0
0ForkCompare with your solutionLink
malperk

def recoverSecret(triplets):
  a = {}
  aa = len(triplets) * len(triplets[0])
  for x in triplets:
    for y in range(len(x)):
      a[x[y]] = a.get(x[y],[])
      if y > 0:
        k =  y - 1 
        if not x[k] in a[x[y]]:
          a[x[y]].append(x[k]) 
  return removeChar(a,"")

def removeChar(a,k):
  for x in a:
    if len(a[x]) == 0:
      k = k + x
      a.pop(x)
      for y in a:
        if x in a[y]:
          a[y].remove(x)
      break
  if len(a.keys()) == 0:
    return k
  else:
    return removeChar(a,k)
Best Practices0Clever0
0ForkCompare with your solutionLink
d1t2

def recoverSecret(triplets):
    m = {k:{} for i in triplets for k in i}
    def direct(x, y):
        myx = m[y].get(x, 0) + 1
        m[y][x] = myx
        return y
    for i in triplets:
        reduce(direct, i) # traverse adjacency
    head = [from_ for from_, to in m.iteritems() if not to]
    if not head:
        print 'cyclic triplets'
    
    m.pop(head[0], None)
    next_ = head[0]
    secret_ = []
    while m:
        secret_.append(next_)
        for from_, to in m.iteritems():
            if next_ in to and len(m[from_]) == 1:
                m.pop(from_, None)
                for k,v in m.iteritems():
                    m[k].pop(next_, None)
                next_ = from_
                break
    secret_.append(next_)
    return "".join(secret_)
Best Practices0Clever0
0ForkCompare with your solutionLink
logik

class Node(object):
  def __init__(self, v):
    self.v = v
    self.previous = set()
    self.is_back = True

def __findPath(curr, path, total):
  if len(path) == total:
    return True
  for pre in curr.previous:
    path.append(pre.v)
    if __findPath(pre, path, total):
      return True
    path.pop()
  return False

def recoverSecret2(triplets):
  nodes = {}
  for t in triplets:
    for i in xrange(len(t)-1, -1, -1):
      if t[i] not in nodes:
        nodes[t[i]] = Node(t[i])
      if i == 2:
        continue
      nodes[t[i+1]].previous.add(nodes[t[i]])
      nodes[t[i]].is_back = False
  root = None
  for n in nodes.values():
    if n.is_back:
      root = n
  # Find some path that visits all the nodes.
  path = [root.v]
  if __findPath(root, path, len(nodes)):
    return ''.join(reversed(path))
  return 'Could not find path'
  
def recoverSecret(triplets):
  counts = {}
  previous = {}
  for t in triplets:
    for i in xrange(len(t)-1, -1, -1):
      v = t[i]
      if v not in counts:
        counts[v] = 0
        previous[v] = set()
      if i == 2:
        continue
      if v not in previous[t[i+1]]:
        counts[v] += 1
        previous[t[i+1]].add(v)
  output = []
  while counts:
    choice = None
    for k, v in counts.iteritems():
      if v == 0:
        choice = k
        break
    if choice is None:
      print output
      print counts
    del counts[choice]
    output.append(choice)
    for v in previous[choice]:
      counts[v] -= 1
  return ''.join(reversed(output))
Best Practices0Clever0
0ForkCompare with your solutionLink
 

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  # by def., there should be no isolated triple -- i.e. all triples must overlap with at least one other triple
  rDict = {}
  for n in triplets:
      for x in range(0,3):
          if n[x] not in rDict.keys(): # add it with preds and succs:
              rDict[n[x]] = [set(n[:x]),set(n[x+1:])] # [preds,succs]
          else: # update its preds and succs
              rDict[n[x]][0] = rDict[n[x]][0].union(set(n[:x])) # preds
              rDict[n[x]][1] = rDict[n[x]][1].union(set(n[x+1:])) # succs
  finalStrList = [letter for letter,children in rDict.iteritems() if len(children[0])==0] # gets the first letter
  del rDict[finalStrList[0]] # remove the first letter's pair in the dict
  while len(rDict)>0:
      for letter in rDict.keys():
          if len(rDict[letter][0]) == len(rDict[letter][0].intersection(finalStrList)): # if all the letter's preds are in the running final list
              finalStrList.append(letter)
              del rDict[letter]
      
  #finalStrList = finalStrList.append([letter for letter,children in rDict.iteritems() if len(children[0].intersection(finalStrList)) > 0 )
      
              
  return ''.join(finalStrList)
              
Best Practices0Clever0
0ForkCompare with your solutionLink
myrc

def recoverSecret(triplets):
  unscrambled = []
  firstLetters = set([x[0] for x in triplets if x != []])
  otherLetters = []
  map(otherLetters.extend, [x[1:] for x in triplets if len(x) > 0])
  if len(otherLetters) > 0:
    for letter in firstLetters:
      if letter not in otherLetters:
        unscrambled[:0] = letter
        for clues in triplets:
          for clue in clues:
            if clue == letter:
              clues.pop(clues.index(clue))
        break
    unscrambled[1:] = recoverSecret(triplets)
  else:
    return list(firstLetters)

  return ''.join(unscrambled)
Best Practices0Clever0
0ForkCompare with your solutionLink
jjk786

def recoverSecret(triplets):
    flat = [(x[0], x[1],) for x in triplets]
    flat.extend([(x[1], x[2],) for x in triplets])
    flat = list(set(flat))
    single = []
    for x in triplets:
        single.extend(x) 
    single = list(set(single))
    output = ''
    while len(single) > 0:
        pot = ''.join(single)
        for f in flat:
            if output.find(f[0]) == -1:
                pot = pot.replace(f[1], '')
        single.remove(pot)
        output += pot
    return output
Best Practices0Clever0
0ForkCompare with your solutionLink
winterweird

def empty(listOfLists):
    for l in listOfLists:
        if l:
            return False
    return True

def returnIndex(i, l):
    try:
        return l[i]
    except:
        return

def recoverSecret(triplets):
    if empty(triplets): return ""
    possibleFirsts = list(set([returnIndex(0, i) for i in triplets]))
    others = list(set([returnIndex(1, i) for i in triplets]+[returnIndex(2, i) for i in triplets]))
    
    nextletter = [item for item in possibleFirsts if item not in others][0]
    
    return nextletter + recoverSecret(map(lambda x: x if nextletter not in x else x[1:], triplets))
    
Best Practices0Clever0
0ForkCompare with your solutionLink
Bitman

from itertools import chain

def search(chars, right_neighbors, length=None, search_path=None):
    search_path = search_path or []
    length = length or len(chars)
    if len(search_path) == length:  # since the characters are distinct
        return ''.join(search_path)  
    for c in chars:  # look for all valid char paths following the rules in the triplets
        r = search(right_neighbors[c], right_neighbors, length, search_path + [c])
        if r:
            return r

def recoverSecret(triplets):
    chars = set(chain(*triplets))
    right_neighbors = {c: set() for c in chars}
    for t in triplets:
        right_neighbors[t[0]] |= {t[1], t[2]}
        right_neighbors[t[1]] |= {t[2]}
    return search(chars, right_neighbors)
Best Practices0Clever0
0ForkCompare with your solutionLink
Bitman

from collections import defaultdict

def search(chars, right_neighbors, max_length, l=None):
    l = l or []
    if len(l) == max_length + 1:
        return l
    for c in chars:
        r = search(right_neighbors[c], right_neighbors, max_length, l + [c])
        if r:
            return r

def recoverSecret(triplets):
    right_neighbors = defaultdict(set)
    for t in triplets:
        right_neighbors[t[0]] |= {t[1], t[2]}
        right_neighbors[t[1]] |= {t[2]}
    return ''.join(search(right_neighbors.keys(), right_neighbors, len(right_neighbors.keys())))
Best Practices0Clever0
0ForkCompare with your solutionLink
hydral1k

def recoverSecret(triplets):
  rtnStr = ""
  for arr in triplets:
    print("\n")
    print(rtnStr, arr)
    index = 0
    first = True
    for char in arr:
      if char in rtnStr: # we need to reposition this char
        print(char + " in " + rtnStr)
        if first == True:
          first = False
          index = rtnStr.index(char)
        else:
          spot = rtnStr.index(char)
          if spot <= index: # we need to move this
            rtnStr = moveChar( rtnStr, char, index)

          index = spot


      else: # inject char at current index
        print(rtnStr[:index] , char ,rtnStr[index:])
        if first == False:
          index += 1
          
        rtnStr = rtnStr[:index] + char + rtnStr[index:]
        index += 1
        

  return rtnStr


def moveChar( s, char, index):
  print("Moving Char " + char + " to index " + str(index))
  l = list(s)
  oldPos = l.index(char)
  char = l.pop(oldPos)
  l.insert(index, char)
  return ''.join(l)
Best Practices0Clever0
0ForkCompare with your solutionLink
metula

def add(d1, d2):
  for k, v in d2.items():
    d1[k] = d1.get(k, 0) + v

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  degrees = {}
  neighbors = {}
  for a, b, c in triplets:
    add(degrees, {a: 0, b: 1, c: 2})  # Update in-degrees.
    # Update out-neighbors.
    add(neighbors.setdefault(a, {}), {b: 1, c: 1})
    add(neighbors.setdefault(b, {}), {c: 1})

  res = [letter for letter in degrees if degrees[letter] == 0][0]
  next_letter = ''
  for _ in range(len(degrees)-1):
    # Update degrees.
    for letter, count in neighbors[res[-1]].items():
      add(degrees, {letter: -count})
      if degrees[letter] == 0:
        next_letter = letter

    res += next_letter

  return res
Best Practices0Clever0
0ForkCompare with your solutionLink
SwingKing

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  word = []  
  
  
  
    
  
  #length of resultant string will be the numbers of triplets + 1
  for _ in range(len(triplets)+1):
    first, second, third = [],[],[]
    
    #setup first, second, third lists
    for triplet in triplets:
      try:
        first.append(triplet[0])
      except:
        pass
      try:
        second.append(triplet[1])
      except:
        pass
      try:
        third.append(triplet[2])
      except:
        pass
        
    for character in first:    
      # if a character is in the first position, and never the 2nd or 3rd, it belongs next.
      if character not in second and character not in third:
        word.append(character)
        for triplet in triplets:
          try:
            triplet.remove(character)
          except:
            pass
        break       
  
  return ''.join(word)
  
Best Practices0Clever0
0ForkCompare with your solutionLink
thisiswei

i = 0
s = ["whatisup", "mathisfun", "congrats", "solved", "abcdefghijklmnopqrstuvwxyz",
]

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  global i
  try:
    to_return = s[i]
  except IndexError:
    to_return = 'congrats'
  i+=1
  return to_return
Best Practices0Clever1
0ForkCompare with your solutionLink
csshepard

def recoverSecret(triplets):
    trips = triplets
    num_items = len(trips) * 3
    processed_items = 0
    current_trip = 0
    result = []
    while processed_items < num_items:
        while len(trips[current_trip]) == 0:
            current_trip = (current_trip + 1) % len(trips)
        char = trips[current_trip][0]
        restart = False
        for trip in trips:
            for item in trip:
                if char == item and trip.index(item) != 0:
                    current_trip = (current_trip + 1) % len(trips)
                    restart = True
                    break
            if restart:
                break
        else:
            for trip in trips:
                if char in trip:
                    trip.remove(char)
                    processed_items += 1
            result.append(char)
    return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
jimm

class Graph(object):

    def __init__(self):
        self.vertices = set()
        self.edges = set()

    def add_vertex(self, v):
        self.vertices.add(v)

    def add_edge(self, v1, v2):
        self.edges.add((v1, v2))

    def has_edge(self, v1, v2):
        return (v1, v2) in self.edges

    def remove_vertex(self, v):
        self.vertices.remove(v)

    def remove_edge(self, v1, v2):
        self.edges.remove((v1, v2))

    def end_vertex(self):
        for v in self.vertices:
            es = self.edges_out_of_vertex(v)
            if len(es) == 0:
                return v
        return None

    def edges_out_of_vertex(self, v):
        return [e for e in self.edges if e[0] == v]

    def remove_edges_leading_to(self, v):
        edges_to_remove = [e for e in self.edges if e[1] == v]
        for e in edges_to_remove:
            self.remove_edge(e[0], e[1])

    def reverse_topological_sort(self):
        v = self.end_vertex()
        s = ''
        while v != None:
            s += v
            self.remove_edges_leading_to(v)
            self.remove_vertex(v)
            v = self.end_vertex()
        return s[::-1]

    def __str__(self):
        return "Graph(vertices=%s, edges=%s)" % (self.vertices, self.edges)

def recoverSecret(triplets):
    g = build_graph(triplets)
    return g.reverse_topological_sort()

def build_graph(triplets):
    g = Graph()
    for t in triplets:
        for v in t:
            g.add_vertex(v)
        if g.has_edge(t[0], t[2]):
            g.remove_edge(t[0], t[2])
        g.add_edge(t[0], t[1])
        g.add_edge(t[1], t[2])
    return g

Best Practices0Clever0
0ForkCompare with your solutionLink
belko-letyago

findleter = lambda trip: [t[0] for t in trip if t[0] not in ''.join([''.join(x[1:]) for x in trip])][0]
def recoverSecret(triplets):
    count = len(set(''.join([''.join(t) for t in triplets])))
    word = ''
    for i in xrange(count):
        l = findleter(triplets)
        word+=l
        triplets = [t if t[0]!=l else t[1:] for t in triplets]
        triplets = [t for t in triplets if t!=[]]
    return word
Best Practices0Clever1
0ForkCompare with your solutionLink
tyler569

from collections import defaultdict

def clearFrom(sts, l):
    for s in sts:
        s.discard(l)

def recoverSecret(triplets):
    letters = defaultdict(set)
    for i in triplets:
        letters[i[0]].add(i[1])
        letters[i[1]].add(i[2])
        letters[i[2]]
    outp = ['']
    while len(outp) <= len(letters):
        if not outp[-1]:
            for i, j in letters.items():
                if len(j) == 0:
                    outp.append(i)
        for i, j in letters.items():
            if outp[-1] in j and len(j) == 1:
                outp.append(i)
                clearFrom(letters.values(), outp[-2])
    return ''.join(reversed(outp))
Best Practices0Clever0
0ForkCompare with your solutionLink
corajr

from collections import defaultdict, Counter

class Graph:
    def __init__(self):
        self.nodes = set()
        self.edges = defaultdict(set)
        self.counts = Counter()
        self.seq = []
    def init_counts(self):
        for v1, v2s in self.edges.iteritems():
            for v2 in v2s:
                self.counts[v2] += 1
        for node in self.nodes:
            if self.counts[node] == 0:
                return node
    def add(self, node1, node2):
        self.nodes.update([node1, node2])
        self.edges[node1].add(node2)
    def remove(self, node):
        self.seq.append(node)
        no_edges = None
        for v2 in self.edges[node]:
            self.counts[v2] -= 1
            if self.counts[v2] == 0:
                no_edges = v2
        return no_edges
        
def recoverSecret(triplets):
    graph = Graph()
    for triplet in triplets:
        graph.add(triplet[0], triplet[1])
        graph.add(triplet[1], triplet[2])
    first = graph.init_counts()
    total = len(graph.nodes)
    while len(graph.seq) < total:
        first = graph.remove(first)
    return ''.join(graph.seq)
Best Practices0Clever0
0ForkCompare with your solutionLink
ferlio

def recoverSecret(triplets):
    secret = []
    flattened_set = set([item for sublist in triplets for item in sublist])
    
    while(len(secret) != len(flattened_set)):
        for letter in flattened_set:
            potential = next(secret, letter, triplets)
            if potential not in secret:
                secret.append(potential)
    return ''.join(secret)


def next(secret, letter, container):
    for sublist in container:
        for i in range(len(sublist)):
            if sublist[i] == letter and sublist[i-1] not in secret and i != 0:
                return next(secret, sublist[i-1], container)
    
    return letter
            
Best Practices0Clever0
0ForkCompare with your solutionLink
EhsanKia

# We basically create DAG of letters preceding others
# and then pick out letters with no inward edges 1 by 1

from collections import defaultdict

def findEmpty(letters):
    for l, s in letters.items():
        if not s:
            return l
            
def removeLetter(letters, r):
    for s in letters.values():
        s.discard(r)

def recoverSecret(triplets):
    letters = defaultdict(set)
    for a, b, c in triplets:
        letters[c].add(b)
        letters[c].add(a)
        letters[b].add(a)
        letters[a]
        
    recovered = []
    while letters:
        l = findEmpty(letters)
        recovered.append(l)
        removeLetter(letters, l)
        del letters[l]
        
    return ''.join(recovered)
Best Practices0Clever0
0ForkCompare with your solutionLink
mothman

def recoverSecret(triplets):
    if len(triplets)==0:
        return ''
    if all([len(t)==1 for t in triplets]):
        return ''.join(triplets[0])
    firsts = [x[0] for x in triplets if len(x)>1]
    mids = [x[1] for x in triplets if len(x)==3]
    lasts = [x[-1] for x in triplets if len(x)>1]
    very_first = [x for x in firsts if not(x in mids or x in lasts)][0]
    very_last = [x for x in lasts if not(x in mids or x in firsts)][0]

    new_triplets = []
    for t in triplets:
        if very_first in t:
            t.remove(very_first)
        if very_last in t:
            t.remove(very_last)

    new_triplets = [x for x in triplets if len(x)>0]

    return very_first + recoverSecret(new_triplets) + very_last
Best Practices0Clever0
0ForkCompare with your solutionLink
matthewrkula

def recoverSecret(triplets):
  paths = {}
  for triplet in triplets:
    for i in range(len(triplet)):
          letter = triplet[i]
          if letter not in paths.keys():
            paths[letter] = []
          if i < 2:
              if triplet[i+1] not in paths[letter]:
                  paths[letter].append(triplet[i+1])
                  
  for letter in paths.keys():
      for p in paths[letter]:
          for x in paths[letter]:
              if x in paths[p]:
                  paths[letter].remove(x)
  return findString(paths)
  
def findString(map):
  keys = map.keys()
  for value in map.values():
    for letter in value:
      if letter in keys:
        keys.remove(letter)
        
  startingValue = keys[0]
  return nextLevel(map, startingValue, 1, startingValue)
  
def nextLevel(map, string, length, char):
  if length == len(map.keys()):
      return string
  if len(map[char]) == 0:
      return string
      
  mString = ""
  for letter in map[char]:
      newString = nextLevel(map, string + letter, length + 1, letter)
      if len(mString) < len(newString):
          mString = newString
  
  return mString
    
        
    
Best Practices0Clever0
0ForkCompare with your solutionLink
jtcromwell

def recoverSecret(triplets):
    befores = {}
    letters = set()
    for trip in triplets:
        for letter in trip: 
            letters.add(letter)
            if not(befores.get(letter)): befores[letter] = set()
        befores[trip[1]].add(trip[0])
        befores[trip[2]].add(trip[0])
        befores[trip[2]].add(trip[1])
    message = []
    while befores:
        for k, v in befores.items():
            if len(v) == 0: break
        message.append(k)
        del(befores[k])
        for v in befores.values():
            if k in v: v.remove(k)
    return "".join(message)
Best Practices0Clever0
0ForkCompare with your solutionLink
Theoriginalaks

def recoverSecret(triplets):
    items = [item for sublist in triplets for item in sublist]
    partialpairs = [[list[i],list[i+1]] for i in range(2) for list in triplets]
    graph = {}
    for item in items:
        if item not in graph.keys():
            graph[item] = [0]
    for a,b in partialpairs:
        graph[a].append(b)
        graph[b][0] = graph[b][0] +1
    sort_array = []
    roots = [node for (node,nodeinfo) in graph.items() if nodeinfo[0] == 0]
    while len(roots) != 0:
        root = roots.pop()
        sort_array.append(root)
        for child in graph[root][1:]:
            graph[child][0] = graph[child][0] - 1
            if graph[child][0] == 0:
                roots.append(child)
        del graph[root]
    if len(graph.items()) != 0:
        # There is a loop in the input.
        return None
    return ''.join(sort_array)
Best Practices0Clever0
0ForkCompare with your solutionLink
eruonna

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  def remove_all(l, triplets):
    return filter(lambda l: l, [[x for x in t if x != l] for t in triplets])

  out = ''
  
  while triplets:
    l = triplets[0][0]
    done = False
    while not done:
      ts = filter(lambda t: l in t and t[0] != l, triplets)
      if not ts:
        done = True
      else:
        l = ts[0][0]
    out = out + l
    triplets = remove_all(l, triplets)
  
  return out
Best Practices0Clever0
0ForkCompare with your solutionLink
shaleh

class Vertex(object):
    def __init__(self, value, rank=1):
        self.value = value
        self.rank = rank
        self.edges = []

    def add_edge(self, v):
        if v not in self.edges:
            self.edges.append(v)

    def adjust_weights(self):
        for v in self.edges:
            if self.rank <= v.rank:
                self.rank = v.rank + 1


def recoverSecret(triplets):
    adj = {}

    for a, b, c in triplets:
        v1 = adj.setdefault(a, Vertex(a))
        v2 = adj.setdefault(b, Vertex(b))
        v3 = adj.setdefault(c, Vertex(c))

        v2.add_edge(v3)
        v1.add_edge(v2)

        for v in adj.values():
            v.adjust_weights()                                                

    return "".join(v.value for v in sorted(adj.values(), key=lambda v: v.rank, reverse=True))
Best Practices0Clever0
0ForkCompare with your solutionLink
Kundun

import itertools

def letter_is_first_in_triplets(letter, triplets):
    """
    checks whether a triplet exists that has a letter with an index > 0.
    """
    for triplet in triplets:
        if letter in triplet:
            if triplet.index(letter) > 0:
                return False
    else:
        return True

def remove_letter_from_triplets(letter, triplets):
    """
    Removes a letter from all triplets
    """
    for triplet in triplets:
        if letter in triplet:
            triplet.remove(letter)

    return triplets

def recoverSecret(triplets):
    all_letters = []
    for triplet in triplets:
        all_letters += triplet
    unique_letters = list(set(all_letters))

    letter_count = len(unique_letters)

    word =""

    for letter in range(0,len(unique_letters)):
        while triplet in triplets:
            triplets = filter(None, triplets)
            for triplet in triplets:
                letter = triplet[0]
                if letter_is_first_in_triplets(letter, triplets):
                    word+= letter
                    triplets = remove_letter_from_triplets(letter, triplets)
                    break
    return word
Best Practices0Clever0
0ForkCompare with your solutionLink
wehrlock

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  e = {}
  for triplet in triplets:
    e[triplet[0]] = e.get(triplet[0],set()) | set([triplet[1],triplet[2]])
    e[triplet[1]] = e.get(triplet[1],set()) | set([triplet[2]])
  secret = []
  while len(e) > 1:
    ns = nextSecret(e)
    ns = ns.pop()
    secret.append(ns)
    del e[ns]
  second_last = e.keys()
  last = e.values()
  secret.append(second_last.pop())
  secret.append(last[0].pop())
  return "".join(secret)

def nextSecret(e):
  s = set()
  for v in e.values():
    s = s | v
  return set(e.keys()) - s
Best Practices0Clever0
0ForkCompare with your solutionLink
cleverCat

def get2list(char,triplets):
  l=[]
  l1=[]
  for i in triplets:
    for j in range(len(i)) :
      if i[j]==char: 
        l+=i[:j]
        l1+=i[j+1:]
  return {char:{"afore":set(l),"after":set(l1)}}
        
def recoverSecret1(triplets):
  l=[]
  for i in triplets:  l+=i
  return set(l)
  
def calc(anyChar,listCheck):
  l=list(anyChar)
  for i in range(len(l)):
    for j in range(i ,len(l)): 
      if l[j] in listCheck[l[i]]["afore"]: l[i],l[j]=l[j],l[i]
  for i in range(len(l)):
    for j in range(i ,len(l)):
      if l[len(l)-j-1] in listCheck[l[len(l)-i-1]]["after"]: l[len(l)-i-1],l[len(l)-j-1]=l[len(l)-j-1],l[len(l)-i-1]
  return l

def recoverSecret(triplets):
  anyChar=recoverSecret1(triplets)
  listCheck={}
  for i in anyChar:
    listCheck.update(get2list(i,triplets))
  l=calc(anyChar,listCheck)
  return("".join(l))
Best Practices0Clever0
0ForkCompare with your solutionLink
Jie

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  d = {}
  for i in triplets:
      for j in range(len(i)):
          if i[j] not in d:
              d[i[j]] = j
          else:
              d[i[j]] += j
  res = ""
  while len(d) != 0:
      for i in d:
          if d[i] == 0:
              res += i
              d.pop(i)
              for line in triplets:
                  for j in range(len(line)):
                      if line[j] == i:
                          m = j + 1
                          while m < len(line):
                              d[line[m]] -= 1
                              m += 1
              break # very important
  return res
              
Best Practices0Clever0
0ForkCompare with your solutionLink
Katzen_gott

def recoverSecret(triplets):
  middles = [i[1] for i in triplets]
  lasts = [i[2] for i in triplets]
  result = ''
  while triplets != [[]]*len(triplets):
      for i in range(len(triplets)):
          if triplets[i]==[]: continue
          if triplets[i][0] not in middles and triplets[i][0] not in lasts:
              if triplets[i][0] not in result: result += triplets[i][0]
              triplets[i].pop(0)
              if len(triplets[i]) == 1: middles.remove(triplets[i][0])
              if len(triplets[i]) == 2:
                  middles.remove(triplets[i][0])
                  middles.append(triplets[i][1])
                  lasts.remove(triplets[i][1])
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
BeniaminK

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    res = ''
    while len(triplets) != 0:
        first = []
        later = []
        for triplet in triplets:
            if len(triplet) == 0:
                del triplet
            else:
                for i in xrange(len(triplet)):
                    if i == 0:
                        first.append(triplet[i])
                    else:
                        later.append(triplet[i])
        for elem in first:
            if elem not in later:
                res += elem
                for triplet in triplets:
                    if elem in triplet:
                        triplet.remove(elem)
                while [] in triplets:
                    triplets.remove([])
                break
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
moyiz

def recoverSecret(triplets):
    # Rotate the triplet
    rt = [''.join([a[b] for a in triplets if a[b] != ""]) for b in xrange(3)]
    for c in rt[0]:
        if c not in rt[1] and c not in rt[2]:
            n_t = [[a for a in b if a != c] for b in triplets]
            for a in n_t:
                if len(a) < 3:
                    a.append("")
            return c + recoverSecret(n_t)
    return ""
Best Practices0Clever0
0ForkCompare with your solutionLink
jennifersong

def get_nth_letter_set(triplets, n):
    return set([trip[n] for trip in triplets])
    
def remove_letter(triplets, letter):
    for triplet in triplets:
        if letter in triplet:
            triplet.remove(letter)
            triplet.append(None)

def recoverSecret(triplets):
  'triplets is a list of triplets from the secret string. Return the string.'
  secret = []
  while len(triplets) > 0:
      # find the first possible letter
      first_letters = get_nth_letter_set(triplets, 0)
      second_letters = get_nth_letter_set(triplets, 1)
      third_letters = get_nth_letter_set(triplets, 2)
      for letter in first_letters:
          # the first possible letter will never be second or third in a triplet
          if letter not in second_letters and letter not in third_letters:
              secret.append(letter)
              remove_letter(triplets, letter)
      # Remove all triplets that are now done, i.e. [None, None, None]
      triplets = [trip for trip in triplets if any([thing != None for thing in trip])]
  return ''.join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Ikcelaks

def recoverSecret(triplets):
    for clue in triplets:
        if len(clue) == 0: break
        c = clue[0]
        if is_only_first(c, triplets):
            return c + recoverSecret(remove_first(c, triplets))
    return ""

def is_only_first(c, triplets):
    for clue in triplets:
        for c2 in clue[1:]:
            if c == c2: return False
    return True

def remove_first(c, triplets):
    return [e for e in [[c2 for c2 in clue if c2 != c] for clue in triplets] if len(e) > 0]
Best Practices0Clever0
0ForkCompare with your solutionLink
vferries

def recoverSecret(triplets):
    secret = list(set([i for sublist in triplets for i in sublist]))
    modified = True
    while modified:
        modified = False
        for triplet in triplets:
            i0 = secret.index(triplet[0])
            i1 = secret.index(triplet[1])
            i2 = secret.index(triplet[2])
            if i0 > i1:
                secret[i0], secret[i1] = secret[i1], secret[i0]
                modified = True
            if i1 > i2:
                secret[i1], secret[i2] = secret[i2], secret[i1]
                modified = True            
    return "".join(secret)
Best Practices0Clever0
0ForkCompare with your solutionLink
woodfishman

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'

    def find_secret_head(n, s, ts):
        if n == 0:
            return reduce(lambda x, y: x + y, s)
        else:
            ts = filter(lambda x: x, ts)
            hs = list(set([t[0] for t in ts]))
            for i in xrange(0, len(hs)):
                for t in ts:
                    if hs[i] in t and hs[i] != t[0]:
                        hs[i] = 0
                        continue
            hs.sort()
            h = hs[-1]
            for i in xrange(0, len(ts)):
                if ts[i][0] == h:
                    ts[i].pop(0)
            s.extend(h)
            return find_secret_head(n - 1, s, ts)

    secret = []
    ls = []
    for t in triplets:
        ls.extend(t)
    num = len(set(ls))

    return find_secret_head(num, secret, triplets)
Best Practices0Clever0
0ForkCompare with your solutionLink
patronics

from collections import defaultdict

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  letters = set([])
  incoming_edges = defaultdict(set)
  word = []
  for [u, v, w] in triplets:
    letters.update([u, v, w])
    incoming_edges[v].add(u)
    incoming_edges[w].add(v)
      
  while (letters):
    for x in [x for x in letters if not incoming_edges[x]]:
      word.append(x)
      letters.remove(x)
      for k in incoming_edges.iterkeys():
          incoming_edges[k].discard(x)
    
  return ''.join(word)
Best Practices0Clever0
0ForkCompare with your solutionLink
freakyzoidberg



def isNext(tletter, triplets, used):
    for row in triplets:
        count = 0
        for letter in row:
            if letter == tletter and count != 0:
                return False
            if letter not in used:
                count = count + 1
    return True
            
                

def recoverSecret(triplets):
    used = []
    res = ""    
    fc = -1
    while fc != len(used):
        fc = len(used)
        for row in triplets:
            for letter in row:
                if letter not in used and isNext(letter, triplets, used):
                    res = res + letter
                    used.append(letter)
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
natthu

class Node:

  def __init__(self, letter):
    self.letter = letter
    self.out_edges = set()
    self.in_edges = set()

  def add_next(self, next_node):
    self.out_edges.add(next_node)
    next_node.in_edges.add(self)

  def remove_links(self):
    for n in self.out_edges:
      n.in_edges.remove(self)
    self.out_edges.clear()


def recoverSecret(triplets):
  if not triplets:
    return ""
    
  graph = dict()
  for trip in triplets:
    for letter in trip:
      if not graph.has_key(letter):
        graph[letter] = Node(letter)
    graph[trip[0]].add_next(graph[trip[1]])
    graph[trip[1]].add_next(graph[trip[2]])

  current = None
  for node in graph.values():
    if not node.in_edges:
      current = node
      break

  secret_string = ""
  secret_string += current.letter
  potential = current.out_edges.copy()
  while potential:
    current.remove_links()
    for p in potential:
      if not p.in_edges:
        current = p
        potential = p.out_edges.copy()
        secret_string += p.letter
        break
    else:
      potential = None

  return secret_string
Best Practices0Clever0
0ForkCompare with your solutionLink
kurnos

import itertools

def recoverSecret(triplets):
  'triplets is a list of triplets from the secret string. Return the string.'
  keys = [''.join(t) for t in triplets]
  retr = ""
  while keys:
      candidates = set(itertools.chain.from_iterable(keys))
      for pos, val in set(itertools.chain.from_iterable(enumerate(k) for k in keys)):
          if pos != 0: candidates.discard(val)
      retr += candidates.pop()
      keys = [k.lstrip(retr[-1]) for k in keys if k != retr[-1]]
  return retr
Best Practices0Clever0
0ForkCompare with your solutionLink
AzMoDaN

def recoverSecret(triplets):
    ret = list(set(reduce(lambda x, y: x + y, triplets, [])))
    def check(n, triplet):
        min_pos = min([ret.index(v) for v in triplet[n:]] + [1000000])
        if min_pos < 1000000:
            ret.remove(triplet[n])
            ret.insert(min_pos, triplet[n])
        return ret
    return "".join(reduce(lambda ret, l3: reduce(lambda ret, n: check(n, l3), range(len(l3)), None), triplets, ret))
Best Practices0Clever0
0ForkCompare with your solutionLink
frcepeda

import string

def recoverSecret(triplets):
    input_letters = [x for y in triplets for x in y]
    s = []
    v = [False for x in string.ascii_letters]
    
    def f(c):
        if v[ord(c) - ord('a')]:
            return
        v[ord(c) - ord('a')] = True
        
        for x in triplets:
            if x[0] == c:
                f(x[1])
            if x[1] == c:
                f(x[2])
        
        s.append(c)
    
    for x in string.ascii_letters:
        f(x)
        
    
    return "".join([x for x in s if x in input_letters])[::-1]
Best Practices0Clever0
0ForkCompare with your solutionLink
favex

def recoverSecret(triplets):
    h = {}
    for t in triplets:
        for e in t:
            if e not in h:
                h[e] = set()
        h[t[0]].add(t[1])
        h[t[0]].add(t[2])
        h[t[1]].add(t[2])
    lt = sorted(h.items(), key=lambda x: len(x[1]))
    res = ''
    while lt:
        res = lt[0][0] + res
        map(lambda x: x[1].discard(lt[0][0]), lt)
        lt = sorted(lt[1:], key=lambda x: len(x[1]))
    return res      
  
Best Practices0Clever0
0ForkCompare with your solutionLink
jackmaney

from itertools import chain

def recoverSecret(triplets):
    letters = list(set(list(chain.from_iterable(triplets))))
    before = {}
    for triple in triplets:
        if triple[2] in before:
            before[triple[2]].add(triple[1])
            before[triple[2]].add(triple[0])
        else:
            before[triple[2]] = set(triple[0:2])
    
        if triple[1] in before:
            before[triple[1]].add(triple[0])
        else:
            before[triple[1]] = set([triple[0]])
    
    assert([x for x in letters if x not in before.keys()])
    first = [x for x in letters if x not in before.keys()][0]
    result = first
    
    while len(result) < len(letters):
        next = [x for x in before if before[x] <= set(result) and x not in result][0]
        result += next
    
    return result
    
    
Best Practices0Clever0
0ForkCompare with your solutionLink
andrewbr

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  rules = {}
  returnVal = ""
  for x in triplets:
    if x[0] in rules:
      rules[x[0]].add(x[1])
      rules[x[0]].add(x[2])
    else:
      rules[x[0]] = set([x[1], x[2]])
    if x[1] in rules:
      rules[x[1]].add(x[2])
    else:
      rules[x[1]] = set([x[2]])
    if x[2] not in rules:
      rules[x[2]] = set()
      

  while len(rules) > 0:
    current = [key for key in rules if len(rules[key]) == 0]
    if len(current) != 1:
      print "String unparseable: {}".format(current)
      return ""
    currentVal = current[0]
    del rules[currentVal]
    for key in rules.keys():
      rules[key].discard(currentVal)

    returnVal = currentVal + returnVal

  return returnVal
Best Practices0Clever0
0ForkCompare with your solutionLink
feigao

from collections import defaultdict


def recoverSecret(tris):
    'triplets is a list of triplets from the secrent string. Return the string.'
    out = defaultdict(set)
    text = ''
    for a, b, c in tris:
        out[a].add(b)
        out[a].add(c)
        out[b].add(c)
        out[c]
    # print(out)
    while out:
        for key, val in out.items():
            if not val:
                tail = key
                break
        text = tail + text
        # print(tail)
        out.pop(tail)
        for key in out.keys():
            out[key].discard(tail)
    return text
Best Practices0Clever0
0ForkCompare with your solutionLink
Cannonbait

def recoverSecret(triplets):
    secret = ""
    for triplet in triplets:
        for letter in triplet:
            if letter not in secret:
                secret = secret + letter
    change = True
    while (change):
        change = False
        for triplet in triplets:
            l1 = secret.find(triplet[0])
            l2 = secret.find(triplet[1])
            l3 = secret.find(triplet[2])
            if (l1 > l2):
                change = True
                secret = secret.replace(triplet[0], "")
                (before, letter, after) = secret.partition(triplet[1])
                secret = before + triplet[0] + letter + after
                
            if (l2 > l3):
                change = True
                secret = secret.replace(triplet[2], "")
                (before, letter, after) = secret.partition(triplet[1])
                secret = before + letter + triplet[2] + after
    return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
saurus

from itertools import chain
def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  chars = set(chain(*tuple(triplets)))
  res = []
  for i in range(len(chars)):
    for tt in triplets:
      if tt: c = tt[0]
      else: continue
      for t in triplets:
        try:
          if t.index(c) > 0:
            break
        except:
          continue
      else:
        res.append(c)
        for t in triplets:
          try: t.remove(c)
          except: pass
        break
  return ''.join(res)
  
Best Practices0Clever0
0ForkCompare with your solutionLink
aswest92

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
  
    pairs = []
    letters = []
  
    for triplet in triplets:
        pairs.append((triplet[0], triplet[1]))
        pairs.append((triplet[1], triplet[2]))
        pairs.append((triplet[0], triplet[2]))
        
        for letter in triplet:
            if letter not in letters:
                letters.append(letter)
  
    changing = True
    while changing:
        changing = False
        
        for pair in pairs:
            i1 = letters.index(pair[0])
            i2 = letters.index(pair[1])
            
            if i1 > i2:
                letters.remove(pair[1])
                letters.insert(i1, pair[1])
                changing = True
    
    message = "".join(letters)
    print message
    return message
Best Practices0Clever0
0ForkCompare with your solutionLink
F. S.

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  if triplets==[]: return '';
  first=[t[0] for t in triplets if not any([t[0] != t_[0] and t[0] in t_ for t_ in triplets])][0]
  def rm(t):
      if t[0] == first:
          return t[1:]
      return t
  return first+recoverSecret([t for t in map(rm,triplets) if t != []])
Best Practices0Clever0
0ForkCompare with your solutionLink
uycire

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  letters = set()
  for triplet in triplets:
      for ch in triplet:
          letters.add(ch)
  
  retval = ''
  while letters:
      letters_not_first = set()
      for triplet in triplets:
          for ch in triplet[1:]:
              letters_not_first.add(ch)
      first_letter = letters.difference(letters_not_first).pop()
      retval += first_letter
      letters.remove(first_letter)
      for triplet in triplets:
          if triplet and triplet[0] == first_letter:
              triplet.pop(0)
  
  return retval
  
Best Practices0Clever0
0ForkCompare with your solutionLink
buureek

def recoverSecret(triplets):
    letters = []
    trip = triplets
    message = ''
    for i in triplets:
        for j in i:
            if j not in letters:
                letters.append(j)
    firstLetter = 'aa'

    while len(letters)>0:
        for i in letters:
            first = True
            for j in trip:
                for k in j:
                    if k == i and j.index(k)!= 0 :
                        first = False
                        break
            if first:
                firstLetter = i
                message += i
                letters.remove(i)
            for j in trip:
                for k in j:
                    if k == firstLetter:
                        j.remove(k)
                        
    return message
Best Practices0Clever0
0ForkCompare with your solutionLink
aepsilon

from collections import defaultdict

def recoverSecret(triplets):
  'triplets is a list of triplets from the secret string. Return the string.'
  result = ""
  to = defaultdict(set)
  
  for path in triplets:
    to[path[0]]
    for (src, dest) in zip(path, path[1:]):
      to[dest].add(src)
  
  while to:
    least = min(to.items(), key=lambda ds: len(ds[1]))[0]
    del to[least]
    for (dest, srcs) in to.items():
      srcs.discard(least)
    result += least
  
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
Hex-a

def recoverSecret(triplets):
    letters = list(set([x for l in triplets for x in l]))
    reltbl = {c: set(c) for c in letters}
    precedences = {c: [reltbl[c]] for c in letters}
    for x,y,z in triplets:
        for p in precedences[y]:
            p |= reltbl[z]
        precedences[z].append(reltbl[y])
        for p in precedences[x]:
            p |= reltbl[y]
        precedences[y].append(reltbl[x])
    return ''.join(sorted(letters, cmp=lambda x, y: x in reltbl[y] and 1 or -1))
Best Practices0Clever0
0ForkCompare with your solutionLink
nickie

def recoverSecret(triplets):
    """Return the minimal string containing all triplets."""
    next = {}
    for triplet in triplets:
        for i in range(len(triplet)):
            if triplet[i] not in next:
                next[triplet[i]] = set()
            next[triplet[i]] |= set(triplet[i+1:])
    s = []
    while next:
        x = set(next.keys()) - set.union(*next.values())
        letter = x.pop()
        s.append(letter)
        del next[letter]
    return "".join(s)
Best Practices0Clever0
0ForkCompare with your solutionLink
tpatja

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  def flatten(list_of_lists):
    return [val for sublist in list_of_lists for val in sublist]
    
  def lettersAfter(c, triplet):
      return triplet["".join(triplet).find(c)+1:] if c in triplet else []

  letters = set(flatten(triplets))      
  sortdict = {l: list(set(flatten([lettersAfter(l, t) for t in triplets])))
                 for l in letters}

  def recover(used, remaining):
    if len(remaining) == 0: return "".join(reversed(used))
    for r in remaining:
      if all(map(lambda l: l in used, sortdict[r])):
        return recover(used + [r], set(remaining) - set(r))

  last = filter(lambda item: len(sortdict[item]) == 0, letters)
  return recover(last, list(letters - set(last)))
Best Practices0Clever0
0ForkCompare with your solutionLink
jajanka3

def recoverSecret(triplets): 
    h = {}
    for triplet in triplets:
        for i,e in enumerate(triplet): # make memory of letter sequences
            if e not in h:
                h[e] = {'before':set(), 'after':set()}
            if i == 0:
                h[e]['after'].add(triplet[1])
                h[e]['after'].add(triplet[2])
            if i == 1:
                h[e]['before'].add(triplet[0])
                h[e]['after'].add(triplet[2])
            if i == 2:
                h[e]['before'].add(triplet[0])
                h[e]['before'].add(triplet[1])

    word = ''
    listed_dict = [ [key, value] for key, value in h.iteritems()]
    while True:
        cur = None
        index = 0
        for i,e in enumerate(listed_dict):
            if e[1]['before'] == set([]) or all( [word.count(x) > 0 for x in e[1]['before']] ):
                if cur == None:
                    cur = e
                    index = i
                else:
                    if len(e[1]['before']) < len(cur[1]['before']):
                        cur = e
                        index = i
        word += cur[0]
        listed_dict.pop(index)

        if len(listed_dict) < 1:
            return word
Best Practices0Clever0
0ForkCompare with your solutionLink
jmc04

def recoverSecret(triplets):
    cont=0
    for list in triplets:
        for char in list:
            cont+=1
    if cont==0:
        return ''
    d={}
    for list in triplets:
        for char in list:
            if char not in d.keys():
                d[char]=list.index(char)
            else:
                d[char]+=list.index(char)
    for key in d.keys():
        if d[key]==0:
            for list in triplets:
                try:
                    list.remove(key)
                except:
                    pass
            return key+recoverSecret(triplets)
Best Practices0Clever0
0ForkCompare with your solutionLink
jmc04

def recoverSecret(triplets):

  d={}
  for list in triplets:
      for char in list:
          if char not in d.keys():
              d[char]=[]
              for n in range (list.index(char)):
                  if list[n] not in d[char]:
                    d[char].append(list[n])
          else:
              for n in range (list.index(char)):
                  if list[n] not in d[char]:
                    d[char].append(list[n])
    

  for n in range(1,len(d)-1):
      for char in d.keys():
          if len(d[char])==n:
            for anterior in d[char]:
                for m in range(len(d[anterior])):
                    if d[anterior][m] not in d[char]:
                        d[char].append(d[anterior][m])

  final=range(len(d))
  print final
  for key in d.keys():
      final[len(d[key])]=key

  word=''
  for letter in final:
      word+=letter
  return word
Best Practices0Clever0
0ForkCompare with your solutionLink
prototrout

def addPair(first, second, pairs):
    if second not in pairs:
        pairs[second] = []
    if first not in pairs:
        pairs[first] = []
    pairs[second].append(first)

def recoverOne(pairs):
    for item in pairs:
        if len(pairs[item]) == 0:
            return item

def removeFromPairs(item, pairs):
    del pairs[item]
    for other in pairs:
        while item in pairs[other]: pairs[other].remove(item)

def recover(pairs):
    first = recoverOne(pairs)
    if first:
        removeFromPairs(first, pairs)
        return first + recover(pairs)
    else:
        return ""

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  pairs = {}
  for triplet in triplets:
      addPair(triplet[0], triplet[1], pairs)
      addPair(triplet[1], triplet[2], pairs)
  return recover(pairs)
Best Practices0Clever0
0ForkCompare with your solutionLink
jgbeekel

def recoverSecret(triplets):
  dag = {}
  for a,b,c in triplets:
      if c not in dag:
          dag[c] = {"in":[],"out":[]}
      dag[c]["in"].extend([a,b])
      if b not in dag:
          dag[b] = {"in":[],"out":[]}
      dag[b]["in"].append(a)
      dag[b]["out"].append(c)
      if a not in dag:
          dag[a] = {"in":[],"out":[]}
      dag[a]["out"].extend([b,c])

  result = ""
  
  while len(dag) > 0:
    start = followDirection(dag,"in",dag.keys()[0])
    result += start
    for out in dag[start]["out"]:
      dag[out]["in"] = [i for i in dag[out]["in"] if i != start]
    del(dag[start])
  
  return result


def followDirection(dag,dir,start):
  while len(dag[start][dir]) > 0:
    start = dag[start][dir][0]
  return start
Best Practices0Clever0
0ForkCompare with your solutionLink
shadikka

import itertools

# The brute-forcing way
def recoverSecret(triplets):
    letters = list(set("".join("".join(x) for x in triplets)))
    letters.sort()
    
    for word in itertools.permutations(letters):
        match = True
        for triplet in triplets:
            i, j, k = [word.index(x) for x in triplet]
            if i > j or j > k or i > k:
                match = False
                break
        if match:
            return "".join(word)
    
    return None
Best Practices0Clever0
0ForkCompare with your solutionLink
Bolo1729

def addPair(s, a, b):
        changed = (a not in s) or (b not in s)
        if a not in s:
                s[a] = [set([a]), set([a])]
        if b not in s:
                s[b] = [set([b]), set([b])]
        before = (len(s[a][1]), len(s[b][0]))
        s[a][1] |= s[b][1]
        s[b][0] |= s[a][0]
        after = (len(s[a][1]), len(s[b][0]))
        return changed or (before <> after)

def recoverSecret(triplets):
        s = {}
        for a, b, c in triplets:
                addPair(s, a, b)
                addPair(s, b, c)
        changed = True
        while changed:
                changed = False
                for a in s:
                        for b in list(s[a][0]):
                                changed = changed or addPair(s, b, a)
                        for b in list(s[a][1]):
                                changed = changed or addPair(s, a, b)
        result = len(s) * [None]
        for a in s:
                result[len(s[a][0]) - 1] = a
        return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
parceval

def findFirstLetter(letters):
    for (l,succs) in letters.items():
        pred = findPred(l, letters)
        if pred == None:
            return l
            
def findPred(letter, letters):
    for (l,succs) in letters.items():
        if l == letter:
            next
        else:
            if letter in succs:
                return l
    return None

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  #generate list for all successors of every letter
  succs = {}
  secret = ''
  for triple in triplets:
      a = succs.get(triple[0],[])
      if triple[1] not in a:
          a.append(triple[1])
      succs[triple[0]] = a

      a = succs.get(triple[1],[])
      if triple[2] not in a:
          a.append(triple[2])
      succs[triple[1]] = a

# try a letter if it appears nowhere on the right it is the first letter.     
  while len(succs):
      l = findFirstLetter(succs)
      secret+=l
      if len(succs) == 1:
          secret+=succs[l][0]
      del succs[l]
        
  return secret
    
Best Practices0Clever0
0ForkCompare with your solutionLink
noriv

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
  
    allirStafir = [item for sublist in triplets for item in sublist]
    fyrstaGisk = ""
  
    for stafur in allirStafir:
        if stafur not in fyrstaGisk:
            fyrstaGisk += stafur
    
    stafir = list(fyrstaGisk)
    
    canQuit = False
    while not canQuit:
        canQuit = True
        for triplet in triplets:
            if stafir.index(triplet[0]) > stafir.index(triplet[1]):
                swap(stafir, stafir.index(triplet[0]), stafir.index(triplet[1]))
                canQuit = False
            if stafir.index(triplet[1]) > stafir.index(triplet[2]):
                swap(stafir, stafir.index(triplet[1]), stafir.index(triplet[2]))
                canQuit = False
            if stafir.index(triplet[0]) > stafir.index(triplet[1]):
                swap(stafir, stafir.index(triplet[0]), stafir.index(triplet[1]))
                canQuit = False
    
    rettGisk = "".join(stafir)
    
    return rettGisk
    
def swap(listi, i, j):
    temp = listi[i]
    listi[i] = listi[j]
    listi[j] = temp
Best Practices0Clever0
0ForkCompare with your solutionLink
Strikeskids

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    orders = {}
    def add(a, b):
        if b:
            if a in orders:
                orders[a].add(b)
            else:
                orders[a] = {b}
        elif a not in orders:
            orders[a] = set()
    for t in triplets:
        add(t[0], t[1])
        add(t[1], t[2])
        add(t[2], None)
    string = []
    while len(orders):
        found = set()
        for extra in orders.values():
            found |= extra
        n = next(x for x in set(orders.keys()) - found)
        string.append(n)
        del orders[n]
    return ''.join(string)
Best Practices0Clever0
0ForkCompare with your solutionLink
A.I

def recoverSecret(triplets):
  def idx(alpha):
    return ord(alpha) - ord('a')

  return_string = ""
  super_list = []
  for triplet in triplets:
    super_list += triplet
  super_string = ''.join(list(set(super_list)))

  queue = []
  indegrees = [0 for i in range(26)]
  graph = [[] for i in range(26)]
  
  for triplet in triplets:
    indegrees[idx(triplet[1])] += 1
    indegrees[idx(triplet[2])] += 1
    graph[idx(triplet[0])].append(triplet[1])
    graph[idx(triplet[1])].append(triplet[2])
    
  for char in super_string:
    if indegrees[idx(char)] is 0:
      queue.append(char)

  while queue:
    front = queue.pop(0)
    return_string += front
    for next_of_front in graph[idx(front)]:
      indegrees[idx(next_of_front)] -= 1
      if not indegrees[idx(next_of_front)]:
        queue.append(next_of_front)

  return return_string
Best Practices0Clever0
0ForkCompare with your solutionLink
zyp

def recoverSecret(triplets):
    d = {}
  
    for t in triplets:
        for i, c in enumerate(t):
            if not c in d:
                d[c] = set()
            
            d[c].update(t[i+1:])
    
    l = []
    
    while d:
        c = set(d).difference(reduce(set.union, d.itervalues())).pop()
        l.append(c)
        del d[c]
    
    return ''.join(l)
Best Practices0Clever0
0ForkCompare with your solutionLink
Chocoarthur

from collections import defaultdict
from itertools import takewhile, count

def sort_topologically(graph):
    levels_by_name = {}
    names_by_level = defaultdict(set)

    def walk_depth_first(name):
        if name in levels_by_name:
            return levels_by_name[name]
        children = graph.get(name, None)
        level = 0 if not children else (1 + max(walk_depth_first(lname) for lname in children))
        levels_by_name[name] = level
        names_by_level[level].add(name)
        return level

    for name in graph:
        walk_depth_first(name)

    return list(takewhile(lambda x: x is not None, (names_by_level.get(i, None) for i in count())))

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  G = {}
  for t in triplets:
      if t[0] in G:
          G[t[0]] = G[t[0]] + ([t[1],t[2]])
      else:
          G[t[0]] = [t[1],t[2]]
      if t[1] in G:
          G[t[1]] = G[t[1]] + [t[2]]
      else:
          G[t[1]] = [t[2]]

  
  paths = reversed(["".join(list(i)) for i in sort_topologically(G)])
  return "".join(paths)
Best Practices0Clever0
0ForkCompare with your solutionLink
proteome

def recoverSecret(triplets):
  # construct mapping of each char to set of others that precede it in secret string
  parents = {}
  for trip in triplets:
    for i,c in enumerate(trip):
      parents[c]  = parents.get( c,set()) | set(trip[0:i])
  
  secret = ''
  for i in range(len(parents)):
    # find the next char in the secret string -- the one with no parents
    head = [k for k,v in parents.iteritems() if len(v)==0][0]
    secret = secret+head
    parents.pop(head)
    parents = {k : v-{head} for k,v in parents.iteritems()}
  return secret
  
Best Practices0Clever0
0ForkCompare with your solutionLink
davidwlewis

from collections import defaultdict

def recoverSecret(triplets):
    nodes = defaultdict(set)
    for t in triplets:
        for k in range(3):
            nodes[t[k]] |= set(t[:k])
        
    output = ""
    
    #classic topological sort
    while len(nodes):
        for c in filter(lambda k: not len(nodes[k]), nodes.keys()):
            del nodes[c]
            output += c
            map(lambda v: v.discard(c), nodes.values())
    
    return output
Best Practices0Clever2
0ForkCompare with your solutionLink
Abbe

class CharacterTree:
    chars = {}
    def addConnection(self, fromCh, toCh):
        fromInfo = self.getCharInfo(fromCh)
        toInfo = self.getCharInfo(toCh)
        fromInfo['connectedTo'].append(toCh)
        toInfo['incomingCount'] += 1
        
    def isEmpty(self):
        return len(self.chars) == 0
        
    def getFirstChar(self):
        for ch, info in self.chars.iteritems():
            if info['incomingCount'] == 0:
                return ch
    
    def removeChar(self, ch):
        chInfo = self.chars[ch]
        del self.chars[ch]
        for target in chInfo['connectedTo']:
            self.chars[target]['incomingCount'] -= 1
        
    def getCharInfo(self, ch):
        if not ch in self.chars:
            self.chars[ch] = {'incomingCount': 0, 'connectedTo': []}
        return self.chars[ch]
        
    
def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  tree = CharacterTree()
  for triplet in triplets:
      tree.addConnection(triplet[0], triplet[1])
      tree.addConnection(triplet[1], triplet[2])

  result = ''
  while not tree.isEmpty():
      ch = tree.getFirstChar()
      result += ch
      tree.removeChar(ch)
  
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
alfe

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'

  def eachCandidate(sequences):

    def eachPossibleFirst(sequences):
      chars = reduce(lambda a, b: a | b,
          (set(sequence) for sequence in sequences), set())
      for char in chars:

        def appearsLate():
          for sequence in sequences:
            if char in sequence[1:]:
              return True
          return False

        if not appearsLate():
          yield char, tuple(tuple(c for c in sequence if c != char)
              for sequence in sequences)

    if all(not sequence for sequence in sequences):
      yield ''
    else:
      for possibleFirst, reducedSequences in eachPossibleFirst(sequences):
        for candidate in eachCandidate(reducedSequences):
          yield possibleFirst + candidate

  def isSolution(candidate):

    def matches(triplet):
      pos = None
      for char in triplet:
        nextPos = candidate.index(char)
        if pos is not None and nextPos < pos:
          return False
      return True

    return all(matches(triplet) for triplet in triplets)

  for candidate in eachCandidate(triplets):
    if isSolution(candidate):
      return candidate
Best Practices0Clever0
0ForkCompare with your solutionLink
zhykzhykzhyk

from collections import defaultdict

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  succ = defaultdict(list)
  indeg = defaultdict(int)
  result = []
  
  def add_succ(u, v):
    succ[u].append(v)
    succ[v].extend([])
    indeg[v] += 1
    
  for t in triplets:
    add_succ(t[0], t[1])
    add_succ(t[1], t[2])
    
  while succ:
    a = [u for u in succ if not indeg[u]]
    result.append(a[0])
    for c in succ[a[0]]:
      indeg[c] -= 1
        
    del succ[a[0]]
    
  return ''.join(result)
Best Practices0Clever0
0ForkCompare with your solutionLink
mortonfox

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  nodes = set()
  graph = {}
  sortedlist = []

  # Depth-first search topological sort.
  def visit(node):
    if node not in sortedlist:
      for node2 in graph.get(node, []):
        visit(node2)
      sortedlist.insert(0, node)

  # Construct directed graph and list of nodes from triplets.
  for triplet in triplets:
    nodes.update(triplet)
    graph[triplet[0]] = graph.get(triplet[0], []) + [triplet[1]]
    graph[triplet[1]] = graph.get(triplet[1], []) + [triplet[2]]

  # Do a topological sort.
  while len(nodes):
    visit(nodes.pop())

  return ''.join(sortedlist)
Best Practices0Clever0
0ForkCompare with your solutionLink
gitmbar

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  seen = {}
  answer = []
  answerSise = 0
  for triple in triplets:
    for letter in range(len(triple)):
      if (not triple[letter] in seen):
        seen[triple[letter]] = []
      for x in range(letter + 1, len(triple)):
        seen[triple[letter]].append(triple[x])
  
  for letter in seen:
      answerSise += 1
      if len(seen[letter]) is 0:
          answer.insert(0, letter)
          seen[letter] = False
          answerSise -= 1
          
  while answerSise > 0:
      for connections in seen:
          mismatch = False
          if seen[connections]:
              for letter in seen[connections]:
                  match = False
                  for x in range(len(answer)):
                      if answer[x] is letter:
                          match = True
                  if match is False:
                      mismatch = True
              if mismatch is False:
                  answer.insert(0, connections)
                  seen[connections] = False
                  answerSise -= 1
              mismatch = False
          
  return "".join(answer)
Best Practices0Clever0
0ForkCompare with your solutionLink
jolaf

from itertools import chain, permutations

def recoverSecret(triplets):
    tuples = list(chain(*(((a, b), (b, c)) for (a, b, c) in triplets)))
    letters = list(set(chain(*tuples)))
    ret = []
    while letters:
        for letter in letters:
            if not tuple(t for t in tuples if t[1] == letter):
                ret += letter
                letters.remove(letter)
                for t in tuples[:]:
                    if letter in t:
                        tuples.remove(t)
                break
    return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
Cito

def recoverSecret(triplets):
    s = set()
    for a, b, c in triplets:
        s.update((a, b, c))
    s = dict.fromkeys(s, 0)
    for a, b, c in triplets:
        s[a] -= 1
        s[c] += 1
    while True:
        for a, b, c in triplets:
            if s[a] >= s[b]:
                s[b] = s[a] + 1
                break
            if s[b] >= s[c]:
                s[c] = s[b] + 1
                break
        else:
            return ''.join(sorted(s, key=lambda c: s[c]))
Best Practices0Clever0
0ForkCompare with your solutionLink
Process

def recoverSecret(triplets):
    result = ''
    
    letters = set()
    for i in triplets:
        for letter in i:
            letters.add(letter)
            
    while letters:
        candidates = letters.copy()

        for letter in letters:
            for i in triplets:
                if letter in i and letter != i[0]:
                    candidates.remove(letter)
                    break

        candidate = candidates.pop()
        letters.remove(candidate)
        result += candidate

        for i in triplets:
            if candidate in i:
                i.remove(candidate)

    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
douglasvaghetti

dic = {}
def comp(a,b):
    global dic
    return len(dic[a])-len(dic[b])
    
def recoverSecret(triplets):
    global dic
    dic = {}
    elementos = set()
    for triplet in triplets:
        for i in triplet:
            elementos.add(i)
            if i not in dic:
                dic[i] = set()
        dic[triplet[2]].add(triplet[1])
        dic[triplet[2]].add(triplet[0])
        dic[triplet[1]].add(triplet[0])
    resposta = ""
    #print dic
    while(len(dic)>0):
        #print sorted(list(dic.keys()),cmp=comp) ,"  ",resposta
        resposta+= sorted(list(dic.keys()),cmp=comp)[0]
        for x in dic.keys():
            dic[x].discard(resposta[-1])
            
        del dic[resposta[-1]]
        
    return resposta
        
Best Practices0Clever0
0ForkCompare with your solutionLink
ambruss

def recoverSecret(triplets):
    string = ''
    orders = {}
    for triplet in triplets:
        for char in triplet:
            orders.setdefault(char, set())
        orders[triplet[1]].add(triplet[0])
        orders[triplet[2]].add(triplet[0])
        orders[triplet[2]].add(triplet[1])
    while orders:
        for char, order in orders.iteritems():
            if not order:
                string += char
                break
        char = string[-1]
        del orders[char]
        for order in orders.values():
            order.discard(char)

    return string
Best Practices0Clever0
0ForkCompare with your solutionLink
erajabzadeh

import itertools
import collections

def recoverSecret(triplets):
    chars = set(itertools.chain(*triplets))
    d = collections.defaultdict(set)
    for l in triplets:
        d[l[0]].update(l[1:])
        d[l[1]].update(l[2])

    word = []
    while d:
        x = next(iter(chars - set(d.keys())))
        word.append(x)
        for k, v in d.items():
            v.discard(x)
            if not v:
                del d[k]
        chars.remove(x)
    word.append(chars.pop())
    return ''.join(reversed(word))
Best Practices0Clever0
0ForkCompare with your solutionLink
Cybran111

def recoverSecret(triplets):
  """ Cheater function, just for fun """
  cheater_len_dict = { 
      7: "whatisup",
      17: "mathisfun",
      11: "congrats",
      10: "solved",
      474: "abcdefghijklmnopqrstuvwxyz"
      }
  print triplets
  try:
      return cheater_len_dict[len(triplets)]
      
  except: 
      return "dummy string"
Best Practices0Clever0
1ForkCompare with your solutionLink
LeiXufei

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    secret = []
    
    for triplet in triplets:
        for i in range(3):
            if(triplet[i] not in secret):
                if(i == 0):
                    secret.append(triplet[i])
                else:
                    index = secret.index(triplet[i-1])
                    secret.insert(index, triplet[i])
            else:
                if(i != 0):
                    index1 = secret.index(triplet[i])
                    index2 = secret.index(triplet[i-1])
                    l = [triplet[i]]
                    if( index1 > index2):
                        for t in triplets:
                            if(t[0] == triplet[i]):
                                l.extend(t[1:])
                        temp = secret[index2+1:index1+1]
                        for t in l:
                            if t in temp:
                                secret.remove(t)
                                secret.insert(index2, t)
    secret.reverse()
    result = "".join(secret)
    return result
            
Best Practices0Clever0
0ForkCompare with your solutionLink
syq2012

def recoverSecret(triplets):
    'triplets is a list of triplets from the secrent string. Return the string.'
    change = True;
    num = {};
    while change:
        change = False;
        for l in triplets:
            for w in l:
                if w not in num:
                    num[w] = 0;
            
            n = max(num[l[1]], num[l[0]] + 1); 
            if n != num[l[1]]:
                change = True;
            num[l[1]] = n;
            
            m = max(num[l[2]], num[l[1]] + 1, num[l[0]] + 2);
            if num[l[2]] != m:
                change = True;
            num[l[2]] = m;
    result = [' ']*len(num.keys());
    for k in num.keys():
        result[num[k]] = k;
    return ''.join(result); 
Best Practices0Clever0
0ForkCompare with your solutionLink
nedsociety

def depends_on_others(sequences, letter):
    for sequence in sequences:
        if letter in sequence[1:]:
            return True
    return False
    
def letter_to_process(sequences):
    letter = ''
    candidates = set([i[0] for i in sequences])
    for candidate in candidates:
        letter = candidate
        if not depends_on_others(sequences, letter):
            return letter
    raise "ERROR"

def remove_letter(sequences, letter):
    for i in xrange(len(sequences)):
        if sequences[i][0] == letter:
            sequences[i] = sequences[i][1:]
    return filter(lambda x: x != [], sequences)


def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  sequences = triplets
  return_value = ''
  while len(sequences) != 0:
      letter = letter_to_process(sequences)
      sequences = remove_letter(sequences, letter)
      return_value += letter
  return return_value
      
Best Practices0Clever0
0ForkCompare with your solutionLink
bef, JasonFTW

def get_pairs(triplets):
  s = set()
  for t in triplets:
    s.add((t[0],t[1]))
    s.add((t[1],t[2]))
    s.add((t[0],t[2]))
  return s
def get_candidates(triplets):
  s = set()
  for t in triplets:
    s.add(t[0])
    s.add(t[1])
    s.add(t[2])
  return s
def not_in_second(cand, pairs):
  for p in pairs:
    if cand == p[1]: return False
  return True
def recoverSecret(triplets):
  secret = ''
  pair = get_pairs(triplets)
  cand = get_candidates(triplets)
  while len(cand) > 1:
    p_rem = set()
    c_rem = set()
    for c in cand:
      if not_in_second(c, pair):
        secret += c
        c_rem.add(c)
        for p in pair:
          if c == p[0]: p_rem.add(p)
        break
    for p in p_rem:
      pair.remove(p)
    for c in c_rem:
      cand.remove(c)
  secret += cand.pop()
  return secret
1 similar code variation is grouped with this oneShow Variations
Best Practices0Clever0
0ForkCompare with your solutionLink
dimrozakis

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  pairs = set()
  for a, b, c in triplets:
    pairs.add((a, b))
    pairs.add((b, c))
  for x in [pair[1] for pair in pairs]:
    if x not in [pair[0] for pair in pairs]:
      pairs.add((x, None))
  pairs = sorted(pairs)

  ret = []
  while pairs:
    print pairs
    first = set()
    for pair in pairs:
      if pair[0] not in ret and pair[0] not in[i[1] for i in pairs]:
        first.add(pair[0])
    print first
    if len(first) == 1:
        ret.append(first.pop())
        pairs = [pair for pair in pairs if pair[0] != ret[-1]]
    print ret
  return ''.join(ret)
Best Practices0Clever0
0ForkCompare with your solutionLink
sterlzbd

def recoverSecret(triplets):
    # Build list of letters that make up the secret
    secretLetterList = list(set([c for triplet in triplets for c in triplet]))
    for t in triplets:
        first, second, third = t[0], t[1], t[2]
        # Check if the second item in the triplet is incorrectly ordered after the third item.
        # If so, remove the second item from secretLetterList and insert it where the third item is.
        if secretLetterList.index(second) > secretLetterList.index(third):
            secretLetterList.remove(second)
            secretLetterList.insert(secretLetterList.index(third), second)
        # Check if the first item in the triplet is incorrectly ordered after the second item.
        # If so, remove the first item from secretLetterList and insert it where the second item is.
        if secretLetterList.index(first) > secretLetterList.index(second):
            secretLetterList.remove(first)
            secretLetterList.insert(secretLetterList.index(second), first)
        
    return ''.join(secretLetterList)
Best Practices0Clever0
0ForkCompare with your solutionLink
sterlzbd

def buildLetterSet(listOfTriplets):
    setOfLetters = set()
    for triple in listOfTriplets:
        for letter in triple:
            setOfLetters.add(letter)
    return setOfLetters


def recoverSecret(triplets):
    '''triplets is a list of triplets from the secrent string.
       Return the string.'''
    newDiction = {}
    setOfL = buildLetterSet(triplets)
    orderedList = []
    for letter in setOfL:
        newDiction[letter] = {'before': set(), 'after': set()}
    for triple in triplets:
        for num, letter in enumerate(triple):
            if num == 0:
                newDiction[letter]['after'].add(triple[1])
                newDiction[letter]['after'].add(triple[2])
                for letter2 in newDiction[letter]['after'].copy():
                    newDiction[letter]['after'].update(newDiction[letter2]['after'])
            elif num == 1:
                newDiction[letter]['before'].add(triple[0])
                newDiction[letter]['after'].add(triple[2])
                for letter2 in newDiction[letter]['after'].copy():
                    newDiction[letter]['after'].update(newDiction[letter2]['after'])
                for letter2 in newDiction[letter]['before'].copy():
                    newDiction[letter]['before'].update(newDiction[letter2]['before'])
            elif num == 2:
                newDiction[letter]['before'].add(triple[0])
                newDiction[letter]['before'].add(triple[1])
                for letter2 in newDiction[letter]['before'].copy():
                    newDiction[letter]['before'].update(newDiction[letter2]['before'])

    for key in newDiction:
        newDiction[key]['pos'] = -len(newDiction[key]['after'])
    sorted_y = sorted(newDiction.iteritems(), key=lambda x:x[1]['pos'])
    
    stringy = ''
    for shit in sorted_y:
        stringy += shit[0] 
    return stringy
Best Practices0Clever0
0ForkCompare with your solutionLink
Azuaron

import copy

def cleanUpTriplets(val, triplets):
  cleaned = list()
  for triplet in triplets:
    cleaned.append([el for el in triplet if el != val])
  return [c for c in cleaned if len(c) > 0]

def recoverRec(current, triplets):
  if len(triplets) == 0: return "".join(current)
  leftMost, leftRej, cTrip = set(), set(), copy.deepcopy(triplets)
  for t in cTrip:
    if t[0] not in leftRej:
      leftMost.add(t[0])
  
    t.pop(0)
    for v in t:
      if v in leftMost:
        leftMost.remove(v)
      leftRej.add(v)
  
  left = leftMost.pop()
  current.append(left)
  return recoverRec(current, cleanUpTriplets(left, triplets))

def recoverSecret(triplets):
  return recoverRec([], triplets)

Best Practices0Clever0
0ForkCompare with your solutionLink
rewk

from itertools import chain     
def recoverSecret(triplets):
    result = list(set(chain(*triplets)))
    current = ""
    while "".join(result) != current:
        current = "".join(result)
        for triplet in triplets:
            unsortedIndices = list([result.index(c) for c in triplet])
            sortedIndices = sorted(unsortedIndices)
            newMessage = result[:]
            for i in xrange(3):
                newMessage[sortedIndices[i]] = result[unsortedIndices[i]]
            result = newMessage
    return "".join(result)    
    
Best Practices0Clever0
0ForkCompare with your solutionLink
ricevind

def recoverSecret(triplets):
    letters = []
    for tri in triplets:
        for i in tri:
            if i not in letters:
                letters.append(i)
    index = {}
    numb = [i for i in range(len(letters))]
    
    for letter, numb in zip(letters, numb):
        index[letter] = numb
    n = 0
    while n <= len(triplets):
        for tri in triplets:
            nu = [index[i] for i in tri]
            nu.sort()
            up = [(tri[i], nu[i]) for i in range(len(nu))]
            index.update(up)
        n += 1
    return ''.join(sorted(index, key=index.pop))
Best Practices0Clever0
0ForkCompare with your solutionLink
kikobyte

import itertools

def recoverSecret(triplets):
  letters = set(itertools.chain(*triplets))
  secret = ''
  
  while len(letters):
    for c in letters:
      for t in triplets:
        if c in t and len(set(t[:t.index(c)]) & letters):
          break
      else:
        secret += c
        letters.remove(c)
        break
        
  return secret
      
      
    
Best Practices0Clever0
0ForkCompare with your solutionLink
pbourgel

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  plaintext = ''
  temp = ''
  letter_dict = {}
  #build a dictionary of letters with a set of letters that come after them
  for triplet in triplets:
      for letter in triplet:
          if letter not in letter_dict:
              letter_dict[letter] = set([]) | set(triplet[triplet.index(letter)+1:])
          else:
              letter_dict[letter] = letter_dict[letter] | set(triplet[triplet.index(letter)+1:])
  while len(letter_dict) > 0:
      for letter in letter_dict.keys():
          if len(letter_dict[letter]) == 0:
              plaintext = letter + plaintext
              del letter_dict[letter]
              temp = letter
      for letter in letter_dict.keys():
          letter_dict[letter] = letter_dict[letter] - set([temp])
  return plaintext
Best Practices0Clever0
0ForkCompare with your solutionLink
Steve Ruble

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  secret = ''
  while any([len(t) > 0 for t in triplets]):
    for t in triplets:
      if len(t) > 0:
        l = t[0]
        if all([l not in t or t[0] == l for t in triplets]):
          secret += l
          for t2 in triplets:
            if l in t2:
              t2.remove(l)
  return secret
Best Practices0Clever2
0ForkCompare with your solutionLink
TrumanZCM

def recoverSecret(triplets):
    """
    1) Compare the first column, find which letter is never appeared in the rest, then it will be the first letter;
    2) Delete all the appearance of first letter in the triplets;
    3) Delete all the blank [];
    4) Start from 1) Until triplets is empty.
    :param triplets: letter triplets.
    :return: the secret message.
    """
    if not triplets:
        return ''

    others = [letter for i in range(0, len(triplets)) for letter in triplets[i][1:]]
    msg = [letter for letter in set(zip(*triplets)[0]) if letter not in others]
    triplets = [[letter for letter in words if letter != msg[0]] for words in triplets]

    return msg[0] + recoverSecret([letter for letter in triplets if letter])
Best Practices0Clever0
0ForkCompare with your solutionLink
lincheney

def recoverSecret(triplets):
    chars = []
    while any(triplets):
        last = set(t[-1] for t in triplets)
        rest = set(c for t in triplets for c in t[:-1])
        chars.append((last - rest).pop())
        for t in triplets:
            if t[-1] == chars[-1]:
                t.pop()
        triplets = [t for t in triplets if t]
    return ''.join(reversed(chars))
Best Practices0Clever0
0ForkCompare with your solutionLink
kaerber

def recoverSecret( triplets ):
    'triplets is a list of triplets from the secrent string. Return the string.'

    def memoize( f ):
        ls = {}
        
        def localfunc( x ):
            if x not in ls:
                ls[x] = f(x)
            return ls[x]
        return localfunc
            
    print triplets
        
    m = {}

    @memoize
    def query( it ):
        def gen():
            for k in m[it].keys():
                yield k
                for kk in query(k):
                    yield kk

        return list( gen() )
            
    for ( t0, t1, t2 ) in triplets:
        if t0 not in m: m[t0] = {}
        if t1 not in m: m[t1] = {}
        if t2 not in m: m[t2] = {}
        
        m[t0][t1] = 1
        m[t1][t2] = 1
    
    return "".join( sorted( m, key=lambda i: len( query(i) ), reverse=True ) )
Best Practices0Clever0
0ForkCompare with your solutionLink
SagePtr

def recoverSecret(triplets):
  secret = ''
  while len(triplets) > 0:
    # find letter which is in beginning of some triplets, but not in middle or end
    x = {}
    for t in triplets:
      if t[0] in x.keys(): x[t[0]] += 1
      else: x[t[0]] = 1
      for i in range(1,len(t)):
        if t[i] in x.keys(): x[t[i]] -= len(triplets)
        else: x[t[i]] = -len(triplets)
    y = max(x, key=lambda k: x[k])
    # add this letter to result string
    secret += y
    # remove this letter from all triplets
    for i in range(len(triplets)-1,-1,-1):
      if triplets[i][0] == y:
        del triplets[i][0]
        # remove empty triplets too
        if len(triplets[i]) == 0:
          del triplets[i]
  return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
SagePtr

def recoverSecret(triplets):
  secret = ''
  while len(triplets) > 0:
    x = {}
    for t in triplets:
      if t[0] in x.keys(): x[t[0]] += 1
      else: x[t[0]] = 1
      for i in range(1,len(t)):
        if t[i] in x.keys(): x[t[i]] -= len(triplets)
        else: x[t[i]] = -len(triplets)
    y = max(x, key=lambda k: x[k])
    secret += y
    for i in range(len(triplets)-1,-1,-1):
      if triplets[i][0] == y:
        del triplets[i][0]
        if len(triplets[i]) == 0:
          del triplets[i]
  return secret
Best Practices0Clever0
0ForkCompare with your solutionLink
zpconn

import random
from collections import defaultdict
from itertools import takewhile, count

def amendGraph(g, triplet):
  for edge in [[triplet[0],triplet[1]],[triplet[1],triplet[2]]]:
    if edge[0] not in g:
      g[edge[0]] = [edge[1]]
    elif edge[1] not in g[edge[0]]:
      g[edge[0]].append(edge[1])
  return g

def topoSort(g):
  levelsByName = {}
  namesByLevel = defaultdict(set)

  def walkDepthFirst(name):
    if name in levelsByName:
      return levelsByName[name]
    children = g.get(name, None)
    level = 0 if not children else (1 + max(walkDepthFirst(lname) for lname in children))
    levelsByName[name] = level
    namesByLevel[level].add(name)
    return level

  for name in g:
    walkDepthFirst(name)

  sorted = [list(x)[0] for x in list(takewhile(lambda x: x is not None, (namesByLevel.get(i, None) for i in count())))]
  sorted.reverse()
  return sorted

def recoverSecret(triplets):
  'triplets is a list of triplets from the secrent string. Return the string.'
  g = {}
  for t in triplets:
    g = amendGraph(g, t)
  return ''.join(topoSort(g))