import re

#
# There's probably simpler ways to do this, but I thought this would be a cool
# way for me to learn about how to make a lexer and parser from scratch.
#

class Token(object):
    def __init__(self, tag, value):
        self.tag = tag
        self.value = value
        
    def __repr__(self):
        return "Token({}, {})".format(self.tag, self.value)
    
    def __str__(self):
        return "{}: {}".format(self.tag, self.value)

class ChemicalLexer(object):
    TOKEN_TYPES = [
        (r'[A-Z][a-z]?', 'ELEMENT'),
        (r'[0-9]+',      'QUANTITY'),
        (r'\[|\(|\{',    'LEFT_GROUPING'),
        (r'\]|\)|\}',    'RIGHT_GROUPING'),
    ]
    def __init__(self, formula):
        self.formula = formula
        self.pos = 0
        self.token_types = [(re.compile(pattern), tag) for pattern, tag in self.TOKEN_TYPES]
    
    def token_gen(self):
        while self.pos < len(self.formula):
            error = True
            for regex, tag in self.token_types:
                match = regex.match(self.formula, self.pos)
                if match:
                    error = False
                    yield Token(tag, match.group(0))
                    self.pos = match.end(0)
                    break
                else:
                    continue
            if error:
                raise Exception("Syntax Error")


def add_dicts(dict1, dict2):
    totals = {}
    for key in dict1:
        totals.setdefault(key, 0)
        totals[key] += dict1[key]
    for key in dict2:
        totals.setdefault(key, 0)
        totals[key] += dict2[key]
    return totals

def scale_dict(d, scalar):
    return {k: scalar * v for k, v in d.items()}

class ElementNode(object):
    def __init__(self, element):
        self.type = 'element'
        self.element = element
        self.quantity = 1
        
    def __str__(self):
        num = '' if self.quantity == 1 else self.quantity
        return "{}{}".format(self.element, num)
        
class GroupingNode(object):
    def __init__(self, symbol = ''):
        self.type = 'grouping'
        self.symbol = symbol
        self.quantity = 1
        self.children = []
    
    def add(self, element):
        self.children.append(element)
        
    def last(self):
        try:
            return self.children[-1]
        except IndexError:
            return None
    
    def add_quantity(self, quantity):
        self.children[-1].quantity = quantity
    
    def closing_symbol(self):
        if self.symbol == '':
            return ''
        if self.symbol == '(':
            return ')'
        if self.symbol == '[':
            return ']'
        if self.symbol == '{':
            return '}'
    
    def get_atoms_dict(self):
        atoms = {}
        for child in self.children:
            if child.type == 'element':
                atoms.setdefault(child.element, 0)
                atoms[child.element] += child.quantity * self.quantity
            elif child.type == 'grouping':
                child_atoms = child.get_atoms_dict()
                atoms = add_dicts(atoms, scale_dict(child_atoms, self.quantity))
        return atoms                
    
    def __str__(self):
        num = '' if self.quantity == 1 else self.quantity
        return "{}{}{}{}".format(self.symbol, ''.join(str(child) for child in self.children), self.closing_symbol(), num)


class ChemicalParser(object):
    def __init__(self, formula):
        self.lexer = ChemicalLexer(formula)
        self.formula = GroupingNode()
        self.group_stack = []
    
    def current_group(self):
        try:
            return self.group_stack[-1]
        except IndexError:
            return self.formula
        
    def element(self, token):
        node = ElementNode(token.value)
        group = self.current_group()
        group.add(node)
    
    def quantity(self, token):
        node = self.current_group().last()
        if node:
            node.quantity = int(token.value)
        else:
            raise Exception("Missing Atom before quantifier {}".format(token.value))
    
    def left_grouping(self, token):
        node = GroupingNode(token.value)
        self.group_stack.append(node)
    
    def right_grouping(self, token):
        group = self.current_group()
        if group.closing_symbol() == token.value:
            node = self.group_stack.pop()
            group = self.current_group()
            group.add(node)
        else:
            raise Exception("Missing Grouping Symbol {}".format(group.closing_symbol()))
    
    def parse(self):
        for token in self.lexer.token_gen():
            if token.tag == 'ELEMENT':
                self.element(token)
            elif token.tag == 'QUANTITY':
                self.quantity(token)
            elif token.tag == 'LEFT_GROUPING':
                self.left_grouping(token)
            elif token.tag == 'RIGHT_GROUPING':
                self.right_grouping(token)
            else:
                raise Exception("Invalid Token!")
        if self.group_stack:
            raise Exception("Missing Grouping Symbol {}".format(self.current_group().closing_symbol()))
        return self.formula.get_atoms_dict()


def parse_molecule (formula):
    parser = ChemicalParser(formula)
    return parser.parse()
Best Practices2Clever0
0ForkCompare with your solutionLink
GodMode-On

from string import digits

def count_nums(text, position):
    '''
    Returns how many digits in a row in text, starting from pos.
    '''
    
    if not text[position].isdigit():
        return False
    count = 0
    while text[position].isdigit():
        count += 1
        position += 1
        if position == len(text):
            return count
    return count
    
    
def get_rid_of_brackets(molecule):
    '''
    Something like that:
    K4[ON(SO3)2]2 -> K4ONSO3SO3ONSO3SO3
    '''
    brackets = {'(' : ')',
                '[' : ']',
                '{' : '}'}
                
    while any(bracket in molecule for bracket in brackets.keys()):
        for i in range(len(molecule)-1, -1, -1):
            if molecule[i] in brackets.values():
                for j, element in list(enumerate(molecule))[::-1]:
                    if element in brackets.keys():
                        if brackets[element] == molecule[i]:
                            start = molecule[:j]
                            in_brackets = molecule[j+1:i]
                            number_len = count_nums(molecule, i+1)
                            if number_len:
                                times = int(molecule[i+1:i+number_len+1])
                            else:
                                times = 1
                            end = molecule[i+number_len+1:]
                            break
                molecule = start + in_brackets * times + end
                break
    return molecule
    
def molecule_to_atoms(molecule):
    '''
    Something like that:
    H2SO3 -> ['H2', 'S', 'O3']
    '''
    
    molecule_without_brackets = get_rid_of_brackets(molecule)
    molecule_split = ''
    for element in molecule_without_brackets:
        if element.isupper():
            molecule_split += ' ' + element
        else:
            molecule_split += element           
    return molecule_split.lstrip().split()
    
def parse_molecule(molecule):
    '''
    Returns number of atoms of each element contained in the molecule
    '''
    
    atom_list = molecule_to_atoms(molecule)
    
    result = dict()
    for element in atom_list:
        if any(digit in element for digit in digits):
            if element[1].isdigit():
                atom = element[0]
                count = element[1:]
                
            else:
                atom = element[:2]
                count = element[2:]
        else:
                atom = element
                count = 1
        if atom in result.keys():
            result[atom] += int(count)
        else:
            result[atom] = int(count)
    return result
Best Practices2Clever0
0ForkCompare with your solutionLink
lincheney

import re

def parse_group(tokens, counts, scale=1):
    _scale = scale
    for t in tokens:
        if t in '])}':
            parse_group(tokens, counts, _scale)
        elif t in '([{':
            break
        elif t.isdigit():
            _scale = scale * int(t)
            continue
        elif t.isalpha():
            counts[t] = counts.get(t, 0) + _scale
        _scale = scale
    return counts

def parse_molecule (formula):
    tokens = re.findall(r'[A-Z][a-z]?|[()\[\]{}]|\d+', formula)
    return parse_group(iter(reversed(tokens)), {})
Best Practices1Clever3
0ForkCompare with your solutionLink
zellerede

import re
from collections import Counter

parenth = re.compile(r'(\(.*?\)|\[.*?\]|\{.*?\})(\d*)')
atom = re.compile(r'([A-Z][a-z]*)(\d*)')
as_number = lambda s: int(s) if s else 1

def parse_molecule (formula):
    while True:
        m = parenth.search(formula)
        if not m:
            break
        expr, num = m.groups()
        expr = expr[1:-1]
        num = as_number(num)
        formula = parenth.sub(expr*num, formula, count=1)
    my_atoms = Counter()
    while True:
        m = atom.search(formula)
        if not m:
            break
        at, num = m.groups()
        num = as_number(num)
        my_atoms[at] += num
        formula = atom.sub('', formula, count=1)
    return my_atoms
    
Best Practices1Clever0
0ForkCompare with your solutionLink
rennat

from collections import Counter
import re


class MathCounter(Counter):
    
    def __mul__(self, operand):
        result = self.__class__()
        for key, value in self.iteritems():
            result[key] = value * operand
        return result


def iter_atoms (formula):
    for m in re.finditer(r'([A-Z][a-z]?)(\d*)', formula):
        element, count = m.groups()
        count = int(count) if count else 1
        for i in xrange(count):
            yield element


def parse_molecule (formula, multiplier=1):
    count = MathCounter()
    for m in re.finditer(r'(\[[^\]]+\]|\([^)]+\)|\{[^}]+\})(\d+?)|(\w+)', formula):
        group, group_multiplier, remainder = m.groups()
        if group:
            group_multiplier = int(group_multiplier) if group_multiplier else 1
            count.update(parse_molecule(group, group_multiplier))
        if remainder:
            count.update(iter_atoms(remainder))
    if multiplier > 1:
        count *= multiplier
    return count
Best Practices1Clever1
0ForkCompare with your solutionLink
SleepingCode

import re
def parse_molecule(form):
    form=form.replace('[','(').replace(']',')').replace('{','(').replace('}',')')
    d={}
    molt=1
    bracket_count=0
    string_count=1
    m=set(re.findall('[A-Z][a-z]*', form))
    for el in m: d[el]=0
    while(form!=''):
        m=re.match('[A-Z][a-z]*', form)
        if(m!=None):
            k=m.group(0)
            form=re.sub(k, '', form,1)
            n=re.match('[0-9]*', form)
            form=re.sub('[0-9]*','',form,1)
            d[k]+=molt*(1 if n==None or n.group(0)=='' else int(n.group(0)))
        elif(form[0] =='('):
            while(bracket_count<1):
                fsc=form[string_count]
                bracket_count+=1 if fsc==')' else -1 if fsc=='(' else 0
                string_count+=1
            n=re.match('[0-9]*',form[string_count:])
            molt*=1 if n==None or n.group(0)=='' else int(n.group(0))
            form=form[1:]
            bracket_count=0
            string_count=1
        else:
            form=form[1:]
            n=re.match('[0-9]*',form)
            molt/=(1 if n==None or n.group(0)=='' else int(n.group(0)))
            form=re.sub('[0-9]*', '', form, 1)
    return d
Best Practices1Clever0
0ForkCompare with your solutionLink
leonoverweel

from re import findall, match

def expand(formula):
    parts = findall("(\(.*?\)|\[.*?\]|\{.*?\}|[A-Z][a-z]*)([0-9]*)", formula)
    for i in range(0, len(parts)):
        part = parts[i]
        if not match("[A-Z][a-z]*", part[0]):
            part = (expand(part[0][1:-1]), part[1])
        if part[1] == "":
            parts[i] = (part[0], 1)
        else:
            parts[i] = (part[0], int(part[1]))
    return parts
    
def collapse(array, multiple):
    result = []
    for element in array:
        if isinstance(element[0], list):
            result += collapse(element[0], element[1] * multiple)
        else:
            result.append((element[0], element[1] * multiple))
    return result

def parse_molecule(formula):
    collapsed = collapse(expand(formula), 1)
    result = {}
    for element in collapsed:
        if element[0] in result:
            result[element[0]] += element[1]
        else:
            result[element[0]] = element[1]
    return result
Best Practices1Clever0
0ForkCompare with your solutionLink
anter69

import re, collections

def parse_molecule(formula):
    while True:
        m = re.search("[\[({](\w+)[\])}](\d+)", formula)
        if not m:
            break
        formula = re.sub(re.escape(m.group(0)), m.group(1) * int(m.group(2)), formula)
    
    while True:
        m = re.search("([A-Z][a-z]?)(\d+)", formula)
        if not m:
            break
        formula = re.sub(m.group(0), m.group(1) * int(m.group(2)), formula)
    
    return collections.Counter(re.findall("[A-Z][a-z]?", formula))
Best Practices1Clever1
0ForkCompare with your solutionLink
stranac

from collections import Counter
import re

COMPONENT_RE = (
    r'('
        r'[A-Z][a-z]?'
        r'|'
        r'\([^(]+\)'
        r'|'
        r'\[[^[]+\]'
        r'|'
        r'\{[^}]+\}'
    r')'
    r'(\d*)'
)


def parse_molecule(formula):
    counts = Counter()
    for element, count in re.findall(COMPONENT_RE, formula):
        count = int(count) if count else 1
        if element[0] in '([{':
            for k, v in parse_molecule(element[1:-1]).items():
                counts[k] += count * v
        else:
            counts[element] += count
    return counts
Best Practices1Clever0
0ForkCompare with your solutionLink
russh

import re
import string

def parse_molecule (formula):
    """
    universalizes all brackets and processes all molecular groups
    """
    d = {}
    elements = []
    final = []
    numbers = string.digits
    closer, opener = ')', '('

    for item in formula:
        if item in ['[', '{']:
            formula = formula.replace(item, '(')
        elif item in [']', '}']:
            formula = formula.replace(item, ')')

    new = re.split(r'([A-Z][a-z]*\d*)', formula)
    for index, item in enumerate(new):
        if any(char == closer for char in item):
            b = item
            new.pop(index)
            for a in b[::-1]:
                new.insert(index, a)

    multipliers = [1]
    for index, value in enumerate(new[::-1]):
        if value.isdigit():
            multipliers.append(int(value))
        elif value == opener:
            multipliers.pop()
        elif any(x in [opener, closer] for x in value) != True and value != '':
            elements.extend([value]*multiplier(multipliers))

    for item in elements:
        if any(char.isdigit() for char in item):
            final.extend(parser(item, numbers))
        else:
            final.append(item)

    for item in final:
        if item not in d:
            d[item] = final.count(item)
    return d


def parser(x, numbers):
    """
    parses single terms of multiple atoms of the same type. ie: 'K4' -> ['K','K','K','K']
    """
    if any(char.isdigit() for char in x):
        factor = 1
        atom = ''
        for index, char in enumerate(x):
            if char not in numbers:
                atom += char
                x = x.replace(char, '')
        factor *= int(x)
        return [atom] * factor
    else:
        return x


def multiplier(multipliers):
    return int(reduce(lambda x,y: x*y, multipliers)) if multipliers else 1
Best Practices1Clever0
0ForkCompare with your solutionLink
tchar

import re

def parse_molecule (formula):
    
    _dict = {}
    _regex = {'braces': '\{(.*?)\}(\d*)', 'brackets': '\[(.*?)\](\d*)', 
             'parentheses': '\((.*?)\)(\d*)', 'simple':'([A-Z][a-z]?)(\d*)'}
    
    def _assign_molecules(molecules):
        for molecule, num in molecules:
            try: _dict[molecule] += num
            except KeyError: _dict[molecule] = num
    
    
    def _process_formula(formulas):
        formula, mul = formulas.pop()
        
        for key in ['braces', 'brackets', 'parentheses']:
            findall = re.findall(_regex[key], formula)
            formulas += [(a, mul*int(b)) if b.isdigit() else (a, mul) for a, b in findall]
            formula = re.sub(_regex[key], '', formula)
    
        findall = re.findall(_regex['simple'], formula)
        molecules = [(a, mul*int(b)) if b.isdigit() else (a, mul) for a, b in findall]
        _assign_molecules(molecules)        
    
    formulas = [(formula, 1)]
    
    while formulas:
        _process_formula(formulas)

    return _dict
Best Practices1Clever0
0ForkCompare with your solutionLink
seanpquig

import re

element_regex = re.compile('[A-Z][a-z]?')
bracket_l_regex = re.compile('[\(\[\{]')
bracket_r_regex = re.compile('[\)\]\}]')

def matches(string, regex):
    return [(i.group(), i.start()) for i in regex.finditer(string)]
    
def group_brackets(formula):
    level = 0
    i_l = bracket_l_regex.search(formula).start()
    for i, c in enumerate(formula[i_l+1:]):
        if bracket_r_regex.match(c):
            if level == 0:
                return i_l, i_l + 1 + i
            else:
                level -= 1
        elif bracket_l_regex.match(c):
            level += 1

def parse_sub_molecule(formula, count_object, factor=1):
    elements = matches(formula, element_regex)
    left_brackets = matches(formula, bracket_l_regex)
    right_brackets = matches(formula, bracket_r_regex)
    
    if not count_object:
        for e, i in elements:
            count_object[e] = 0
    
    if not left_brackets:
        for elem, i in elements:
            if len(elem) == 1:
                pad = 1
            else:
                pad = 2
            if i + pad < len(formula) and formula[i+pad].isdigit():
                j = max(filter(lambda x: formula[i+pad:x].isdigit(),
                               xrange(len(formula), i+pad, -1)))
                count_object[elem] += int(formula[i+pad:j]) * factor
            else:
                count_object[elem] += factor
    else:
        i_l, i_r = group_brackets(formula)
        parse_sub_molecule(formula[:i_l], count_object, factor)
        parse_sub_molecule(formula[i_r+1:], count_object, factor)
        sub_formula = formula[i_l+1:i_r]
        if formula[i_r+1].isdigit():
            j = max(filter(lambda x: formula[i_r+1:x].isdigit(),
                           xrange(len(formula), i_r+1, -1)))
            factor *= int(formula[i_r+1:j])
        parse_sub_molecule(sub_formula, count_object, factor)
    
def parse_molecule(formula):
    count_object = {}
    parse_sub_molecule(formula, count_object)
    return count_object
        
Best Practices0Clever0
0ForkCompare with your solutionLink
neilbezdek

import string
def parse_molecule(formula):
    ans = {}
    fList = list(formula)
    digits = ['0','1','2','3','4','5','6','7','8','9']
    numbers = list()
    #create dictionary with each atom
    for x in range(len(formula)):
        if fList[x] in string.uppercase:
            try:
                if fList[x+1] in string.lowercase:
                    fList[x] = str(fList[x]) + str(fList[x+1])
                    fList[x+1] = '!'
            except:
                pass
            ans[fList[x]] = 0        
        if fList[x] in digits:
            loc = x+1
            try:
                while fList[loc] in digits:
                    fList[x] = str(fList[x]) + str(fList[loc])
                    fList[loc] = '!'
                    loc += 1
            except:
                pass
            numbers.append(fList[x])
    while '!' in fList:
        fList.remove('!')
    listCopy = list()
    for a in fList:
        listCopy.append(1)
    
    #look for numbers, and then move backward increasing the number of each atom
    openPar = ['(','[','{']
    closePar = [')',']','}']
    for x in range(len(fList)):
        pos = x-1
        openCount = 0
        closeCount = 0
        if fList[x] in numbers:
            exp = int(fList[x])
            if fList[pos] in ans:
                listCopy[pos] *= exp
            if fList[pos] in closePar:
                closeCount = 1
            while openCount != closeCount:
                pos -=1
                if fList[pos] in openPar:
                    openCount += 1
                if fList[pos] in closePar:
                    closeCount +=1
                if fList[pos] in ans:
                    listCopy[pos] *= exp
    for b in range(len(fList)):
        if fList[b] in ans:
            ans[fList[b]] += listCopy[b]
    return ans
Best Practices0Clever0
0ForkCompare with your solutionLink
dimitr

import re

def dline(line, mply): # ''Ca(NO3)2 -> line = 'NO3', mply = 2
  a = re.findall("([A-Z][a-z]*)(\d*)", line)
  new_line = ''
  for name, num in a:
    new_line += name
    new_line += str(int(num) * mply) if num != '' else str(mply)
  return new_line

def pre(line): # make all brackets round
  new_line = ''
  for i in line:
    if i in {'{', '['}:
      new_line += '('
    elif i in {']', '}'}:
      new_line += ')'
    else:
      new_line += i
  return new_line

def doer(line, mply):
  left = 0
  while left != len(line):
    if line[left] == '(':
      openbr = 1
      right = left
      while openbr != 0:
        right += 1
        if line[right] == '(': openbr += 1;
        if line[right] == ')': openbr -= 1;
      num, tmp_right = '', right + 1
      while tmp_right < len(line) and line[tmp_right].isdigit():
        num += line[tmp_right]
        tmp_right += 1
      num = int(num)if num != '' else 1
      afterline = line[tmp_right:] if tmp_right != len(line) else ''
      line = line[:left] + doer(line[left + 1 : right], num) + doer(afterline, 1)
      return dline(line, mply)
    left += 1
  return dline(line, mply)

def last(line):
  a = re.findall(r'([A-Z][a-z]*)(\d*)', line)
  b = {}
  for name, num in a:
    if name in b.keys():
      b[name] += int(num)
    else:
      b[name] = int(num)
  return b

parse_molecule = lambda line: last(doer(pre(line), 1)) 
Best Practices0Clever0
0ForkCompare with your solutionLink
dimitr

import re

def dline(line, mply): # ''Ca(NO3)2 -> line = 'NO3', mply = 2
  a = re.findall("([A-Z][a-z]*)(\d*)", line)
  new_line = ''
  for name, num in a:
    new_line += name
    new_line += str(int(num) * mply) if num != '' else str(mply)
  return new_line

def pre(line):
  new_line = ''
  for i in line:
    if i in {'{', '['}:
      new_line += '('
    elif i in {']', '}'}:
      new_line += ')'
    else:
      new_line += i
  return new_line

def bractor(Line):
  Line = pre(Line)
  def doer(line, mply):
    left = 0
    while left != len(line):
      if line[left] == '(':
        openbr = 1
        right = left
        while openbr != 0:
          right += 1
          if line[right] == '(': openbr += 1;
          if line[right] == ')': openbr -= 1;
        num, tmp_right = '', right + 1
        while tmp_right < len(line) and line[tmp_right].isdigit():
          num += line[tmp_right]
          tmp_right += 1
        num = int(num)if num != '' else 1
        afterline = line[tmp_right:] if tmp_right != len(line) else ''
        line = line[:left] + doer(line[left + 1 : right], num) + doer(afterline, 1)
        return dline(line, mply)
      left += 1
    return dline(line, mply)
  return doer(Line, 1)

def last(line):
  a = re.findall(r'([A-Z][a-z]*)(\d*)', line)
  b = {}
  for name, num in a:
    if name in b.keys():
      b[name] += int(num)
    else:
      b[name] = int(num)
  return b

parse_molecule = lambda line: last(bractor(line)) 
Best Practices0Clever0
0ForkCompare with your solutionLink
viktor-goba

def parse_molecule (formula):
  open = '({['
  close = ')}]'

  for brace in range(0,3):
    while open[brace] in formula:
      lpart, null, rest = formula.rpartition(open[brace])
      cpart, null, rpart = rest.partition(close[brace])
      if rpart[0].isdigit():
        cpart *= int(rpart[:len(rpart)-len(rpart.lstrip('1234567890'))])
        rpart = rpart.lstrip('1234567890')
      formula = lpart + cpart + rpart
    
  atoms = []
  imax = len(formula) - 1
  for i in range(imax, 0, -1):
    if formula[i].isupper():
      atoms.append(formula[i:])
      formula = formula[:i]
  atoms.append(formula)
    
  out = {}
  for item in atoms:
    if item[-1].isdigit():
      n = int(item[len(item.rstrip('1234567890')):])
      item = item.rstrip('1234567890')
    else:
      n = 1
    if item in out:
      out[item] += n
    else:
      out[item] = n
 
  return out  
Best Practices0Clever0
0ForkCompare with your solutionLink
ddrouin

from collections import Counter

def parse_molecule (formula):
    stack = []
    atom = factor = ""
    formula = formula.replace("{", "(").replace("}", ")").replace("[", "(").replace("]", ")")
    last = len(formula) - 1
    for i, ch in enumerate(formula):
        if ch.isdigit():
            factor += ch
            if i < last:
                continue
        if factor:
            factor = int(factor)  
            if atom:
                prev = atom
                atom = ""
            else:
                prev = stack.pop()
            if prev == ")":
                atoms = []
                prev = stack.pop()
                while prev != "(":
                    atoms.append(prev) 
                    prev = stack.pop()                                   
                stack += atoms * factor
            else:
                stack += [prev] * factor
            factor = ""
        if atom == "" and ch.isalpha():
            atom = ch
        elif ch.islower():
            atom += ch
            stack.append(atom)
            atom = ""
        elif ch.isupper() and atom != "":
            stack.append(atom)
            atom = ch
        elif ch in "()":
            if atom:
                stack.append(atom)
                atom = ""
            stack.append(ch)
    if atom:
        stack.append(atom)
    elif ch.isalpha():
        stack.append(ch)
    return Counter([atom for atom in stack if atom not in "()"])                                         

Best Practices0Clever0
0ForkCompare with your solutionLink
YNestA

def parse_molecule (formula):
    bracket,my_stack={'(':')','[':']','{':'}',')':'(',']':'[','}':'{'},[]
    for x in formula:
        if x.isdigit():
            if my_stack[-1].isdigit():
                my_stack[-1]+=x
            else:
                my_stack.append(x)
        elif x.islower():
            my_stack[-1]+=x
        else:
            if my_stack:
                if my_stack[-1].isalpha() or my_stack[-1] in (')',']','}'):
                    my_stack.append('1')
            my_stack.append(x)
    if  my_stack[-1].isalpha() or my_stack[-1] in (')',']','}'): my_stack.append('1')
    while check_bracket(my_stack):
        for index in range(0,len(my_stack)):
            if my_stack[index] in bracket:
                temp_bracket,left,right,multi=[],index,index,0
                temp_bracket.append(my_stack[index])
                for y in range(index+1,len(my_stack)):
                    if bracket[temp_bracket[-1]]==my_stack[y]:
                        temp_bracket.pop()
                    if not temp_bracket:
                        right,multi=y,int(my_stack[y+1])
                        break
                for y in range(left,right):
                    if my_stack[y].isdigit() and my_stack[y-1] not in bracket:
                        my_stack[y]=str(int(my_stack[y])*multi)
                my_stack.pop(left)
                my_stack.pop(right-1)
                my_stack.pop(right-1)
                break
    res={}
    for x in [(my_stack[x],my_stack[x+1]) for x in range(0,len(my_stack),2)]:
        if x[0] in res:
            res[x[0]]+=int(x[1])
        else:res[x[0]]=int(x[1])
    return res

def check_bracket(formula):
    for bracket in {'(':')','[':']',')':'(','[':']'}:
        if bracket in formula: return True
    return False
Best Practices0Clever0
0ForkCompare with your solutionLink
doctorj

import re
from collections import Counter

atom_re = re.compile('[A-Z][a-z]*')
num_re = re.compile('[0-9]+')

def parse(m, start):
    """:Return: Counter mapping atoms to counts and ending pos in molecule string `m`."""
    if start >= len(m) or m[start] in ')}]':
        return Counter(), start

    # Either [X]N or XN
    if m[start] in '({[':       # [X]
        atoms, start = parse(m, start + 1)
        start += 1
    else:       # X
        match = atom_re.match(m, start)
        atoms = Counter({match.group(0): 1})
        start = match.end()

    # Optional trailing number
    match = num_re.match(m, start)
    atoms = sum((atoms,) * (int(match.group(0)) if match else 1), Counter())      # Multiply everything we just found (the Counter's values) by the number (or 1 if none)
    start = match.end() if match else start

    # Right-recurse
    rest, start = parse(m, start)
    return atoms + rest, start

def parse_molecule(m):
    return dict(parse(m, 0)[0])
Best Practices0Clever0
0ForkCompare with your solutionLink
loopz0723

import re

def parse_molecule (formula):
    atoms = {}
    atom_regex = r'([A-Z][a-z]{0,2})(\d*)'

    while formula:
        match = re.match(atom_regex,formula)
        if match:
            name = match.group(1)
            number = int(match.group(2)) if match.group(2) else 1
            if name not in atoms:
                atoms[name] = number
            else:
                atoms[name] += number
        else:
            for left,right in [('\(','\)'),('\[','\]'),('\{','\}')]:
                regex = left + r'(.+?)'  + right + r'(\d*)';
                match = re.match(regex,formula)
                if not match:
                    continue
                multiple = int(match.group(2)) if match.group(2) else 1
                new_atoms = parse_molecule(match.group(1))
                for atom,num in new_atoms.items():
                    if atom not in atoms:
                        atoms[atom] = num*multiple
                    else:
                        atoms[atom] += num*multiple
                break
        formula = formula[match.end():]
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
phuse2

def parse_molecule (formula):
    import re

    def splittable(s):
        if "[" in s or "(" in s:
            return True
        return False
    
    def split(sTuple):
        s = sTuple[0]
        if not splittable(s):
            return [sTuple]
        
        prevMult = sTuple[1]
        
        splits = []
        
        start = len(s)
    
        if "[" in s:
            start = s.index("[")
            stop = s[start+1:].index("]") + start + 1
            chars = "[]"
        if "(" in s:
            if s.index("(") < start:
                start = s.index("(")
                stop = s[start+1:].index(")") + start + 1
                chars = "()"
        if "{" in s:
            if s.index("{") < start:
                start = s.index("{")
                stop = s[start+1:].index("}") + start + 1
                chars = "{}"
                
        mult = []
        if len(re.findall(r'[0-9]+', s[stop+1])) > 0:
            mult = re.findall(r'[0-9]+', s[stop:])[0]
    
        if start > 0:
            splits.append((s[0:start], prevMult))
    
        if len(s) > (stop + len(mult)) + 1:
            splits.append((s[stop+len(mult)+1:], prevMult))
            
        if len(mult) == 0:
            mult = 1
            
        splits.append((s[start+1:stop], int(mult) * prevMult))
        
        return splits
      
    def splitMol(s):
        s = re.findall(r'([A-Z][a-z][0-9]*)|([A-Z][0-9]*)', s)
        s = [i for j in s for i in j if len(i) > 0]
        
        return s
    
    def countAtoms(molTup, atomDict):
        
        mult = molTup[1]
        atoms = molTup[0]
    
        for a in atoms:
    
            ele = re.findall(r'[a-zA-Z]+',a)[0]
            num = re.findall(r'[0-9]+', a)
            
            if len(num) == 0:
                num = 1
            else:
                num = int(num[0])
            
            num *= mult
            
            if ele not in atomDict:
                atomDict[ele] = num
            else:
                atomDict[ele] += num
        
        return atomDict
    
    allSplits = [(formula, 1)]
    
    while sum(map(lambda x: 1*splittable(x[0]), allSplits)) > 0:
        sTuple = allSplits.pop(0)
        allSplits += split(sTuple)
    
    allSplits = map(lambda (x,y): (splitMol(x),y), allSplits)
    
    atomDict = {}
    
    for tup in allSplits:
        atomDict = countAtoms(tup, atomDict)
        
    return atomDict
Best Practices0Clever0
0ForkCompare with your solutionLink
lpd2

def parse_molecule(form):

    formula = make_list(form)
    d = make_dict(formula)
    for i, symbol in enumerate(formula):
        n = 1
        if symbol.isalpha():
            if formula[i] == formula[-1]:
                d[symbol] += 1
            else:
                if formula[i+1].isdigit():
                    n*=int(formula[i+1])
                n*=brackets(i, formula)
                d[symbol] += n
    return d

def brackets(i, form):
    bracks = ["()", "[]", "{}"]
    formula = form[i:]
    m = 1
    for bracket in bracks:
        if formula.count(bracket[1]) > formula.count(bracket[0]):
            index = formula.index(bracket[1]) + 1
            if formula[index].isdigit():
                m *= int(formula[index])
    return m

def make_dict(formula):

    d = {}
    for i in formula:
        if i.isalpha() and not i in d.keys():
            d[i] = 0
    return d

def make_list(formula):

    l = []
    i = 0
    for c in range(len(formula)):
    
        try:
                if formula[i].isalpha():
                    if formula[i+1].islower():
                        l.append(formula[i:i+2])
                        i += 2
                    else:
                        l.append(formula[i])
                        i += 1
                elif formula[i].isdigit():
                    if formula[i+1].isdigit():
                        l.append(formula[i:i+2])
                        i += 2
                    else: 
                        l.append(formula[i])
                        i += 1
                else:
                    l.append(formula[i])
                    i += 1
        except IndexError:
            l.append(formula[-1])
            break
    return l
Best Practices0Clever0
0ForkCompare with your solutionLink
kjmosher

from collections import Counter
import re

def parse_molecule (formula, multiplier=1):
    parens = {'(':')', '{':'}', '[':']'}
    atoms = Counter()

    while formula:
        m = re.match('^(([A-Z][a-z]?)(\d+)?)', formula)
        if m:
            token, atom, num = m.groups(1)
            atoms.update([atom] * int(num) * multiplier)
            formula = formula[len(token):]

        elif formula[0] in parens:
            opening, formula = formula[0], formula[1:]
            closing = parens[opening]

            sub = opening
            stack = [opening]
            while stack and formula:
                c, formula = formula[0], formula[1:]
                if c == opening:
                    stack.append(c)
                elif c == closing:
                    stack.pop()
                sub += c

            token = re.match('^(\d+)?', formula).groups()[0]
            if token:
                formula = formula[len(token):]
                num = int(token)
            else:
                num = 1

            atoms = atoms + parse_molecule(sub[1:-1], num * multiplier)

    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
scturtle

from collections import defaultdict

def parse_molecule(formula):
    n = len(formula)
    stack = []
    cur = defaultdict(int)
    i = 0
    while i < n:
        if formula[i] in '([{':
            stack.append(cur)
            cur = defaultdict(int)
            i += 1
        elif formula[i] in ')]}':
            i += 1
            sup = stack.pop()
            m = ''
            while i < n and formula[i].isdigit():
                m += formula[i]
                i += 1
            m = int(m) if m else 1
            for k, v in cur.items():
                sup[k] += v * m
            cur = sup
        else:
            c = formula[i]
            i += 1
            while i < n and formula[i].islower():
                c += formula[i]
                i += 1
            m = ''
            while i < n and formula[i].isdigit():
                m += formula[i]
                i += 1
            m = int(m) if m else 1
            cur[c] += m
    return cur
Best Practices0Clever0
0ForkCompare with your solutionLink
chrono3d

import re

def mol_counter(mol_str):
    mol_dict = {}
    last_mol = ''
    for item in mol_str:
        if item.isalpha():
            last_mol = item
            if item in mol_dict:
                mol_dict[item] += 1
            else:
                mol_dict[item] = 1
        if item.isdigit():
            mol_dict[last_mol] += int(item) - 1
    return(mol_dict)
    
def condense(substr):
    mult = re.search('[\)\]\}]([0-9]*)',substr).groups()[0]
    if not mult.isdigit():
        mult = 1
    else:
        mult = int(mult)
    sub = re.search('[\(\[\{]([^\(\[\{\)\]\}]*)[\)\]\}]', substr).groups()[0]
    sub_split = re.split('([A-Z]{1}[a-z]*)', sub)
    sub_dict = {key:value*mult for key, value in mol_counter(sub_split).items()}
    return(''.join(['{0}{1}'.format(k, v) for k,v in sub_dict.iteritems()]))

def parse_molecule (string):
    print(string)
    nested = re.findall('[\(\[\{][^\(\[\{\)\]\}]*[\)\]\}][0-9]*', string)
    while len(nested) > 0:
        for nest in nested:
            string = string.replace(nest, condense(nest))
        nested = re.findall('[\(\[\{][^\(\[\{\)\]\}]*[\)\]\}][0-9]*', string)
    formula = re.split('([A-Z]{1}[a-z]*)', string)
    return(mol_counter(formula))
        
Best Practices0Clever0
0ForkCompare with your solutionLink
jcstallings

import re


def parse_molecule(formula):
    """Return a dictionary with the count of each type of atom from input chemical forumla."""
    open, closed = '([{', ')]}'
    brackets, digits, multipliers = [], [], [1]
    lowercase, index = '', 1
    atoms = {}

    # Init atoms
    for atom in re.findall(r'[A-Z][a-z]?', formula):
        atoms[atom] = 0
    
    # Parse formula in reverse
    for char in formula[::-1]:
        if char in closed:
            brackets.append(char)
            if digits:
                multipliers.append(int(''.join(digits[::-1])))
                digits = []
        elif char in open:
            try:
                brackets.pop()
            except(IndexError):
                raise SyntaxError('Input string may have incorrect brackets.')
            if len(multipliers) > 1:
                multipliers.pop()
        elif char.isdigit():
            digits.append(char)
        elif char.islower():
            lowercase = char
        elif char.isupper():
            atom = '{}{}'.format(char, lowercase)
            lowercase = ''
            if digits:
                index = int(''.join(digits[::-1]))
                digits = []
            atoms[atom] += index * reduce(lambda x, y: x * y, multipliers)
            index = 1
                  
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
jcstallings

import re


def parse_molecule(formula):
    """Return a dictionary with the count of each type of atom from input chemical forumla."""
    open, closed = '([{', ')]}'
    brackets, digits, multipliers = [], [], [1]
    lowercase, index = '', 1
    atoms = {}

    # Init atoms
    for atom in re.findall(r'[A-Z][a-z]?', formula):
        atoms[atom] = 0
    
    # Parse formula in reverse
    for char in formula[::-1]:
        if char in closed:
            brackets.append(char)
            if digits:
                multipliers.append(int(digits.pop()))
        elif char in open:
            try:
                brackets.pop()
            except(IndexError):
                raise SyntaxError('Input string may have incorrect brackets.')
            if len(multipliers) > 1:
                multipliers.pop()
        elif char.isdigit():
            digits.append(char)
        elif char.islower():
            lowercase = char
        elif char.isupper():
            atom = '{}{}'.format(char, lowercase)
            lowercase = ''
            if digits:
                index = int(''.join(digits[::-1]))
                digits = []
            atoms[atom] += index * reduce(lambda x, y: x * y, multipliers)
            index = 1
                  
    return atoms

Best Practices0Clever0
0ForkCompare with your solutionLink
MirzaI

LEFT_TO_RIGHT = {
    '(': ')',
    '[': ']',
    '{': '}',
}

def find_digits(s, i):
    dig = ""
    while i < len(s):
            if s[i].isdigit():
                dig += s[i]
            else:
                break
            i+=1
    if dig == "":
        return 1, i
    else:
        return int(dig), i

def parse_pure(s, cr=False):
    if not cr: cr = {}

    if s == "":
        return cr
    elif len(s) == 1:
        cr[s] = cr.get(s, 0) + 1
        return cr

    fir, sec = s[0], s[1]
    if fir.isupper and sec.isdigit():
        dig, idx_end = find_digits(s, 1)
        cr[fir] = cr.get(fir, 0) + int(dig)
        s = s[idx_end::]
    elif fir.isupper() and sec.isupper():
        cr[fir] = cr.get(fir, 0) + 1
        s = s[1::]
    else:
        dig, idx_end = find_digits(s, 2)
        if dig == "":
            cr[fir + sec] = cr.get(fir + sec, 0) + 1
        else:
            cr[fir + sec] = cr.get(fir + sec, 0) + int(dig)
        s = s[idx_end::]

    return parse_pure(s, cr)

def string_replace(string, start, stop):
    return string[:start] + string[stop:]

def multi_cr(counter, mul):
    if mul != 1:
        for (k, v) in counter.items():
            counter[k] = v*mul
    return counter

def add_counters(counter, sub_counter):
    sum_counters = {}
    for (k,v) in counter.items():
        sum_counters[k] = sum_counters.get(k, 0) + v
    for (k,v) in sub_counter.items():
        sum_counters[k] = sum_counters.get(k, 0) + v
    return sum_counters

def parse_molecule(formula, cr=False):
    if not cr: cr = {}

    outer_pairs = []
    looking_for = None
    for (i, char) in enumerate(formula):
        if char in '[({' and looking_for == None:
            looking_for = (char, i)
        elif looking_for != None and LEFT_TO_RIGHT[looking_for[0]] == char:
            outer_pairs.append((looking_for[1], i))
            looking_for = None

    sub_crs = []
    for op in outer_pairs[::-1]:
        sta, sto = op
        mul, sto_multi = find_digits(formula, sto+1)
        internal_cr = multi_cr(parse_molecule(formula[sta+1:sto]), mul)
        formula = string_replace(formula, sta, sto_multi)
        sub_crs.append(internal_cr)

    #Add non brackets which are left
    sub_crs.append(parse_pure(formula))

    if len(sub_crs) == 1:
        return sub_crs[0]
    else:
        return reduce(lambda a, b: add_counters(a,b),sub_crs)
Best Practices0Clever0
0ForkCompare with your solutionLink
kars7e

ATOM, INTEGER, LBPAREN, RBPAREN, LCPAREN, RCPAREN, LPAREN, RPAREN, EOF = (
    'ATOM', 'INTEGER', '[', ']', '{', '}', '(', ')', 'EOF'
)

def merge(orig, new):
    for atom, count in new.iteritems():
        orig[atom] = orig.get(atom,0) + count

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()

class Lexer(object):
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Invalid character')

    def advance(self):
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # EOF
        else:
            self.current_char = self.text[self.pos]

    def integer(self):
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def atom(self):
        result = self.current_char
        self.advance()
        
        while self.current_char is not None and self.current_char.islower():
            result += self.current_char
            self.advance()
        return result

    def get_next_token(self):
        while self.current_char is not None:

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char.isupper():
                return Token(ATOM, self.atom())

            if self.current_char == '[':
                self.advance()
                return Token(LBPAREN, '[')

            if self.current_char == ']':
                self.advance()
                return Token(RBPAREN, ']')

            if self.current_char == '{':
                self.advance()
                return Token(LCPAREN, '{')

            if self.current_char == '}':
                self.advance()
                return Token(RCPAREN, '}')

            if self.current_char == '(':
                self.advance()
                return Token(LPAREN, '(')

            if self.current_char == ')':
                self.advance()
                return Token(RPAREN, ')')

            self.error()

        return Token(EOF, None)

class Interpreter(object):
    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')

    def eat(self, token_type):
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def molecule(self):
        """molecule: (ATOM | LPAREN expr RPAREN | LBPAREN expr RBPAREN
           | LCPAREN expr RCPAREN
        """   
        token = self.current_token
        if token.type == ATOM:
            self.eat(ATOM)
            return {token.value: 1}                           
        elif token.type == LPAREN:
            self.eat(LPAREN)
            result = self.expr()
            self.eat(RPAREN)
            return result
        elif token.type == LBPAREN:
            self.eat(LBPAREN)
            result = self.expr()
            self.eat(RBPAREN)
            return result
        elif token.type == LCPAREN:
            self.eat(LCPAREN)
            result = self.expr()
            self.eat(RCPAREN)
            return result
        elif token.type == LCPAREN:
            self.eat(LCPAREN)
            result = self.expr()
            self.eat(RCPAREN)
            return result
        else:
            self.error()
  
    def expr(self):
        """expr: (molecule(INTEGER)?)*
        """
        dict = {}
        while self.current_token.type in [ATOM,LPAREN,LBPAREN, LCPAREN]:
            molecule = self.molecule()
            if self.current_token.type == INTEGER:
                multiplier = self.current_token.value
                for atom, count in molecule.iteritems():
                    molecule[atom] = multiplier * count
                self.eat(INTEGER)
            merge(dict,molecule)
        return dict


def parse_molecule (formula):
    interpreter = Interpreter(Lexer(formula))
    return interpreter.expr()
Best Practices0Clever0
0ForkCompare with your solutionLink
kavika

import re

def parse_molecule(formula):
    add_atoms = re.compile('([A-Z][a-z]?)(\d+)?')
    open_brace = re.compile('[\(\{\[]')
    multiply_close_brace = re.compile('[\)\}\]](\d+)?')
    symbol = re.compile(
       add_atoms.pattern + '|' +
       open_brace.pattern + '|' +
       multiply_close_brace.pattern
    )
    stack = [{}]

    for match in symbol.finditer(formula):
        match_text = match.group()

        if add_atoms.match(match_text):
            atom = match.group(1)
            coefficient = int(match.group(2) or 1)
            stack[-1].update({
                atom: stack[-1].get(atom, 0) + coefficient
            })
        elif open_brace.match(match_text):
            stack.append({})
        elif multiply_close_brace.match(match_text):
            coefficient = int(match.group(3) or 1)
            popped = stack.pop()
            stack[-1].update({
                atom: coefficient * value + stack[-1].get(atom, 0)
                for atom, value in popped.items()
            })
        else:
            raise 'Bug in token matching pattern'

    return stack[-1]
Best Practices0Clever0
0ForkCompare with your solutionLink
nutbag

def parse_molecule(formula):
    p,mult = {},[]
    s,spec = "", ""
    for i in reversed(formula):
        if i.isdigit():
            s = i + s
        elif i in ["(","[","{"]:
            if mult: mult.pop()
        elif i in [")","]","}"]:
            if s: mult.append(int(s))
            s = ""
        elif i.isalpha():
            if i.islower():
                spec = i
                continue
            m = 1
            if mult: m = reduce(lambda x,y: x*y, mult)
            if s: m *= int(s)
            try:
                p[i+spec] += m
            except:
                p[i+spec] = m
            s,spec = "",""
    return p
Best Practices0Clever0
0ForkCompare with your solutionLink
kfreter

import re
i = 0
braces = {'{':'}', '[':']', '(':')'}
def parse_molecule (formula, flag=False):
    global i
    retDict = {}
    
    # Stuff to do first time each test
    if not flag:
        # Reset global counter
        i = 0
        
        # Change to easily parsable array 
        formula = re.sub(r'([A-Z][a-z]*)', r' \1 ', formula)
        formula = re.sub(r'(\(|\{|\[|\)|\}|\])', r' \1 ', formula).split()
        #print formula
    #print 'Entry: i = ' + str(i) + ', retDict = ' + str(retDict)
    while i < len(formula):
        entry = formula[i]
        i += 1
        if entry.isalpha():
            if i < len(formula) and formula[i].isdigit():
                value = int(formula[i])
                i += 1
            else: value = 1
            if entry in retDict: retDict[entry] += value
            else: retDict[entry] = value
            continue
        if   entry in braces: iterDict = parse_molecule (formula, True)
        elif entry in braces.values(): 
            # Really should check that the closng brace matches he opening brace...
            if i < len(formula) and formula[i].isdigit():
                value = int(formula[i])
                i += 1
            else: value = 1            
            for key in retDict: retDict[key] *= value
            #print 'Exit: ' + str(retDict)
            return retDict
        for key in iterDict:
            if key in retDict: retDict[key] += iterDict[key]
            else: retDict[key] = iterDict[key]
    #print 'Exit: ' + str(retDict)
    return retDict        
Best Practices0Clever0
0ForkCompare with your solutionLink
ZixiaWang



def parse_molecule (formula):
    result = {}
    i = len(formula) - 1
    while i >= 0:
        if formula[i].isupper():
            result[formula[i]] = 0
        elif formula[i].islower():
            result[formula[i-1:i+1]] = 0
            i -= 1
        i -= 1
    rec(formula, result, 1)
    print result
    return result
       
def rec(formula, result, weight):
    bracket = {')':'(', ']':'[', '}':'{'} 
    
    i = len(formula) - 1
    while i >= 0:
        if formula[i].isupper():
            if i == len(formula) - 1:
                result[formula[i]] += weight
            elif formula[i + 1].isdigit():
                if i < len(formula) - 2 and formula[i + 2].isdigit():
                    result[formula[i]] += int(formula[i + 1:i + 3]) * weight
                else:
                    result[formula[i]] += int(formula[i + 1]) * weight
            else:
                result[formula[i]] += weight
                
        elif formula[i].islower():
            if i == len(formula) - 1:
                result[formula[i-1:i+1]] += weight
                i -= 1
            elif formula[i + 1].isdigit(): 
                result[formula[i-1:i+1]] += int(formula[i + 1]) * weight
                i -= 1
            else:
                result[formula[i-1:i+1]] += weight
                i -= 1
        elif formula[i] in bracket.keys():
            for j in xrange(i - 2, 0, -1):
                if formula[j] == bracket[formula[i]]:
                    if formula[i + 1].isdigit():
                        rec(formula[j + 1:i], result, int(formula[i + 1]) * weight)
                    else:
                        rec(formula[j + 1:i], result, weight)
                    i = j
                    break
                    
        i -= 1
            
Best Practices0Clever0
0ForkCompare with your solutionLink
Micromind

#from string import *
#CorBrace = {'(':')', '[':']', '{':'}'}
def parse_molecule (formula):
    if formula == "": return None

    DigitString   = ""
    ElementString = ""
    
    Elements = {}
    Factors = [1]
    CurrentFactor = 1    
    for i in xrange( len(formula)-1, -1, -1 ):
        if    formula[i].isdigit():  DigitString = formula[i] + DigitString
        elif  DigitString != "":     CurrentFactor = int(DigitString); DigitString = ""
        
        if    formula[i] in ")]}":   Factors.append(CurrentFactor); CurrentFactor = 1
        elif  formula[i] in "([{":   Factors.pop()
        elif  formula[i].islower():  ElementString = formula[i] + ElementString
        elif  formula[i].isupper():  
            ElementString = formula[i] + ElementString
            if ElementString in Elements:  Elements[ElementString] += CurrentFactor*reduce(lambda x, y: x*y, Factors)
            else:                          Elements[ElementString] = CurrentFactor*reduce(lambda x, y: x*y, Factors)
            
            ElementString = ""
            CurrentFactor = 1
        
    return Elements
Best Practices0Clever0
0ForkCompare with your solutionLink
ynnej

def split_units(formula) :
    ''' The given chemical formula is split into a list of units.
    Each unit consists of either an atom or a bracketed expression,
    with or without an index. '''
    if len(formula) == 0 :
        return []
    if len(formula) == 1 :
        return [formula]
    if formula[0] in ['(','[','{'] :
        n_open = 1
        for i in range(1,len(formula)) :
            if n_open == 0 and not formula[i].isdigit() :
                return [formula[:i]] + split_units(formula[i:])
            if formula[i] in ['(','[','{'] :
                n_open += 1
            if formula[i] in [')',']','}'] :
                n_open -= 1
        return [formula]
    for i in range(1, len(formula)) :
        if formula[i].isupper() or formula[i] in ['(','[','{'] :
            return [formula[:i]] + split_units(formula[i:])
    return [formula]

def split_number(unit) :
    ''' This function expects one unit as defined by the split_units function
    and returns a tuple (unit,index) where the first entry is the atom or 
    bracketed expression and the second one is the index. If there is no index,
    the number will be 1. '''
    expr  = unit.rstrip('0123456789')
    count = 1 if expr == unit else int(unit.replace(expr,''))
    return expr,count

def parse_molecule (formula):
    atoms = {}
    units = split_units(formula)
    print formula, units
    for unit in units :
        if unit[0] in ['(','[','{'] :
            nested,count = split_number(unit)
            n_atoms = parse_molecule(nested[1:-1])
            for atom in n_atoms :
                atoms[atom] = atoms.get(atom, 0) + count * n_atoms[atom]
        else :
            atom,count = split_number(unit)
            atoms[atom] = atoms.get(atom, 0) + count
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
Gabino3

def parse_molecule(formula):
  formula = tokenize(formula)
  mol_counts = {}
  bracket_match = { '{':'}', '[':']', '(':')' }
  num_stack = []
  for c in formula[::-1]:
    if isinstance( c, int ) or c in ['}',']',')']:
      num_stack.append(c)
    elif c in bracket_match:
      num_stack = num_stack[:getLastIndex(num_stack, bracket_match[c])]
      if len(num_stack) > 0 and isinstance( num_stack[-1], int ):
        num_stack = num_stack[:-1]
    else:
      count = 1
      if len(num_stack) > 0 and isinstance( num_stack[-1], int ):
        count *= num_stack[-1]
        num_stack = num_stack[:-1]
      for x in num_stack[::-1]:
        if isinstance( x, int ):
          count *= x
      if c in mol_counts:
        mol_counts[c] += count
      else:
        mol_counts[c] = count
  return mol_counts

def tokenize(formula):
  tokens = []
  pos = 0
  while pos < len(formula):
    if formula[pos].isdigit():
      tok = ''
      while pos < len(formula) and formula[pos].isdigit():
        tok += formula[pos]
        pos += 1
      tokens.append(int(tok))
    elif formula[pos].isupper():
      tok =  formula[pos]
      pos += 1
      while pos < len(formula) and formula[pos].islower():
        tok += formula[pos]
        pos += 1
      tokens.append(tok)
    elif formula[pos] in ['}',']',')', '[','{','(']:
      tokens.append(formula[pos])
      pos += 1
  return tokens



def getLastIndex(l, v):
  return len(l) - l[::-1].index(v) - 1
Best Practices0Clever0
0ForkCompare with your solutionLink
smirnov-am

import re
def simple_parse(string):
    res={}
    for i in re.findall(r'([A-Z][a-z]?)(\d?\d?)',string):
        if i[0] in res:
            res[i[0]]+=int(i[1]) if i[1] else 1
        else:
            res[i[0]]=int(i[1]) if i[1] else 1
    return res


def parse_molecule (formula):
    a=formula
    pattern=re.compile(r'[\[\(\{](\w+)[\)\]\}](\d?\d?)')
    while pattern.findall(a):
        for i in pattern.findall(a):
            count=1
            if i[1]:
                count=int(i[1])
            a=re.sub(r'[\[\(\{]'+i[0]+r'[\)\]\}]'+i[1],i[0]*count,a)
    return  simple_parse(a)
Best Practices0Clever0
0ForkCompare with your solutionLink
gmtime

import re
def parse_molecule (formula, count = False):
  subcall = count
  atoms = dict()
  counter = 0
  while len(formula) > 0 and formula[0] not in ")}]":
    if formula[0] in "({[":
      [length, sub] = parse_molecule(formula[1:], True) # 1 for the opening bracket
    else:
      sub = dict([(re.match(r"[A-Z][a-z]*", formula).group(), 1)])
      length = len(sub.keys()[0] )
    mult = re.match(r"\d*", formula[length:]).group()
    formula = formula[length + len(mult):]
    counter += length + len(mult)
    mult = 1 if not mult else int(mult)
    sub = dict([(atom, count*mult) for (atom, count) in sub.iteritems()])
    atoms = dict([(atom, atoms.get(atom, 0)+sub.get(atom, 0)) for atom in set(atoms)|set(sub)])
  if subcall: return [counter + 2, atoms] # plus 2 for brackets
  return atoms 
Best Practices0Clever0
0ForkCompare with your solutionLink
francois-travais

import re

atom = re.compile('[A-Z][a-z]?')
sqr = re.compile('\d+');
open_par = re.compile('[[({]');
close_par = re.compile('[])}]');

def merge (d1, d2):
    return {k: d1.get(k, 0) + d2.get(k, 0) for k in set(d1) | set(d2) }

def multiply (d, nb):
    return {k: v * nb for k, v in d.items()}

def parse (formula):
    result = dict()
    while (len(formula) != 0):
        tmp = dict()
        matchAtom = atom.match(formula)
        matchOpenPar = open_par.match(formula)
        matchClosePar = close_par.match(formula)
        # Enter group
        if matchOpenPar is not None:
            (tmp, formula) = parse(formula[1:])
        # Exit group
        elif matchClosePar is not None:
            return (result, formula[1:])
        # Atom
        elif matchAtom is not None:
            tmp = {formula[:matchAtom.end()]: 1}
            formula = formula[matchAtom.end():]
        # Multiplier
        matchSqr = sqr.match(formula)
        if matchSqr is not None:
            val = int(formula[:matchSqr.end()])
            tmp = multiply(tmp, val)
            formula = formula[matchSqr.end():]
        result = merge(result, tmp)
    return (result, formula)

def parse_molecule (formula):
    return parse(formula)[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
tchar

import re

def parse_molecule (formula):
    
    _dict = {}
    _regex = {'braces': '\{(.*?)\}(\d*)', 'brackets': '\[(.*?)\](\d*)', 
             'parentheses': '\((.*?)\)(\d*)', 'simple':'([A-Z][a-z]?)(\d*)'}
    
    def _assign_molecules(molecules):
        for molecule, num in molecules:
            try: _dict[molecule] += num
            except KeyError: _dict[molecule] = num
    
    
    def _process_formula(formulas):
        formula, mul = formulas.pop()
        
        for key in ['braces', 'brackets', 'parentheses']:
            findall = re.findall(_regex[key], formula)
            formulas += [(a, mul*int(b)) if b.isdigit() else (a, mul) for a, b in findall]
            formula = re.sub(_regex[key], '', formula)
    
        findall = re.findall(_regex['simple'], formula)
        molecules = [(a, mul) if not b.isdigit() else (a, mul*int(b)) for a, b in findall]
        _assign_molecules(molecules)        
    
    formulas = [(formula, 1)]
    
    while formulas:
        _process_formula(formulas)

    return _dict
Best Practices0Clever0
0ForkCompare with your solutionLink
mlyundin

from collections import defaultdict
from operator import mul

OPEN_B = '{[('
CLOSE_B = '}])'

def parse_molecule(formula):
    n = len(formula)
    def get_next_symbols(start, criteria, default=None):
        j = start
        while j < n and criteria(formula[j]):
            j += 1
        res = formula[start:j]
        if not res:
            res = default

        return res, j

    get_next_number = lambda start: get_next_symbols(start, str.isdigit, '1')

    i = 0
    parsed_formula = []
    while i < len(formula):
        item = formula[i]
        if item in OPEN_B + CLOSE_B:
            parsed_formula.append(item)
            i += 1

            if item in CLOSE_B:
                res, i = get_next_number(i)
                parsed_formula.append(int(res))
        else:
            res, i = get_next_symbols(i+1, str.islower, '')
            parsed_formula.append(item+res)

            res, i = get_next_number(i)
            parsed_formula.append(int(res))

    multipliers = []
    res = defaultdict(int)
    for item in reversed(parsed_formula):
        if isinstance(item, int):
            multipliers.append(item)
        elif item in OPEN_B:
            multipliers.pop()
        elif item not in CLOSE_B:
            res[item] += reduce(mul, multipliers, 1)
            multipliers.pop()

    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
xroman

import re
def parse_molecule (formula):
    temp=formula[::]
    result={}
    temp=re.sub(r'\((.*?)\)(\d*)',lambda x: x.group(1)*(int(x.group(2)) if x.group(2) else 1),temp)
    temp=re.sub(r'\[(.*?)\](\d*)',lambda x: x.group(1)*(int(x.group(2)) if x.group(2) else 1),temp)
    temp=re.sub(r'\{(.*?)\}(\d*)',lambda x: x.group(1)*(int(x.group(2)) if x.group(2) else 1),temp)
    temp=[[x,int(y) if y else 1] for (x,y) in re.findall(r'([A-Z][a-z]*)(\d*)',temp)]
    temp=map(lambda x:(x,sum([y[1] for y in filter(lambda z:z[0]==x,temp)])),set(x[0] for x in temp))
    for (x,y) in temp:result[x]=y
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
anter69

import re

def parse_molecule(formula):
    while True:
        m = re.search("[\(\[\{](\w+)[\)\]\}](\d+)", formula)
        if m:
            formula = re.sub(re.escape(m.group(0)), m.group(1) * int(m.group(2)), formula)
        else:
            break
    
    while True:
        m = re.search("([A-Z][a-z]?)(\d+)", formula)
        if m:
            formula = re.sub(m.group(0), m.group(1) * int(m.group(2)), formula)
        else:
            break
    
    formula = re.findall("[A-Z][a-z]?", formula)

    atoms = {}
    for e in formula:
        atoms[e] = atoms.get(e, 0) + 1
    
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
NonStop

import re
def finder(formula):
  counter = 0
  for i,char in enumerate(formula[0:]):
    if char == '(': counter += 1
    if char == ')': 
      counter -= 1
      if counter == 0:
        return i  
        
def dict_multiply(dict,m):
  for key in dict:
    dict[key]*=m
  return dict

def dict_append(dictbig,d):
  for key in d:
    if key in dictbig:
      dictbig[key] += d[key]
    else:
      dictbig[key] = d[key]
  return dictbig

def parse_molecule (formula):
  result ={}
  formula = formula.replace('[','(').replace(']',')').replace('{','(').replace('}',')')
  words = []
  while '(' in formula:
    begin = formula.find('(')
    end = finder(formula)
    m = 1
    word = formula[begin+1:end]
    if formula[end+1].isdigit():
      m = int(formula[end+1])
      end += 1
    words.append( [word, m] )
    formula = formula[:begin] + formula[end+1:]
  print formula
  print words
  while formula!='':
    srch = re.search('[A-Z][a-z]?[0-9]*', formula)
    element = srch.group(0)
    srchelement = re.search('[A-Z][a-z]?', element)
    elementname = srchelement.group(0)
    srchelement = re.search('[0-9]+', element)
    if srchelement == None: elementamount = 1
    else: elementamount = int(srchelement.group(0))
    elementResult = {elementname:elementamount}
    result = dict_append(result,elementResult)
    formula = formula.replace(element,'')
  for newformula, m in words:
    result = dict_append(result, dict_multiply(parse_molecule(newformula),m))
  print result
  return result
Best Practices0Clever0
0ForkCompare with your solutionLink
WangWeiqiang

import re
groupnumber=re.compile(r'(.*)(\[.*\]|\(.*\)|\{.*\})(\d+)(.*)')
pattern=re.compile(r'([A-Z][a-z]{0,2})(\d+|)')
def mutipleItem(formula,count):
    l=[]
    atoms=pattern.findall(formula)
    for i in range(len(atoms)):
        l.append(atoms[i][0])
        if atoms[i][1]=='':
            l.append(str(count))
        else:
            l.append(str(int(atoms[i][1])*count))
    return ''.join(l)    
def parse_molecule(formula):
    g=groupnumber.match(formula)
    if g is not None:
        return parse_molecule(g.group(1)+mutipleItem(g.group(2),int(g.group(3)))+g.group(4))
    else:
        d=dict()
        for e in pattern.findall(formula):
            if d.has_key(e[0]):
                if e[1]!='': d[e[0]]+=int(e[1])
                else: d[e[0]]+=1
            else:
                if e[1]!='': d[e[0]]=int(e[1])
                else: d[e[0]]=1
        return d
Best Practices0Clever0
0ForkCompare with your solutionLink
WangWeiqiang

import re
groupnumber=re.compile(r'(.*)(\[.*\]|\(.*\)|\{.*\})(\d+)(.*)')
pattern=re.compile(r'([A-Z][a-z]{0,2})(\d+|)')

def mutipleItem(formula,count):
    print formula,count
    l=[]
    x=pattern.findall(formula)
    
    for i in range(len(x)):
        l.append(x[i][0])
        if x[i][1]=='':
            l.append(str(count))
        else:
            l.append(str(int(x[i][1])*count))

    return ''.join(l)
    
def parse_molecule(formula):
    g=groupnumber.match(formula)
    if g is not None:
        g1=g.group(1)
        g2=g.group(2)
        g3=g.group(3)
        g4=g.group(4)
        n=mutipleItem(g2,int(g3))

        return parse_molecule(g1+n+g4)
    else:
        d=dict()
        for e in pattern.findall(formula):
            if d.has_key(e[0]):
                if e[1]!='':
                    d[e[0]]+=int(e[1])
                else:
                    d[e[0]]+=1
            else:
                if e[1]!='':
                    d[e[0]]=int(e[1])
                else:
                    d[e[0]]=1
        return d
Best Practices0Clever0
0ForkCompare with your solutionLink
Sergey Surazhskyi

parens = {
    '(' : ')',
    '[' : ']',
    '{' : '}'
};

def merge_two_dicts(x, y):
    for key in x:
        if y.get(key, -1) == -1:  y.update({ key : x[key]}) ;
        else: y[key] += x[key];
    return y

def __parse_molecule(formula, close_paren = None):
    #parse parametrs
    res = {};
    el_name = "";
    el_cnt  = 1;
    was_digit = False;
    was_lower = False;
    i = len(formula) - 1;

    while (i >= 0):
        if formula[i].isdigit():
            if was_digit:
                el_cnt = el_cnt + int(formula[i]) * 10;
            else:
                was_digit = True;
                el_cnt = int(formula[i]);
        elif formula[i].isalpha():
            if formula[i].islower():
                was_lower = True;
                el_name = formula[i] + el_name;
                i -= 1;
                continue;
            else:
                if was_lower:
                    el_name = formula[i] + el_name;
                else:
                    el_name = formula[i];
                was_lower = False;
            try:
                res[el_name] += el_cnt;
            except:
                res.update({ el_name : el_cnt});
            el_name = "";
            el_cnt = 1;
            was_digit = False;
        else: #parens
            if parens.get(formula[i], -1) == close_paren:
                return res, i;
            parens_res, i = __parse_molecule(formula[0:i], formula[i]);
            for key in parens_res:
                parens_res[key] *= el_cnt;
            el_cnt = 1;
            res = merge_two_dicts(res, parens_res);
            was_digit = False;
        i -= 1;
    return res, i
    
def parse_molecule(formula):
    res, i = __parse_molecule(formula);
    return res;
Best Practices0Clever0
0ForkCompare with your solutionLink
marwahaha

def parse_molecule (formula):
    d = {}
    def merge(a,b,gm):
        for i in b:
            if i in a: a[i] += gm*b[i]
            else: a[i] = gm*b[i]
        return a
    i = 0
    while i < len(formula):
        brackets = [['[','(','{'],[']',')','}']]
        if formula[i] in brackets[0]:
            b = brackets[0].index(formula[i])   
            gm,x = '',formula[i:].find(brackets[1][b])
            word = formula[(i+1):(i+x)]
            i = i+x
            while i+1 < len(formula) and formula[i+1] in '0123456789':
                gm += formula[i+1]
                i += 1
            d = merge(d,parse_molecule(word),int(gm) if len(gm) > 0 else 1)
        elif formula[i] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
            f,m = formula[i],''
            if i+1 < len(formula) and formula[i+1] in 'abcdefghijklmnopqrstuvwxyz':
                f += formula[i+1]
                i += 1
            while i+1 < len(formula) and formula[i+1] in '0123456789':
                m += formula[i+1]
                i += 1
            m = int(m) if len(m) > 0 else 1
            if f in d: d[f] += m
            else: d[f] = m
        i += 1
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
mhagiwara

import re
from collections import Counter


def parse_molecule(formula):
    segments = re.findall(r'(?:[A-Z][a-z]?)|(?:[0-9]+)|(?:[\(\)\{\}\[\]])', formula)
    res = ''
    prev_seg = None
    for seg in segments:
        if seg.isalpha():
            if prev_seg is not None and prev_seg not in {'(', '{', '['}:
                res += '+'
            res += "'%s'" % seg
        elif seg.isdigit():
            res += '*%s' % seg
        elif seg in {'(', '{', '['}:
            if prev_seg is not None and prev_seg not in {'(', '{', '['}:
                res += '+'
            res += '('
        elif seg in {')', '}', ']'}:
            res += ')'
        prev_seg = seg
    return dict(Counter(re.findall(r'[A-Z][a-z]?', eval(res))))

Best Practices0Clever0
0ForkCompare with your solutionLink
Nuno

import re
def parse_molecule(formula):
    elements = {'A':'As', 'M':'Mg', 'Y':'Mo', 'Z':'Pd', 'W':'Be', 'E':'Co', 'Q':'Cu', 'F':'Fe' }
    rev_elements = dict((v,k) for k, v in elements.items())
    f = ''
    result = {}
    for el in list(rev_elements.keys()):
        formula = formula.replace(el,rev_elements[el])
    f = formula[:]
    for el in f:
        if el.isalpha():
            result[el]=0
    while re.search(r"\(([A-Za-z0-9_]+)\)", f) != None:
        in_brackets = re.search(r"\(([A-Za-z0-9_]+)\)", f).group(1)
        f = simplify(f,in_brackets)
    while re.search(r"\[([A-Za-z0-9_]+)\]", f) != None:
        in_brackets = re.search(r"\[([A-Za-z0-9_]+)\]", f).group(1)
        f = simplify(f,in_brackets)
    while re.search(r"\{([A-Za-z0-9_]+)\}", f) != None:
        in_brackets = re.search(r"\{([A-Za-z0-9_]+)\}", f).group(1)
        f = simplify(f,in_brackets)
    f = list(f)
    i=0
    while i < len(f):   # caso em que pode existir um numero com dois digitos
        if i+1 < len(f):
            if not f[i].isalpha() and not f[i+1].isalpha():
                f[i] += f[i+1]
                del(f[i+1])
                i -= 1
        i += 1
    for i in range(len(f)):
        if f[i].isalpha() and i+1 < len(f) and not f[i+1].isalpha():
            result[f[i]] += int(f[i+1])
        elif f[i].isalpha():
            result[f[i]] += 1
    for el in result:
        if el in elements:
            result[elements[el]] = result[el]
            del(result[el])
    return result
    
def simplify(f,in_brackets):   #desdobra parenteses {[(  )]}    
    index = f.index(in_brackets)
    length = len(in_brackets)
    n = f[index+length+1]
    if not n.isalpha():
        in_brackets = list(in_brackets)
        i=0
        while i < len(in_brackets):   # caso em que pode existir um numero com dois digitos
            if i+1 < len(in_brackets):
                if not in_brackets[i].isalpha() and not in_brackets[i+1].isalpha():
                    in_brackets[i] += in_brackets[i+1]
                    del(in_brackets[i+1])
                    i -= 1
            i += 1
        for i in range(len(in_brackets)):
            if in_brackets[i].isalpha():
                if i+1 < len(in_brackets) and in_brackets[i+1].isalpha():
                    in_brackets[i] += n
            else:
                in_brackets[i] = str(eval(in_brackets[i]+'*'+n))
        if in_brackets[-1].isalpha():
            in_brackets[-1] += n
        in_brackets = ''.join(in_brackets)
        return f[:index-1] + in_brackets + f[(index+length+2):]
    else:
        return f[:index-1] + in_brackets + f[(index+length+1):]
Best Practices0Clever0
0ForkCompare with your solutionLink
icemonster

#Yes, its gigantic
#Yes, its stupid
#No, im not proud
#And no, im not ashamed of myself.
#Because ye... i dont care
def count_atoms(formula,atoms):
  res = {}
  atoms.sort(lambda x,y: cmp(len(y),len(x)))
  for atom in atoms:
      res[atom] = formula.count(atom)
      while atom in formula:
        index = formula.find(atom)
        formula = list(formula)
        for i in range(index,index+len(atom)):
          formula[i] = ''
        formula = ''.join(formula)
  return res

def aux_parse(formula):
  if '(' not in formula and '[' not in formula and '{' not in formula:
    return formula
  b = ''
  index = 0
  formula = list(formula)
  for i in range(len(formula)):
    if formula[i] in ('([{'):
      index = i
      if formula[i] == '(':
        b = ')'
      elif formula[i] == '[':
        b = ']'
      elif formula[i] == '{':
        b = '}' 
    if formula[i] == b:
      #Number after brackets is optional
      if i != len(formula)-1 and formula[i+1] in str(range(1,10)).strip('[]'):
        #Multiply each atom and remove brackets
        number = ''
        for i2 in range(i+1,len(formula)):
          if formula[i2] in str(range(10)).strip('[]'):
            number += formula[i2]
          else:
            break
        number = int(number)
        for i3 in range(i+1,i2):
          formula[i3] = ''
        return aux_parse(''.join(formula[:index]+formula[index+1:i]*number+formula[i+2:]))
      return aux_parse(''.join(formula[:index]+formula[index+1:i]+formula[i+1:]))


def parse_molecule (formula):
    atoms = []
    formula = list(formula)
    lowerLetters = ('abcdefghijklmnopqrstuvwxyz')
    #initialize
    for c in range(len(formula)):
        if formula[c] not in str(range(1,10)) and formula[c] not in ('({[]})') and formula[c] not in lowerLetters:
            #s --> symbol
            s = formula[c]
            if c != len(formula)-1 and formula[c+1] in lowerLetters: #If atom = Xx
                s+=formula[c+1]
                if s not in atoms: atoms.append(s)
                if c < len(formula)-2 and formula[c+2] in str(range(1,10)).strip('[]'): #If there's a following number
                  number = ''
                  for i2 in range(c+2,len(formula)):
                    if formula[i2] in str(range(10)).strip('[]'):
                      number += formula[i2]
                    else:
                      break
                  if i2 == len(formula)-1 and formula[i2] in str(range(1,10)).strip('[]'):
                    i2 += 1
                  number = int(number)
                  for i in range(c+1,i2):
                    formula[i] = ''
                  formula[c] = s*number
            else: #If atom = X
                if formula[c] not in atoms: atoms.append(formula[c])
                if c < len(formula)-1 and formula[c+1] in str(range(1,10)).strip('[]'): #If there's a following number
                  number = ''
                  for i2 in range(c+1,len(formula)):
                    if formula[i2] in str(range(10)).strip('[]'):
                      number += formula[i2]
                    else:
                      break
                  if i2 == len(formula)-1 and formula[i2] in str(range(1,10)).strip('[]'):
                    i2 += 1
                  number = int(number)
                  for i in range(c+1,i2):
                    formula[i] = ''
                  formula[c] = s*number
    formula = ''.join(formula)
    formula = aux_parse(formula)
    return count_atoms(formula,atoms)
Best Practices0Clever0
0ForkCompare with your solutionLink
KPC1061

import operator

def combine_dicts(a, b, op=operator.add):
    """merge two dictionaries"""
    return dict(a.items() + b.items() +
        [(k, op(a[k], b[k])) for k in set(b) & set(a)])

def helper1(dic, key, freq):
    """small helper function"""
    if key in dic.keys():
        dic[key] += freq
    else:
        dic[key] = freq
    return dic

def formula_wo_parens(formula):
    """parses formula that does not contain parenthesis"""
    atom_count = {}
    for i in range(len(formula)):
        try:
            if formula[i].isalpha() and formula[i].isupper():
                    element = formula[i]
                    if formula[i + 1].isalpha() and formula[i + 1].islower():
                        element += formula[i + 1]
                        if formula[i + 2].isdigit():
                            atom_count = helper1(atom_count, element, int(formula[i + 2]))
                            try:
                                if formula[i + 3].isdigit():
                                    atom_count[element] = int(formula[i + 2:i + 4])
                            except IndexError:
                                continue
                        else:
                            atom_count = helper1(atom_count, element, 1)
                    elif formula[i + 1].isalpha():
                        atom_count = helper1(atom_count, formula[i], 1)
                    elif formula[i + 1].isdigit():
                        atom_count = helper1(atom_count, formula[i], int(formula[i + 1]))
                        try:    
                            if formula[i + 2].isdigit():
                                    atom_count[element] = int(formula[i + 1:i + 3])
                        except IndexError:
                            continue
        except IndexError:
            helper1(atom_count, element, 1)
    return atom_count

def get_paren_contents(formula):
    """for any string returns the content of the first
    properly closed parenthesis"""
    for j in range(len(formula)):
        if formula[j] == '(':
            count = 1
            for i in range(j + 1, len(formula)):
                if formula[i] == ')':
                    count -= 1
                if formula[i] == '(':
                    count += 1
                if count == 0:
                    break
            return formula[j + 1:i]
        if formula[j] == '[':
            count = 1
            for i in range(j + 1, len(formula)):
                if formula[i] == ']':
                    count -= 1
                if formula[i] == '[':
                    count += 1
                if count == 0:
                    break
            return formula[j + 1:i]
        if formula[j] == '{':
            count = 1
            for i in range(j + 1, len(formula)):
                if formula[i] == '}':
                    count -= 1
                if formula[i] == '{':
                    count += 1
                if count == 0:
                    break
            return formula[j + 1:i]
    return ''

def parse_molecule(formula):
    """returns atom count of the formula"""
    atom_count = {}
    allowed_brackets = ['[', ']', '{', '}', '(', ')']
    # are there bracketed subformulas?
    if any(br in formula for br in allowed_brackets):
        # get the first subformula
        sub_formula = get_paren_contents(formula)
        try:
            indx = formula.find(sub_formula) + len(sub_formula) + 1
            if formula[indx].isdigit():
                freq = int(formula[indx])
            else:
                freq = 1
                indx -= 1
        except IndexError:
            freq = 1
        # count of inner parenthesis
        sub_count = parse_molecule(sub_formula)
        # remove that subformula to prevent overcounting
        formula = formula[:formula.find(sub_formula) - 1] + formula[indx + 1:]
        atom_count = parse_molecule(formula)
        # weight subcoun
        while freq != 0:
            atom_count = combine_dicts(atom_count, sub_count)
            freq -= 1
        return atom_count
    # no bracketed subformulas
    else:
        return formula_wo_parens(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
pstryq

def try_push(inp, stack):
    if len(inp) > 0:
        stack.append(inp)
        return True
    return False

def try_push_all(inp_atom, inp_num, stack):
    try_push(inp_num, stack)
    try_push(inp_atom, stack)

def parse_formula(formula):
    parsed = []
    new_atom = ''
    new_num = ''
    for char in formula:
        if char.isupper():
            try_push_all(new_atom, new_num, parsed)
            new_num = ''
            new_atom = char
        elif char.islower():
            new_atom += char
        elif char.isdigit():
            try_push(new_atom, parsed)
            new_atom = ''
            new_num += char
        elif char in '([{':
            try_push_all(new_atom, new_num, parsed)
            new_num = ''
            new_atom = ''
            parsed.append(char)
        else:
            try_push_all(new_atom, new_num, parsed)
            new_num = ''
            new_atom = ''
            parsed.append(char)
    try_push_all(new_atom, new_num, parsed)
    return parsed

def mul(collection):
    return reduce(lambda x, y : int(x) * int(y), collection)

def parse_molecule (formula):
    result = {}
    parsed = parse_formula(formula)
    stack = ['1']
    was_digit = False
    for el in parsed[::-1]:
        if el in ')]}':
            was_digit = False
            continue
        if el.isdigit():
            stack.append(el)
            was_digit = True
        else:
            if el.isalpha():
                if not was_digit:
                    stack.append('1')
                if el in result:
                    result[el] += mul(stack)
                else:
                    result[el] = mul(stack)
            stack.pop()
            was_digit = False
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
RevansChen

import re

replace_bracket = lambda formula: formula.replace('{', '(').replace('}', ')').replace('[', '(').replace(']', ')')

def parse(formula):
    formula = replace_bracket(formula)        
    return re.findall('[()]|[A-Z][a-z]*|\d*', formula)

def dictAdd(d1, d2):
    for k, v in d2.items():
        d1[k] = d1[k] + v if k in d1 else v
    return d1

def dictMul(d, num):
    return {k: d[k] * num for k in d}

def parse_molecule(formula):
    elements = parse(formula)
    stack = []
    for element in elements:
        if element == '(':
            stack.append(element)
        elif element == ')':
            atoms = {}
            while True:
                s = stack.pop()
                if s == '(':
                    stack.append(atoms)
                    break
                atoms = dictAdd(atoms, s)
        elif element.isdigit():
            num = int(element)
            atoms = stack.pop()
            stack.append(dictMul(atoms, num))
        elif element.isalpha():
            stack.append({element: 1})
            
    result = stack.pop()
    while len(stack) > 0:
        result = dictAdd(result, stack.pop())
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
RevansChen

import re

replace_bracket = lambda formula: formula.replace('{', '(').replace('}', ')').replace('[', '(').replace(']', ')')

def parse(formula):
    elements = []
    formula = replace_bracket(formula)
    
    while len(formula) > 0:
        m = re.match('\(|\)|([A-Z][a-z]*)|(\d*)', formula)
        element, i = m.group(0), m.end()
            
        elements.append(element)
        formula = formula[i:]
        
    return elements

def dictAdd(d1, d2):
    for k, v in d2.items():
        d1[k] = d1[k] + v if k in d1 else v
    return d1

def dictMul(d, num):
    return {k: d[k] * num for k in d}

def parse_molecule(formula):
    elements = parse(formula)
    stack = []
    for element in elements:
        if element == '(':
            stack.append(element)
        elif element == ')':
            atoms = stack.pop()
            while True:
                e = stack.pop()
                if e == '(':
                    stack.append(atoms)
                    break
                atoms = dictAdd(atoms, e)
        elif element.isdigit():
            num = int(element)
            atoms = stack.pop()
            stack.append(dictMul(atoms, num))
        else:
            stack.append({element: 1})
    result = stack.pop()
    while len(stack) > 0:
        result = dictAdd(result, stack.pop())
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
GallardoAlba



class Preprocess:
    diccionario = {"(":")","{":"}","[":"]"}
    def __init__(self,formula):
        self.formula = formula
    def split_formula(self):
        queue = []; indices, pieces = [], []
        counters = map(self.formula.count,self.diccionario.keys())
        counters = [x for x in counters if x != 0]
        if not sum(counters): return self.formula
        for i in range(min(counters),len(self.formula)):
            counters = map(self.formula[i:].count,self.diccionario.keys())
            counters =[x for x in counters if x != 0]
            if not counters:
                indices.append(len(self.formula)-1)
                break
            if self.formula[i] in self.diccionario.values():
                queue.append(self.formula[i])
            elif self.formula[i] in self.diccionario.keys():
                queue.pop()
            if i != 0 and i != min(counters) and  not queue: indices.append(i)
        for i in range(len(indices)-1):
            if i == 0: pieces.append(self.formula[:indices[i]+1])
            pieces.append(self.formula[indices[i]+1:indices[i+1]+1])
        ctrl = 0; result = []
        while True:
            try:
                if len(pieces[ctrl]) > 1: result.append(pieces[ctrl])
                elif pieces[ctrl].isdigit() or pieces[ctrl].islower():
                    result.append(pieces[ctrl] + pieces[ctrl+1])
                    ctrl+=1
                ctrl+=1
            except:
                break
        for i in range(1,len(result)):
            if result[i-1][-1].isdigit():
                val = result[i-1][-1]
                result[i-1] = result[i-1][:-1]
                result[i] = val + result[i]
        self.formula = result
    
    def normalize(self,formula):
        formula.append("end"); i = 0
        while formula[i] != "end":
            if formula[i].isalpha() and formula[i+1].isalpha():
                if formula[i].isupper() and formula[i+1].isupper():
                    formula.insert(i+1,"1")
                    i+=1
                elif formula[i].islower():
                    i+=1
                else:
                    formula.insert(i,"1")
                    i+=1
            elif formula[i] in self.diccionario.values():
                if not formula[i+1].isdigit():
                    if formula[i+1].islower():
                        formula.insert(i+1,"1")
                        i+=2
                    else:
                        formula.insert(i+1,"1")
                        i+=1
            elif formula[i] in self.diccionario.keys():
                if formula[i+1].isupper():
                    formula.insert(i+1,"1")
                    i+=1
                elif formula[i+1].islower() and len(formula[i+1]) == 1:
                    formula.insert(i+1,"1")
                    i+=3
            elif formula[i].isalpha() and formula[i+1] in self.diccionario.keys():
                if not formula[i-1].isdigit():
                    formula.insert(i,"1")
                i+=1
            elif formula[i].isdigit() and formula[i+1].isupper():
                i+=1
            i+=1
        formula.pop(); return formula
        # print ("".join(formula))[-1::-1]
        
    def process(self,formula):
        fix = []; i = 0
        while i < len(formula)-1:
            if len(formula) == 2:
                if formula[0].islower() and formula[1].isupper():
                    return [1,formula[1]+formula[0]]
                else: return formula
            elif i == 0 and formula[i].isalpha():
                fix.append("1"); fix.append(formula[i])
            elif formula[i].isdigit() and formula[i+1].isdigit():
                fix.append(str(formula[i+1])+str(formula[i]))
                i+=1
            elif formula[i].islower() and formula[i+1].isupper():
                fix.append(formula[i+1] + formula[i])
                i+=1
            else: fix.append(formula[i])
            i+=1
        fix.append(formula[-1])
        formula = fix
        for i in range(len(formula)): 
            if formula[i].isdigit(): formula[i] = int(formula[i])
        counter = 0; aux = 0; ctrl = len(formula)
        sigqueue = []; valsqueue = []
        while counter < ctrl:
            if type(formula[counter]) == int:
                if formula[counter+1] in self.diccionario.values():
                    aux = counter+2
                    sigqueue.append(formula[counter+1])
                    valsqueue.append(formula[counter])
                    while True:
                        if type(formula[aux]) == int:
                            formula[aux]*=valsqueue[-1]
                        elif formula[aux] in self.diccionario.keys():
                            sigqueue.pop()
                            valsqueue.pop()
                            if not sigqueue:break
                        elif formula[aux] in self.diccionario.values():
                            valsqueue.append(formula[aux-1])
                            sigqueue.append(formula[aux])
                            formula[aux-1] = 1
                        aux+=1
                    formula[counter] = 1
                    counter = aux-2
            counter+=1
        return formula
        #print "".join(map(str,formula[-1::-1]))
                    
    def process2(self,formula,dic):
        if len(formula) == 1:
            if formula[0] in dic.keys():
                dic[formula[0]]+=1
            else:
                dic[formula[0]] = 1
                return 
        for i in range(len(formula)-1):
            if (str(formula[i])).isdigit() and (str(formula[i+1])).isalpha():
                if formula[i+1] in dic.keys():
                    dic[formula[i+1]]+= formula[i]
                else:
                    dic[formula[i+1]] = int(formula[i])
        
    def along(self):
        dictio = {}
        if type(self.formula) == str:
            self.formula = list(self.formula)
            self.formula = self.normalize(self.formula)
            self.formula = self.process(self.formula)
            self.process2(self.formula,dictio)
        else:
            for i in range(len(self.formula)):
                self.formula[i] = list(self.formula[i])
                self.formula[i] = self.normalize(self.formula[i])
                self.formula[i] = self.process(self.formula[i])
                self.process2(self.formula[i],dictio)
        return dictio

    def show(self):
        print self.formula

    
def parse_molecule(formula):
    iformula = formula[-1::-1]
    formula = Preprocess(iformula)
    formula.split_formula()
    result = formula.along()
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
russh

import re
import string
def parse_molecule (formula):
    d = {}
    elements = []
    final = []
    numbers = string.digits
    formula = formula.replace('[', '(')
    formula = formula.replace(']', ')')
    formula = formula.replace('{', '(')
    formula = formula.replace('}', ')')
    new = re.split(r'([A-Z][a-z]*\d*)', formula)
    closer = ')'
    opener = '('
    for index, item in enumerate(new):
        if any(char == closer for char in item):
            b = item
            new.pop(index)
            for a in b[::-1]:
                new.insert(index, a)
    work = new[::-1]
    multipliers = [1]
    for index, value in enumerate(work):
        if value.isdigit():
            multipliers.append(int(value))
        elif value == opener:
            multipliers.pop()
        elif any(x in [opener, closer] for x in value) != True and value != '':
            elements.extend([value]*multiplier(multipliers))
    for item in elements:
        if any(char.isdigit() for char in item):
            final.extend(parser(item))
        else:
            final.append(item)
    for item in final:
        if item not in d:
            d[item] = final.count(item)
    return d


def parser(x):
    numbers = string.digits
    if any(char.isdigit() for char in x):
        factor = 1
        atom = ''
        for index, char in enumerate(x):
            if char not in numbers:
                atom += char
                x = x.replace(char, '')
        factor *= int(x)
        return [atom] * factor
    else:
        return x


def multiplier(multipliers):
    if multipliers:
        return int(reduce(lambda x,y: x*y, multipliers))
    else:
        return 1
Best Practices0Clever0
0ForkCompare with your solutionLink
smile67

def parse_molecule (formula):
    stack=[]; num=""; sym=""
    formula="("+formula.replace("{","(").replace("}",")").replace("[","(").replace("]",")")+")"
    for c in formula:
       cU=c.upper()
       if c>='0' and c<='9': #build numbers
          if len(sym)>0: stack.append(sym); sym=""
          num+=c
       elif cU >='A' and cU<='Z': #build atom names
          f=0
          if len(num)>0: stack.append(int(num)); num=""; f=1
          if c==cU and len(sym)>0:
             stack.append(sym); sym="" 
             if f==0: stack.append(1)
          sym+=c
       else:  #handle brackets
          if len(sym)>0: 
             stack.append(sym); sym=""; stack.append(1)
          elif len(num)>0: n=int(num); stack.append(n); num=""
          stack.append(c) 
    res=calcStack(stack)
    return res


def calcStack(s):
    r={}
    while s.count("(")>1:
      sp=len(s)-1
      while s[sp]==")" and sp>0: sp-=1
      n=s[sp]; br=0
      for i in range(sp-1,-1,-1):
        if type(s[i])==int and br==1: s[i]*=n
        elif s[i]!=")" and s[i]!="(":
           if br==0:
               if s[i] in r: r[s[i]]+=s[i+1]
               else: r[s[i]]=s[i+1]
               del(s[sp+1]); del(s[sp]); del(s[i])
               if type(s[i-1])!=int: s.append(1)
               s.append(")"); break
        elif s[i]==")": br+=1
        elif s[i]=="(": br-=1
        if br==0: del(s[sp+1]); del(s[sp]); del(s[i]); break  
    del(s[-1]); del(s[0])
    for i in range(0,len(s),2):
       if s[i] in r: r[s[i]]+=s[i+1]
       else: r[s[i]]=s[i+1]
    return r
Best Practices0Clever0
0ForkCompare with your solutionLink
jbehley

import re

def remove_brackets(formula, level):
    """ remove brackets by multiplying the 
        atoms with multiplicity of the bracket. """
    pattern = ["\(([A-za-z0-9]*)\)([1-9]*)", 
               "\[([A-za-z0-9]*)\]([1-9]*)", 
               "\{([A-za-z0-9]*)\}([1-9]*)"]

    atom_pattern = re.compile("([A-Z][a-z]*)([0-9]*)")
    result = re.search(pattern[level], formula)
    
    while result != None:
        inside = result.group(1)
        multiplicity = result.group(2)
        if multiplicity == '' or multiplicity is None: multiplicity = 1
            
        atoms = [list(item) for item in atom_pattern.findall(inside)]
        for atom in atoms:
            if(atom[1] == ''): atom[1] = 1
            atom[1] = int(atom[1])
            atom[1] *= int(multiplicity)
                
        new_part = "".join([str(a[0])+str(a[1]) for a in atoms])
        formula = formula.replace(result.group(0), new_part)
        
        # next brackets...
        result = re.search(pattern[level], formula)
        
    return formula
    
    
def parse_molecule (formula):
    formula = remove_brackets(formula, 0)
    formula = remove_brackets(formula, 1)
    formula = remove_brackets(formula, 2)
    
    # now all brackets should be eliminated...
    atom_dict = {}
    atom_pattern = re.compile("([A-Z][a-z]*)([0-9]*)")
    # count atoms.
    atoms = atom_pattern.findall(formula)
    

    for match in atoms:
        count = 1
        if match[1] != '': count = int(match[1])
        if not atom_dict.has_key(match[0]): atom_dict[match[0]] = 0
        atom_dict[match[0]] += count
        
    return atom_dict
Best Practices0Clever0
0ForkCompare with your solutionLink
RevansChen

import re
brackets_re_dict = {'(' : '\(.+?\)',
                    '[' : '\[.+?\]',
                    '{' : '\{.+?\}'}
atom_re = "[A-Z][a-z]*"

def parse_molecule(formula):
    isLeftBracket = formula[0] in brackets_re_dict
    brackets_re = brackets_re_dict[formula[0]] if isLeftBracket else None
    m = re.match('%s\d*' % (brackets_re if isLeftBracket else atom_re), formula)
    if m.end() < len(formula):
        return dictAdd(parse_molecule(formula[:m.end()]), parse_molecule(formula[m.end():]))
    
    if isLeftBracket:
        m = re.match(brackets_re, formula)
        atoms = parse_molecule(formula[1 : m.end() - 1])
        return atoms if m.end() == len(formula) else dictMul(atoms, int(formula[m.end():]))
        
    m = re.match(atom_re, formula)
    num = 1 if m.end() == len(formula) else int(formula[m.end():])
    return {m.group(0) : num}

def dictAdd(d1, d2):
    for k, v in d2.items():
        d1[k] = d1[k] + v if k in d1 else v
    return d1

def dictMul(d, num):
    return {k: d[k] * num for k in d}
Best Practices0Clever0
0ForkCompare with your solutionLink
RevansChen

import re
brackets_re = {'(' : '\(.+?\)',
               '[' : '\[.+?\]',
               '{' : '\{.+?\}'}
atom_re = "[A-Z][a-z]*"

def parse_molecule(formula):
    print(formula)
    isLeftBracket = formula[0] in brackets_re
    m = re.match('%s\d*' % brackets_re[formula[0]], formula) if isLeftBracket else re.match('%s\d*' % atom_re, formula)
    if m.end() < len(formula):
        return dictAdd(parse_molecule(formula[:m.end()]), parse_molecule(formula[m.end():]))
    
    if isLeftBracket:
        m = re.match(brackets_re[formula[0]], formula)
        inner_formula = formula[1 : m.end() - 1]
        atoms = parse_molecule(inner_formula)
        return atoms if m.end() == len(formula) else dictMul(atoms, int(formula[m.end():]))
        
    
    m = re.match(atom_re, formula)
    num = 1 if m.end() == len(formula) else int(formula[m.end():])
    return {m.group(0) : num}

def dictAdd(d1, d2):
    for k, v in d2.items():
        d1[k] = d1[k] + v if k in d1 else v
    return d1

def dictMul(d, num):
    return {k: d[k] * num for k in d}
Best Practices0Clever0
0ForkCompare with your solutionLink
Soirana

def debracket (formula):
    smalld = {"(":")", "{":"}", "[":"]"}
    while True:
        checkstr = formula[0:]
        multip = 1
        a= len(formula)
        breaker = False
        for i in range (0, a-1):
            if formula[i] in smalld:
                for j in range (i+1, a):
                    if formula[j] == smalld[formula[i]]:
                        if j!= len(formula) - 1:
                            for k in range (j+1, a):
                                if formula[j+1:k+1].isdigit():
                                    multip = int(formula[j+1:k+1])
                                else: break
                            if multip > 1:
                                formula = formula + formula[i+1:j]*(multip-1)
                            for k in range (j+1, a):
                                if formula[j+1:k+1] == str(multip):
                                    formula = formula[:j+1] + formula [k+1:]                                
                        formula = formula [0:i]+formula[i+1:j]+formula[j+1:]
                        breaker = True
                        break
            if breaker: break
        if checkstr == formula: break                      
    return formula

def counter (formula, diction):
    if not formula[-1].isdigit():
        formula = formula + "1"
    for i in range (1, len(formula)):
        if formula[i].isdigit():
            value = int(formula[i:])
            key = formula[:i]
            if key in diction:
                diction[key] = diction[key] + value
            else:
                diction[key] = value
            return diction

def stripper (formula, diction):
    
    if len(formula) == 1:
        diction = counter(formula, diction)
        formula = ""        
    for i in range (1, len(formula)):
        if formula[i].isupper():
            diction = counter(formula[:i], diction)
            formula = formula[i:]
            break
        if i == len(formula)-1:
            diction = counter(formula, diction)
            formula = ""
            break
    
    return formula, diction
    
def parse_molecule (formula):
    diction = {}
    formula = debracket(formula)
    while formula:
        formula, diction = stripper (formula, diction)
    return diction
Best Practices0Clever0
0ForkCompare with your solutionLink
breakfastpy

def parse_molecule (formula):
    oParen = {')':'(',']':'[','}':'{'}
    outList, outDict = [], {}
    while any(x.isdigit() for x in formula):
        for i,c in enumerate(formula):
            if c.isdigit():
                if i < len(formula)-1 and formula[i+1].isdigit():
                    num = int(formula[i:i+2])
                else:
                    num = int(c)
                item = formula[i-1]
                if item in ")]}":
                    j = i - 1
                    while formula[j] != oParen[item]:
                        j -= 1
                    item = formula[j:i]
                elif item.islower():
                    item = formula[i-2:i]
                formula = formula.replace(item+str(num),item*num)
                break
    for i in range(len(formula)-1,-1,-1):
        if formula[i].isupper():
            outList.append(formula[i:])
            formula = formula[:i]
        elif formula[i] in "()[]{}":
            formula = formula[:i]
    for item in outList:
        outDict[item] = outDict.get(item,0) + 1
    return outDict
Best Practices0Clever0
0ForkCompare with your solutionLink
makesmewanna

def parse_molecule (formula):
    result = {}
    inPt = False
    curr = ''
    innerGroup = ''
    waitForGroupNum = False
    startPt = ''
    ptDict = {'(':')', '[':']', '{':'}'}
    num = ''
    for s in formula:            
        if inPt:
            if s == ptDict[startPt]:
                waitForGroupNum = True
                inPt = False
            else:
                innerGroup = innerGroup + s
        elif s.isupper():
            if waitForGroupNum:
                if not num:
                    num = '1'
                result = merge_dict(result, parse_molecule(innerGroup), int(float(num)))
                innerGroup = ''
                startPt = ''
                waitForGroupNum = False
                num = ''
            elif curr:
                result = add_to_dict(result, curr, num)
                num = ''
            curr = s
        elif s.islower():
            curr = curr + s
        elif s.isdigit():
            num = num + s
        elif s in ptDict:
            if waitForGroupNum:
                if not num:
                    num = '1'
                result = merge_dict(result, parse_molecule(innerGroup), int(float(num)))
                innerGroup = ''
                startPt = ''
                waitForGroupNum = False
                num = ''
            inPt = True
            startPt = s
            if curr:
                result = add_to_dict(result, curr, num)
                num = ''
                curr = ''

    if curr:
        result = add_to_dict(result, curr, num)
    if waitForGroupNum:
        result = merge_dict(result, parse_molecule(innerGroup), int(float(num)))
    return result
    
    
def merge_dict(result, innerResult, groupNum):
    for key in innerResult:
        if key not in result:
            result[key] = 0
        result[key] += innerResult[key] * groupNum
    return result
    
def add_to_dict(result, curr, num):
    if curr not in result:
        result[curr] = 0
    if num:
        result[curr] += int(float(num))
    else:
        result[curr] += 1
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
shadikka

from collections import defaultdict
from itertools import takewhile

braces = {"(": ")", "[": "]", "{": "}"}

def parse_molecule(formula):
    # Empty case
    if not formula:
        return {}
    
    # Find the outermost (=first) opening brace
    brace_start = None
    brace_starts = filter(lambda x: x != -1, (formula.find(k) for k in braces.keys()))
    if brace_starts:
        brace_start = min(brace_starts)
    
    # If there was a brace
    if brace_start is not None:
        # Loop through the formula starting after the opening brace and find for the matching
        # closing brace. Keep track of the amount of relevant opening braces found due to nesting.
        brace = formula[brace_start]
        brace_end = None
        multiplier = ""
        found = 1  # The number of opening braces found
        for i, char in enumerate(formula[brace_start + 1:], brace_start + 1):
            # If we have found the correct closing brace, get the possible numerical multiplier
            if brace_end is not None:
                if char.isdigit():
                    multiplier += char
                else:
                    break
            # Otherwise just keep track of the braces
            elif char == brace:
                found += 1
            elif char == braces[brace]:
                found -= 1
                if found == 0:
                    brace_end = i
        
        # At this point we know the range of the subformula
        out = defaultdict(int)
        multiplier_len = len(multiplier)  # Needed for indexing
        multiplier = int(multiplier) if multiplier else 1
        subformula = formula[brace_start + 1:brace_end]
        
        # Recurse to the subformula
        for k, v in parse_molecule(subformula).items():
            out[k] += v * multiplier
        
        # Recurse to the rest of the formula
        formula = formula[0:brace_start] + formula[brace_end + multiplier_len + 1:]
        for k, v in parse_molecule(formula).items():
            out[k] += v
        return out
    
    # If no braces were found, parse the formula simply
    out = defaultdict(int)
    pieces = []
    
    # Split the formula into pieces with each piece starting with an uppercase letter
    buffer = ""
    for char in formula:
        if char.isupper():
            if buffer:
                pieces.append(buffer)
            buffer = ""
        buffer += char
    pieces.append(buffer)
    
    # Add each piece to the dictionary and return
    for piece in pieces:
        num = "".join(takewhile(str.isdigit, piece[::-1]))[::-1]
        num = int(num) if num else 1
        out["".join(takewhile(str.isalpha, piece))] += num
    return out
Best Practices0Clever0
0ForkCompare with your solutionLink
siskin1

import re

def parse_molecule (formula):
    if formula == '':
        return {}
    result = {}
    groups = re.findall(r'([A-Z][a-z]?|\[.*?\]|\(.*?\)|\{.*?\})([0-9]*)', formula)
    for element, number_string in groups:
        number = int(number_string) if number_string != '' else 1
        if element[0] == '[' or element[0] == '(' or element[0] == '{':
            mini_result = parse_molecule(element[1:-1])
        else:
            mini_result = {element: number}
            number = 1
        for element in mini_result:
            if element not in result:
                result[element] = mini_result[element] * number
            else:
                result[element] += mini_result[element] * number
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
OmarHP

import re


def parse_molecule (formula):
    formula=re.findall("[A-Z]{1}[a-z]*|[0-9]+|\(|\)|\[|\]|\{|\}",formula)
    formula=[int(x) if x.isdigit() else x for x in formula]   
    
    from string import maketrans 
    trans= maketrans("([]){}", ")][(}{")
    
    aux=[]
    for x in xrange(len(formula)):
        if x==len(formula)-1:
            aux.append(formula[x])
            if not isinstance(formula[x], int) and formula[x].isalpha():
                aux.append(1)
        else:
            aux.append(formula[x])
            if not isinstance(formula[x], int) and formula[x].isalpha() and not isinstance(formula[x+1],int):
                aux.append(1)
    formula=aux    
    stack=[]
    drop=True;
    m=None
    c=None
    while len(formula)>0 or c!=None:
        if drop==True:
            current=formula.pop(0)
            if current in [")","]","}"]:
                drop=False;
                c=current
                m=1
                if formula and isinstance(formula[0], int):
                    m=formula.pop(0)
            else:
                stack.insert(0,current)
        else:
            current=stack.pop(0)
            if current==c.translate(trans):
                c=None
                drop=True
            else:
                if isinstance(current, int):
                    formula.insert(0, current*m)
                else:
                    formula.insert(0, current)
    stack= stack[::-1]    
    result=dict()
    for x in xrange(0,len(stack),2):
        if result.has_key(stack[x]):
            result[stack[x]]+=stack[x+1]
        else:
            result[stack[x]]=stack[x+1]
    return result
        
    
    
        
                
Best Practices0Clever0
0ForkCompare with your solutionLink
Marnemissile

import re
def parse_molecule (formula):
    f = formula
    f = re.sub('[\[\{]', '(', f)
    f = re.sub('[\]\}]', ')', f)
    n = len(f)
    a = []
    i = 0
    while i < n:
        if f[i].isupper():
            a.append(f[i])
            i += 1
        elif f[i].islower():
            a[-1] += f[i]
            i += 1
        elif f[i].isdigit():
            val = 0
            while i < n and f[i].isdigit():
                val = val * 10 + ord(f[i]) - ord('0')
                i += 1
            a.append(val)
        else:
            a.append(f[i])
            i += 1
    res = [{}]
    n = len(a)
    i = 0
    while i < n:
        if re.match(r'^[A-Z][a-z]?$', a[i]):
            elem = a[i]
            if i + 1 < n and isinstance(a[i + 1], int):
                stuff = a[i + 1]
                i += 2
            else:
                stuff = 1
                i += 1
            if not elem in res[-1]:
                res[-1][elem] = stuff
            else:
                res[-1][elem] += stuff
        elif a[i] == '(':
            res.append({})
            i += 1
        elif a[i] == ')':
            if i + 1 < n and isinstance(a[i + 1], int):
                stuff = a[i + 1]
                i += 2
            else:
                stuff = 1
                i += 1
            for k in res[-1]:
                if not k in res[-2]:
                    res[-2][k] = stuff * res[-1][k]
                else:
                    res[-2][k] += stuff * res[-1][k]
            res.pop()
    return res.pop()
Best Practices0Clever0
0ForkCompare with your solutionLink
dietmar

import re
def parse_molecule (formula):
    while True:
        m = re.search(r'[({[]([A-Za-z0-9]+)[)}\]](\d+)?', formula)
        if m is None:
            break
        if m.group(2):
            factor = int(m.group(2))    
        else:
            factor = 1
        prefix = formula[:m.start()]
        inner = m.group(1) * factor
        postfix = formula[m.end():]
        formula = prefix + inner + postfix

    result = {}
    for m in re.finditer(r'([A-Z][a-z]?)(\d+)?', formula):
        elem = m.group(1)
        if m.group(2):
            count = int(m.group(2))
        else:
            count = 1
        if elem in result:
            result[elem] += count
        else:
            result[elem] = count
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
auroralinan

def parse_molecule(formula):
    f = []
    number_mark = False
    for i in formula:
        if ord(i)<58 and ord(i)>47:
            number_mark = True
        else:
            if number_mark:
                num = 0
                lam = 0
                while 1:
                    x = f.pop()
                    if ord(x)<58 and ord(x)>47:
                        num += (10**lam) * int(x)
                        lam += 1
                    else:
                        f.append(x)
                        f.append(str(num))
                        number_mark = False
                        break
        f.append(i)
    molecule = {}
    queue = []
    for i in f:
    # number, uppercase, lowercase, brackets
        try:
            ascii = ord(i)
        except:
            ascii = None
        if ascii == 91 or ascii == 40 or ascii == 123:
            # left brackets
            queue.append(i)
        elif ascii < 91 and ascii > 64:
            # uppercase
            queue.append([i, 1])
        elif ascii < 123 and ascii > 96:
            # lowercase
            queue[-1] = [queue[-1][0] + i, queue[-1][1]]
        elif ascii == 93 or ascii == 41 or ascii == 125:
            # right brackets
            queue.append(i)
        else:
            # number
            if isinstance(queue[-1], list):
                queue[-1][1] *= int(i)
            else:
                lst = []
                queue.pop()
                bracket_mark = 1
                while bracket_mark > 0:
                    char = queue.pop()
                    if isinstance(char, list):
                        char[1] *= int(i)
                        lst.append(char)
                    elif char == '(' or char == '[' or char == '{':
                        bracket_mark -= 1
                    else:
                        bracket_mark += 1
                queue.extend(lst[::-1])
    for i in queue:
        if i == "(" or i == ")" or i == "[" or i == "]" or i == "{" or i == "}":
            continue
        try:
            molecule[i[0]] += i[1]
        except:
            molecule[i[0]] = i[1]
    return molecule
Best Practices0Clever0
0ForkCompare with your solutionLink
TomekG

import re

def parse_molecule (formula):
    result = {}
    groups = re.findall('[A-Z][a-z]*', formula)
    for mole in groups: result.update(parse_one_molecule(mole, formula))    
    return result
    
def parse_one_molecule(mole, formula):        
    tmp = re.sub('[\{|\[]', '(', formula)
    tmp = re.sub('[\}|\]]', ')', tmp)
    tmp = re.sub('(\d+)', '*\\1' , tmp)
    tmp = re.sub('(\))([A-Z])', '\\1+\\2' , tmp)
    tmp = re.sub('(.)(\()', '\\1+\\2' , tmp)
    tmp = re.sub('([A-Z0-9]{1})([A-Z]{1})', '\\1+\\2' , tmp)
    tmp = re.sub('([A-Z]{1})([^0-9a-z])', '\\1*1\\2' , tmp)
    tmp = re.sub('(\d+)([A-Z])', '\\1+\\2' , tmp)         
    tmp = re.sub(mole+'[a-z]+', '0' , tmp)        
    tmp = re.sub(mole, '1' , tmp)    
    tmp = re.sub('[a-zA-Z]+', '0' , tmp)                
    return {mole: eval(tmp)}
Best Practices0Clever0
0ForkCompare with your solutionLink
lymanchou

import re
def parse_molecule (formula):
    d={}
    p0=re.compile('(\{.+?\})(\d*)')
    l=re.findall(p0,formula)
    if l!=[]:
        for i in l:
            n=1
            if i[1]!='':
                n=int(i[1])
            dd=parse_molecule(str(i[0][1:-1]))
            for j in dd.keys():
                d[j]=d.get(j,0)+dd.get(j)*n
        formula=re.sub(p0,'',formula)   
    p1=re.compile('(\[.+?\])(\d*)')
    l=re.findall(p1,formula)
    if l!=[]:
        for i in l:
            n=1
            if i[1]!='':
                n=int(i[1])
            dd=parse_molecule(str(i[0][1:-1]))
            for j in dd.keys():
                d[j]=d.get(j,0)+dd.get(j)*n
        formula=re.sub(p1,'',formula)     
    p2=re.compile('(\(.+?\))(\d*)')
    l=re.findall(p2,formula)
    if l!=[]:
        for i in l:
            n=1
            if i[1]!='':
                n=int(i[1])
            dd=parse_molecule(i[0][1:-1])
            for j in dd.keys():
                d[j]=d.get(j,0)+dd.get(j)*n
        formula=re.sub(p2,'',formula)     
    p3=re.compile('([A-Z]+?[a-z]*)(\d*)')    
    l=re.findall(p3,formula)
    if l!=[]:
        for i in l:
            n=1
            if i[1]!='':
                n=int(i[1])
            d[i[0]]=d.get(i[0],0)+n
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
wandering_newfie

from pyparsing import (Suppress, Word, nums, alphas, Regex, Forward, Group, 
                        Optional, OneOrMore, ParseResults)
from collections import defaultdict

LPAR,RPAR = map(Suppress, "()")
LBRC,RBRC = map(Suppress, "{}")
LBKT,RBKT = map(Suppress, "[]")
integer = Word(nums)

# add parse action to convert integers to ints, to support doing addition 
# and multiplication at parse time
integer.setParseAction(lambda t:int(t[0]))

element = Word(alphas.upper(), alphas.lower())

# forward declare 'formula' so it can be used in definition of 'term'
formula = Forward()

term = Group((element | Group(LPAR + formula + RPAR)("subgroup")
                      | Group(LBRC + formula + RBRC)("subgroup")
                      | Group(LBKT + formula + RBKT)("subgroup")) + 
                Optional(integer, default=1)("mult"))

# define contents of a formula as one or more terms
formula << OneOrMore(term)

# add parse actions for parse-time processing

# parse action to multiply out subgroups
def multiplyContents(tokens):
    t = tokens[0]
    # if these tokens contain a subgroup, then use multiplier to
    # extend counts of all elements in the subgroup
    if t.subgroup:
        mult = t.mult
        for term in t.subgroup:
            term[1] *= mult
        return t.subgroup
term.setParseAction(multiplyContents)

# add parse action to sum up multiple references to the same element
def sumByElement(tokens):
    elementsList = [t[0] for t in tokens]

    # construct set to see if there are duplicates
    duplicates = len(elementsList) > len(set(elementsList))

    # if there are duplicate element names, sum up by element and
    # return a new nested ParseResults
    if duplicates:
        ctr = defaultdict(int)
        for t in tokens:
            ctr[t[0]] += t[1]
        return ParseResults([ParseResults([k,v]) for k,v in ctr.items()])
formula.setParseAction(sumByElement)

def parse_molecule (f):
    results = formula.parseString(f)
    print f, '->', dict(results.asList())
    return dict(results.asList())
Best Practices0Clever0
0ForkCompare with your solutionLink
hobbez1

def parse_molecule (formula):
    newstring = []
    elements = []
    for x in formula:
        if x in [']',')','}']:
            if len(newstring) > 1 and '+' in newstring[-1]:
               newstring.append(newstring.pop().rstrip('+'))
            newstring.append(')+')
        elif x in ['[','(','{']:
            newstring.append('(')
        elif x.isdigit():
            previous = newstring.pop().rstrip('+')
            if '*' in previous:
                newstring.append("%s%s+"%(previous,x))
            else:
                newstring.append("%s*%s+"%(previous,x))
        elif x.upper() == x:
            newstring.append('"%s"+'%x)
            elements.append(x)
        else:
            previous = newstring.pop().rstrip('"+')
            newstring.append('%s%s"+'%(previous,x))
            previous = elements.pop()
            elements.append('%s%s'%(previous,x))
    retval = {}
    elements = list(set(elements))
    newstring = ''.join(newstring).rstrip('+')
    molstring = str(eval(newstring))
    for ee in sorted(elements)[::-1]:
        retval[ee] = molstring.count(ee)
        molstring = molstring.replace(ee, '')
    return retval
Best Practices0Clever0
0ForkCompare with your solutionLink
gavlynch

def parse_molecule (formula):
    ind = 0
    atoms = {}
    while ind < len(formula):
        new_atoms,ind = read_atoms(formula, ind)
        num,ind = read_number(formula, ind)
        for k,v in new_atoms.iteritems():
            atoms[k] = (atoms[k] if k in atoms else 0) + num*v
    return atoms

def read_atoms(formula, ind):
    bracket_map = {"{": "}", "[": "]", "(": ")"};
    if formula[ind] in bracket_map:
        start_bracket = formula[ind]
        end_bracket = bracket_map[start_bracket]
        ind2 = ind + 1
        bracket_cnt = 1
        while 1 == 1:  # find the matching end bracket
            if formula[ind2] == start_bracket:
                bracket_cnt += 1
            elif formula[ind2] == end_bracket:
                bracket_cnt -= 1
                if bracket_cnt == 0:
                    break
            ind2 += 1
        return parse_molecule(formula[ind+1:ind2]), ind2+1
    else:
        a = formula[ind];
        ind += 1;
        while ind < len(formula) and formula[ind] != formula[ind].upper():
            a += formula[ind]
            ind += 1
        return {a: 1}, ind
        
def read_number(formula, ind):
    num = None
    while ind < len(formula) and '0' <= formula[ind] and '9' >= formula[ind]:
        num = (0 if num is None else num*10) + int(formula[ind])
        ind += 1
    return (1 if num is None else num),ind
        
Best Practices0Clever0
0ForkCompare with your solutionLink
SakuraSa

import re

SP = re.compile(r'[A-Z][a-z]*|\d+|\(|\)|\[|\]|{|}')


def combine(a, b):
    s = dict(a)
    for k, v in b.iteritems():
        s[k] = s.get(k, 0) + v
    return s


def scalar(d, s):
    for k in d:
        d[k] *= s


def counter(parts, jumps, head, tail):
    sequence = []
    i = head
    while i <= tail:
        c = parts[i]
        if c.isalpha():
            sequence.append({c: 1})
        elif c.isalnum():
            scalar(sequence[-1], int(c))
        elif c in '([{':
            jump_to = jumps[i]
            sequence.append(counter(parts, jumps, i + 1, jump_to))
            i = jump_to + 1
            continue
        i += 1
    answer = reduce(combine, sequence)
    # print ''.join(parts[head:tail]), answer
    return answer


def parse_molecule(formula):
    parts = SP.findall(formula)
    jumps = {}
    stack = []
    for i, c in enumerate(parts):
        if c in '([{':
            stack.append(i)
        elif c in ')]}':
            prev = stack.pop()
            jumps[i] = prev
            jumps[prev] = i
    return counter(parts, jumps, 0, len(parts) - 1)
Best Practices0Clever0
0ForkCompare with your solutionLink
bartix1

from collections import Counter
import re

bracers = {'(': ')', '[': ']', '{': '}'}

def change_formula(formula, bracer):
    wrong, end, x, times = 0, 0, 0, 1
    for i, sign in enumerate(formula):
        if sign in bracers.keys(): wrong+=1
        elif sign in bracers.values() and wrong: wrong -= 1
        elif sign == bracers[bracer]: end = i; break
    mult = re.match(r'[0-9]+', formula[end+1])
    if mult:
        x, times = mult.end(), int(mult.group())
    return (formula[:end]) * times + formula[end+1 + x:]

def checkMult(formula):
    x = re.search(r'[0-9]+', formula)
    return [formula] if not x else [formula[:x.start()]] * int(x.group())

def parse_molecule (formula):
    start, i = 0, 0
    fin = []
    while i < len(formula):
        if formula[i] in bracers.keys():
            if start != i:
                fin += checkMult(formula[start:i])
            formula = formula[:i] + change_formula(formula[i+1:], formula[i])
            start = i
            i -= 1
        elif formula[i].isupper() and start != i:
            fin += checkMult(formula[start:i])
            start = i
        i+=1
    fin += checkMult(formula[start:i])
    return dict(Counter(fin).most_common())
Best Practices0Clever0
0ForkCompare with your solutionLink
AbnerZheng

def parse_molecule(formula):
    def consume(f):
        return (f[0], f[1:])

    def deale(head, formula, result):
        while len(formula):
            (head, formula) = consume(formula)
            if(head in param_pairs.values()):
                formula = head + formula
                break
            if head in param_pairs:
                (r, formula) = helper(head, formula, {})  # 
                for e in r:
                    if e in result:
                        result[e] += r[e]
                    else:
                        result[e] = r[e]
            elif head.isupper():  # 
                name = head
                while (len(formula) and formula[0].islower()):
                    name += formula[0]
                    formula = formula[1:]
                if (len(formula) and formula[0].isdigit()):
                    multi = formula[0]
                    formula = formula[1:]
                    while (len(formula) and formula[0].isdigit()):
                        multi += formula[0]
                        formula = formula[1:]
                    multi = int(multi)
                else:
                    multi = 1
                if name in result:
                    result[name] = result[name] + multi
                else:
                    result[name] = multi
        return (result, formula)

    def helper(lParam, formula, result):
        (r, formula) = deale('', formula, {})
        (head, formula) = consume(formula)
        multi = 1
        if (head == param_pairs[lParam]):
            # 
            if (formula[0].isdigit()):
                multi = formula[0]
                formula = formula[1:]
                while len(formula) and formula[0].isdigit():
                    multi += formula[0]
                    formula = formula[1:]
                multi = int(multi)
            else:
                multi = 1
        for e in r:
            if e in result:
                result[e] += r[e] * multi
            else:
                result[e] = r[e] * multi
        return (result, formula)

    param_pairs = {'(': ')', '[': ']', '{': '}'}  # param = param_pairs.keys()


    return deale('', formula, {})[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
Gerrit-K

def find_closing_bracket(string, index):
    bracket = string[index]
    closing_bracket = find_closing_bracket.closing_brackets[bracket]

    j = index + 1
    count = 1
    while j < len(string) and count > 0:
        if string[j] == bracket:
            count += 1
        elif string[j] == closing_bracket:
            count -= 1
        j += 1
    return j

find_closing_bracket.closing_brackets = {
    '(': ')',
    '[': ']',
    '{': '}'
}


def parse_molecule(formula):
    if formula == '':
        return {}

    components = {}

    i = 0
    while i < len(formula):
        if formula[i] in '([{':
            j = find_closing_bracket(formula, i)

            # parse substring
            sub_components = parse_molecule(formula[i+1:j-1])
        elif formula[i].isupper():
            # parse atom
            j = i + 1
            while j < len(formula) and formula[j].islower():
                j += 1
            sub_components = {formula[i:j]: 1}

        i = j

        # parse factor
        while j < len(formula) and formula[j].isdigit():
            j += 1
        if formula[i:j] != '':
            factor = int(formula[i:j])
        else:
            factor = 1

        # merge sub_components into components
        for k in sub_components.keys():
            components[k] = components.get(k, 0) + factor * sub_components[k]

        i = j
    return components
Best Practices0Clever0
0ForkCompare with your solutionLink
coralv

import re

def replace_w_re(regex_obj, string):
    '''
     Analyzes a string based on the regex_obj to look for a type of bracket
     Returns the contents of the brackets repeated as many times
     as the following subscript indicates (min of 1)
    '''
    nums_regex = re.compile(r'(\d+)$')
    match_obj = regex_obj.search(string)
    result = match_obj.group()
    if nums_regex.search(result):
        num_obj = nums_regex.search(result)
        subscript = int(num_obj.group())
        result = result[:-1]
        if result[-1] in '0123456789':
            result = result[:-1]
        return result[1:-1] * subscript
        # using [1:-1] strips away the brackets
    else:
        return result[1:-1]


def parse_molecule (formula):
    '''
     Parses a chemical formula, and returns a dictionary with the
     elements as keys and the number of occurances of each element
     as the respective values
    '''
    # This regex matches any element followed by 0 or more subscripts
    elems_with_nums_regex = re.compile(r'[A-Z][a-z]*[a-z]*\d*')
    
    # This regex matches only the element
    elems_regex = re.compile(r'[A-Z][a-z]*[a-z]*')

    # This regex matches only subscripts
    nums_regex = re.compile(r'\d+')
    
    # The follow regexs match pairs of brackets (round, square, and curly
    # respectively), everything inside them, and 0 or more following
    # subscripts
    r_brackets_regex = re.compile(r'\([^\(]*\)\d*')
    s_brackets_regex = re.compile(r'\[[^\[]*\]\d*')
    c_brackets_regex = re.compile(r'\{[^\{]*\}\d*')
    
    # This loop continues until all brackets have been removed
    while c_brackets_regex.search(formula) or s_brackets_regex.search(formula) or r_brackets_regex.search(formula):
        if c_brackets_regex.search(formula):
            formula = c_brackets_regex.sub(replace_w_re(c_brackets_regex, formula), formula, count=1)
        if s_brackets_regex.search(formula):
            formula = s_brackets_regex.sub(replace_w_re(s_brackets_regex, formula), formula, count=1)
        if r_brackets_regex.search(formula):
            formula = r_brackets_regex.sub(replace_w_re(r_brackets_regex, formula), formula, count=1)
    
    answer = {}
    for item in elems_with_nums_regex.finditer(formula):
        elem = item.group()
        elem_obj = elems_regex.search(elem)
        if elem_obj.group() not in answer:
            # sets dictionary keys with default values
            answer[elem_obj.group()] = 0
        if nums_regex.search(elem):
            if elem[-2] in '0123456789':
                answer[elem[:-2]] += int(elem[-2:])
            else:
                answer[elem[:-1]] += int(elem[-1])
        else:
            answer[elem] += 1
            
    return answer
Best Practices0Clever0
0ForkCompare with your solutionLink
hardkun

import re
#changes empty string go to 1 and anything else converts to integer
chem_num = lambda x: 1 if len(x)==0 else int(x)
#union of dictionaries with summing up values
union_dicts = lambda dic1,dic2:dict((i,dic1[i]+dic2[i]) if (i in dic1)and(i in dic2) else (i,dic1[i]) if (i in dic1) else (i,dic2[i]) if (i in dic2) else None for i in set(dic1).union(set(dic2)))
#multiplying values by all keys by const
const_multip_dicts = lambda dic,const: dict((i,const*dic[i]) for i in dic)
def parse_molecule(formula): 
  res = {}
  last_len=0
  for match in re.finditer(r'\{(.+?)\}(\d*)',formula):
    res=union_dicts(res,const_multip_dicts(parse_molecule(match.group(1)),chem_num(match.group(2))))
    formula=formula[:match.start()-last_len]+formula[match.end()-last_len:]
    last_len+=match.end()-match.start()
  last_len=0
  for match in re.finditer(r'\[(.+?)\](\d*)',formula):
    res=union_dicts(res,const_multip_dicts(parse_molecule(match.group(1)),chem_num(match.group(2))))
    formula=formula[:match.start()-last_len]+formula[match.end()-last_len:]
    last_len+=match.end()-match.start()
  last_len=0
  for match in re.finditer(r'\((.+?)\)(\d*)',formula):
    res=union_dicts(res,const_multip_dicts(parse_molecule(match.group(1)),chem_num(match.group(2))))
    formula=formula[:match.start()-last_len]+formula[match.end()-last_len:]
    last_len+=match.end()-match.start()
  res = union_dicts(res,dict([(chem,chem_num(num)) for chem,num in re.findall(r'([A-Z][a-z]*)(\d*)',formula)]))
  return res
Best Practices0Clever0
0ForkCompare with your solutionLink
Zinth

import re
import string
num_pattern = r"(\d+)"
mol_pattern = r"([A-Z][a-z]?)" + num_pattern + "?"

def parse_molecule(formula):
  molecules, _ = parse_formula(formula)
  return molecules
  
def parse_formula(formula):
  molecules = {}
  i = 0
  while i < len(formula):
    c = formula[i]
    if c in string.ascii_uppercase:
      item, l = read_molecule(formula[i:])
      add_molecule_to(molecules, item)
      i += l
    elif c in '([{':
      group, l = read_group(formula[i:])
      add_molecules_to(molecules, group)
      i += l
    elif c in ')]}':
      i += 1
      break
    else:
      i += 1
  return (molecules, i)
  
def read_group(formula):
  molecules = {}
  l = 1
  group, l_g = parse_formula(formula[l:])
  l += l_g
  m = re.match(num_pattern, formula[l:])
  if m:
    num = int(m.group(1))
    multiply_molecules(group, num)
    l += m.end() - m.start() 
  add_molecules_to(molecules, group)
  return (molecules, l)
  
def read_molecule(formula):
  mol = ''
  num = 0
  l = 0
  m = re.match(mol_pattern, formula)
  if m:
    mol = m.group(1)
    if m.lastindex == 2:
      num = int(m.group(2))
    else:
      num = 1
    l = m.end() - m.start()
  return ((mol, num), l)
  
def add_molecules_to(molecules, adding):
  for item in adding.items():
    add_molecule_to(molecules, item)
    
def add_molecule_to(molecules, item):
  mol, num = item
  m = num
  if mol in molecules.keys():
    m += molecules[mol]
  molecules[mol] = m
  
def multiply_molecules(molecules, m):
  for key in molecules.keys():
    molecules[key] *= m
Best Practices0Clever0
0ForkCompare with your solutionLink
ecolban

upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lower = upper.lower()
digits = '0123456789'

def parse_molecule (formula):
    d, _ = parse_compound('(%s)' % formula, 0) 
    return d

def parse_compound(formula, pos):
    atoms = {}
    pos += 1
    while not formula[pos] in ')]}':
        d, pos = parse_next(formula, pos)
        for e in d:
            atoms[e] = atoms.get(e, 0) + d[e]
    return atoms, pos + 1

def parse_next(formula, pos):
    if formula[pos] in upper:
        atom, pos = parse_atom(formula, pos)
        atoms = {atom:1}
    elif formula[pos] in '([{':
        atoms, pos = parse_compound(formula, pos)
    if formula[pos] in digits:
        num, pos = parse_num(formula, pos)
        for e in atoms: atoms[e] *= num
    return atoms, pos

def parse_atom(formula, pos):
    a = formula[pos]
    pos += 1
    while formula[pos] in lower:
        a += formula[pos]
        pos += 1
    return a, pos

def parse_num(formula, pos):
    num_str = ''
    while formula[pos] in digits:
        num_str += formula[pos]
        pos += 1
    return int(num_str), pos

Best Practices0Clever0
0ForkCompare with your solutionLink
ecolban

upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lower = upper.lower()
digits = '0123456789'

def parse_molecule (formula):
    atoms = {}
    pos = 0
    while pos < len(formula):
        d, pos = parse_next(formula, pos)
        for e in d:
            atoms[e] = atoms.get(e, 0) + d[e]
    return atoms

def parse_next(formula, pos):
    atoms = {}
    if formula[pos] in upper:
        atom, pos = parse_atom(formula, pos)
        if pos < len(formula) and formula[pos] in digits:
            num, pos = parse_num(formula, pos)
            atoms[atom] = num
        else: atoms[atom] = 1
    elif formula[pos] in '([{':
        d, pos = parse_compound(formula, pos)
        if pos < len(formula) and formula[pos] in digits:
            num, pos = parse_num(formula, pos)
            for e in d: atoms[e] = d[e] * num
        else:
            for e in d: atoms[e] = d[e]
    return atoms, pos

def parse_atom(formula, pos):
    a = formula[pos]
    pos += 1
    while pos < len(formula) and formula[pos] in lower:
        a += formula[pos]
        pos += 1
    return a, pos

def parse_num(formula, pos):
    num_str = ''
    while pos < len(formula) and formula[pos] in digits:
        num_str += formula[pos]
        pos += 1
    return int(num_str), pos

def parse_compound(formula, pos):
    atoms = {}
    pos += 1
    while not formula[pos] in ')]}':
        d, pos = parse_next(formula, pos)
        for e in d:
            atoms[e] = atoms.get(e, 0) + d[e]
    return atoms, pos + 1
        
Best Practices0Clever0
0ForkCompare with your solutionLink
timfoden

import re

def parse_molecule (formula):
    tokens = re.findall('([A-Z][a-z]?|[0-9]+|[][{}()])', formula)
    stack = [{}]
    for tok, next in zip(tokens, tokens[1:] + ['.']):
        if tok.isalpha():
            incr( stack[-1], tok, int(next) if next.isdigit() else 1 )
        elif tok in '([{':
            stack.append( {} )
        elif tok in ')]}':
            merge( stack[-2], stack.pop(), int(next) if next.isdigit() else 1 )
    return stack[0]

def incr( chems, chem, count ):
    chems[chem] = chems.get(chem, 0) + count

def merge( chems1, chems2, mult ):
    for chem in chems2:
        incr( chems1, chem, chems2[chem] * mult)
Best Practices0Clever0
0ForkCompare with your solutionLink
timfoden

import re

def parse_molecule (formula):
    tokens = re.findall('([A-Z][a-z]?|[0-9]+|[][{}()])', formula)
    stack = [{}]
    for tok, next in zip(tokens, tokens[1:] + ['.']):
        if tok.isalpha():
            incr( stack[-1], tok, int(next) if next.isdigit() else 1 )
        elif tok in '([{':
            stack.append( {} )
        elif tok in ')]}':
            merge( stack[-2], stack.pop(), int(next) if next.isdigit() else 1 )
    return stack[0]

def incr( chems, chem, count ):
    if chem not in chems:
        chems[chem] = 0
    chems[chem] += count

def merge( chems1, chems2, mult ):
    for chem in chems2:
        incr( chems1, chem, chems2[chem] * mult)
Best Practices0Clever0
0ForkCompare with your solutionLink
eugene-katsevman

import re
from collections import Counter
def parse_molecule(m):
    tokens = re.findall(r'[\(\[\{\)\]\}]|[A-Z][a-z]*|\d+', m)
    stack = []
    for token in tokens:
        if token.isalpha() or token in '([{':
            stack.append([token])        
        elif token in ')]}':
            p = []
            while stack[-1] not in  [['('], ['['], ['{']]:
                p += stack.pop()             
            stack[-1] = p
            
        elif token.isdigit():
            stack[-1] = stack[-1] * int(token)
                
    return Counter(sum(stack,[]))
Best Practices0Clever0
0ForkCompare with your solutionLink
semleti

from collections import Counter

def parse_molecule (formula):
    dic = {}
    i = 0
    while(i < len(formula)):
        c = formula[i]
        if(c == '(' or c == '[' or c == '{'):
            brackets = 1
            j = 0
            while(brackets > 0):
                j += 1
                c2 = formula[i+j]
                if(c2 == '(' or c2 == '[' or c2 == '{'):
                    brackets += 1
                elif(c2 == ')' or c2 == ']' or c2 == '}'):
                    brackets -= 1
            k=1
            multiplier = 0
            if(i+j+k < len(formula)):
                c2 = formula[i+j+k]
                while(c2 >= '0' and c2 <= '9'):
                    multiplier = multiplier * 10 + (ord(c2) - ord('0'))
                    k += 1
                    if(i+j+k >= len(formula)):
                        break
                    c2 = formula[i+j+k]
            newDic = parse_molecule(formula[i+1:i+j])
            newDic.update((x, y* max(multiplier,1)) for x, y in newDic.items())
            dic = dict(Counter(dic) + Counter(newDic))
            i += j + k
        else:
            s = str(c)
            k=1
            if(i + 1 < len(formula)):
                c2 = formula[i + 1]
                if(c2 >= 'a' and c2 <= 'z'):
                    s += str(c2)
                    k += 1
            multiplier = 0
            if(i + k < len(formula)):
                c2 = formula[i+k]
                while(c2 >= '0' and c2 <= '9'):
                    multiplier = multiplier * 10 + (ord(c2) - ord('0'))
                    k += 1
                    if(i + k >= len(formula)):
                        break
                    c2 = formula[i+k]
            if(dic.has_key(s)):
                dic[s] += max(multiplier,1)
            else:
                dic[s] = max(multiplier,1)
            i += k
    return dic
Best Practices0Clever0
0ForkCompare with your solutionLink
sjtudesigner

import re

def parse_molecule (formula):
    res = {}
    regex = r"(?:([A-Z][a-z]*)|(\(.*?\)|\[.*?\]|{.*?}))([0-9]*)"
    parts = re.findall(regex, formula)
    for i, m in enumerate(parts):
        k = (int(m[2]) if m[2] else 1)
        if m[0]:
            res[m[0]] = res.get(m[0], 0) + k
        elif m[1]:
            add_dict(res, parse_molecule(m[1][1:-1]), k)
    return res
        
    
def add_dict(a, b, k):
    for key in b:
        a[key] = a.get(key, 0) + b[key] * k
Best Practices0Clever0
0ForkCompare with your solutionLink
lalala_

def function(str, koeff, result):
    str += ' '
    i = 0
    while str != ' ':
        if str[i+1].isdigit():
            if str[i+2].isdigit():
                if result.get(str[i]):
                    result[str[i]] += int(str[i+1:i+3]) * koeff
                else:
                    result[str[i]] = int(str[i+1:i+3]) * koeff
                str = str.replace(str[i:i+3], '')
            else:
                if result.get(str[i]):
                    result[str[i]] += int(str[i+1]) * koeff
                else:
                    result[str[i]] = int(str[i+1]) * koeff
                str = str.replace(str[i:i+2], '')
        elif str[i+1].isupper():
            if result.get(str[i]):
                result[str[i]] += koeff
            else:
                result[str[i]] = koeff
            str = str.replace(str[i:i+1], '')
        elif str[i+1].islower():
            if str[i+2].isdigit():
                if result.get(str[i:i+2]):
                    result[str[i:i+2]] += int(str[i+2]) * koeff
                else:
                    result[str[i:i+2]] = int(str[i+2]) * koeff
                str = str.replace(str[i:i+3], '')
            else:
                if result.get(str[i:i+2]):
                    result[str[i:i+2]] += koeff
                else:
                    result[str[i:i+2]] = koeff
                str = str.replace(str[i:i+2], '')
        else:
            if result.get(str[i:i+1]):
                result[str[i:i+1]] += koeff
            else:
                result[str[i:i+1]] = koeff
            str = str.replace(str[i:i+1], '')
    return result


def parse_molecule(formula):
    result = {}
    dict = {}
    add_dict = {}
    parse_string(formula, dict)
    for i in dict.iterkeys():
        if '(' in i:
            add_dict[i] = dict[i]
    for i in add_dict.iterkeys():
        del(dict[i])
        parse_string(i, dict, add_dict[i])
    for i in dict.iterkeys():
        function(i, dict[i], result)
    return result


def parse_string(formula, dict, add_koeff=1):
    koeff = 1 * add_koeff
    i = 0
    while formula.count('('):
        if formula[i] not in ['{', '[', '(']:
            i += 1
        else:
            if formula[i] == '{':
                a = formula.index('}')
                k = 1
                if formula[a+1].isdigit():
                    k = int(formula[a+1])
                    temp = formula.replace(formula[formula.index('{'):a+2], '')
                    dict[temp] = koeff
                else:
                    temp = formula.replace(formula[formula.index('{'):a+1], '')
                    dict[temp] = koeff
                formula = formula.replace(formula[:formula.index('{')+1], '')
                formula = formula.replace(formula[formula.index('}'):], '')
                koeff *= k
            if formula[i] == '[':
                a = formula.index(']')
                k = 1
                if formula[a+1].isdigit():
                    k = int(formula[a+1])
                    temp = formula.replace(formula[formula.index('['):a+2], '')
                    dict[temp] = koeff
                else:
                    temp = formula.replace(formula[formula.index('['):a+1], '')
                    dict[temp] = koeff
                formula = formula.replace(formula[:formula.index('[')+1], '')
                formula = formula.replace(formula[formula.index(']'):], '')
                koeff *= k
            if formula[i] == '(':
                a = formula.index(')')
                k = 1
                if formula[a+1].isdigit():
                    k = int(formula[a+1])
                    temp = formula.replace(formula[formula.index('('):a+2], '')
                    if dict.get(temp):
                        dict[temp] += koeff
                    else:
                        dict[temp] = koeff
                else:
                    temp = formula.replace(formula[formula.index('('):a+1], '')
                    dict[temp] = koeff
                formula = formula.replace(formula[:formula.index('(')+1], '')
                formula = formula.replace(formula[formula.index(')'):], '')
                koeff *= k
            i = 0
    dict[formula] = koeff
Best Practices0Clever0
0ForkCompare with your solutionLink
maqquettex

def atoms(x):
  formula = x[0]
  n = x[1]
  elements = {}
  #CALCULATING FREE-OF-BRACKETS FORMULA
  for i in range(len(formula)):
    if formula[i].islower() or formula[i].isdigit(): continue
    element = formula[i]
    if i+1<len(formula) and formula[i+1].islower(): 
      element = formula[i:i+2]
      i+=1
    num = 0
    while i+1<len(formula) and formula[i+1].isdigit():
      num *=10
      num+=int(formula[i+1])
      i+=1
    if num==0: num = 1
    if element in elements:
      elements[element] +=num
    else:
      elements[element] = num 
  for x in elements:
    elements[x]*=n
  return elements


def parse(formula):
  op = '[{('
  cl = ']})'
  flag = 1
  parts = []
  while flag:
    flag = 0
    for i in formula:
      if i in op:
        inds = formula.find(i)
        inde = formula.find(cl[op.index(i)])
        flag = 1
        break
    if not flag: break
    num = 0
    t = inde
    while t+1<len(formula) and formula[t+1].isdigit():
      num *=10
      num+=int(formula[t+1])
      t+=1
    if num==0: 
      num = 1
      lent = 0
    else:
      lent = len(str(num))
    parts.append([formula[inds+1:inde], num])
    formula = formula[:inds]+formula[inde+1+lent:]
  parts.append([formula, 1])
  for x in parts:
    if x[0] == '': parts.remove(x)
    if '[' in x[0] or '{' in x[0] or '(' in x[0]:
      parts.remove(x)
      n = x[1]
      y = parse(x[0])
      for i in y:
        i[1] *=n
        parts.append(i)

  return parts

def parse_molecule (formula):
  elements = {}
  parts = parse(formula)
  for x in parts:
    X = atoms(x)
    print X
    for y in X:
      if y in elements:
        elements[y] += X[y]
      else:
        elements[y] = X[y]
  return elements
Best Practices0Clever0
0ForkCompare with your solutionLink
dsmoker

from re import findall
from collections import Counter

def parse_molecule(formula):
    stack = [Counter()]
    for token in findall(r'([A-Z][a-z]*)([0-9]*)|([\(\{\[])|([\)\}\]])([0-9]*)', formula):
        if token[0]: # Atom name
            stack[-1][token[0]] += (int(token[1]) if token[1] else 1)
        elif token[2]: # Open bracket
            stack.append(Counter())
        elif token[3]: # Close bracket
            mult, last = int(token[4]) if token[4] else 1, stack.pop()
            stack[-1] += Counter(dict((atom, num*mult) for atom, num in last.iteritems()))
    return stack[-1]
Best Practices0Clever1
0ForkCompare with your solutionLink
sperry

from collections import Counter
def parse_molecule (formula):
  formula = formula[::-1]
  ats = []
  low_let = two_digit = ''
  num = 1
  factors = [1]
  for i in formula:
    if i.isdigit():
      two_digit += i
      num = int(two_digit[::-1])
    elif i.isalpha():
      if i.islower(): low_let = i
      else:
        ats.extend([i+low_let for j in range(num * factors[-1])])
        num = 1; two_digit = ''; low_let = ''
    elif i in [']', ')', '}']:
      factors.append(num * factors[-1])
      num = 1; two_digit = ''
    else:
      del factors[-1]           
  atoms = dict(Counter(ats))
  return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
Xavenir

import re

#Idea is to unfold K4[ON(SO3)2]2 to KKKKONSOOOSOOOONSOOOSOOO then count


def unfold(Eln):
    El=Eln.group('element')
    n=Eln.group('weight')

    wight = int(n) if n else 1
    element = El if El.isalpha() else El[1:-1]
    return element*wight


def parse_molecule (formula):
    unfoldedFml = re.sub(r'(?P<element>[A-Z][a-z]*)(?P<weight>\d+)',unfold,formula)
    while not unfoldedFml.isalpha():
        unfoldedFml = re.sub(r'(?P<element>[\(\[\{]([A-Z][a-z]*)+[\)\]\}])(?P<weight>\d?)',unfold,unfoldedFml)

    listUnfoFml = re.findall('[A-Z][a-z]*',unfoldedFml)
    elements = list(set(listUnfoFml))
    weights = [listUnfoFml.count(element) for element in elements]
    return dict(zip(elements,weights))
Best Practices0Clever0
0ForkCompare with your solutionLink
Xavenir

import re

def unfold(Eln):
    El=Eln.group('element')
    n=Eln.group('weight')

    #(AB)=(AB)1
    wight = int(n) if n else 1
    #(El)=El
    element = El if El.isalpha() else El[1:-1]

    return element*wight


def parse_molecule (formula):
    #H2=HH
    unfoldedFml = re.sub(r'(?P<element>[A-Z][a-z]*)(?P<weight>\d+)',unfold,formula)
    #(*)2=**, unfold brakets from inside
    while not unfoldedFml.isalpha():
        unfoldedFml = re.sub(r'(?P<element>[\(\[\{]([A-Z][a-z]*)+[\)\]\}])(?P<weight>\d?)',unfold,unfoldedFml)

    #count elements and their weights
    listUnfoFml = re.findall('[A-Z][a-z]*',unfoldedFml)
    elements = list(set(listUnfoFml))
    weights = [listUnfoFml.count(element) for element in elements]
    return dict(zip(elements,weights))
Best Practices0Clever0
0ForkCompare with your solutionLink
kumarrishianand

def parse_molecule (formula):
    out = {}
    br = {'[':']','(':')','{':'}'}
    brc = [']',')','}']
    ele =""
    mul = 1
    while len(formula)>0:
        if formula[0].isupper():
            if len(ele)>0:
                if ele in out:
                    out[ele] += mul
                else:
                    out[ele] = mul
            ele=formula[0]
            formula = formula[1:]
        elif formula[0].islower():
            ele+=formula[0]
            formula = formula[1:]
        elif ord(formula[0])>48 and ord(formula[0])<=57:
            num = int(formula[0])
            for i in range(1,len(formula)):
                if ord(formula[i])>=48 and ord(formula[i])<=57:
                    num = num*10+int(formula[i])
                else:
                    break
            if len(ele)>0:
                if ele in out:
                    out[ele] += mul*num
                else:
                    out[ele] = mul*num
            formula = formula[1:]
            ele=""
        elif formula[0] in br:
            if len(ele)>0:
                if ele in out:
                    out[ele] += mul
                else:
                    out[ele] = mul
                ele = ''
            for i in range(len(formula)):
                if formula[i] == br[formula[0]]:
                    if ord(formula[i+1])>48 and ord(formula[i+1])<=57:
                        mul *= int(formula[i+1])
                    break
            formula = formula[1:]
        elif formula[0] in brc:
            a = 1
            if len(ele)>0:
                if ele in out:
                    out[ele] += mul
                else:
                    out[ele] = mul
                ele = ''
            if ord(formula[1])>48 and ord(formula[1])<=57:
                num = int(formula[1])
                a = 2
                for i in range(2,len(formula)):
                    if ord(formula[i])>=48 and ord(formula[i])<=57:
                        num = num*10+int(formula[i])
                        a+=1
                    else:
                        break
                mul/=int(formula[1])
            formula = formula[a:]
    if len(ele)>0:
        if ele in out:
            out[ele] += mul
        else:
            out[ele] = mul
    return out
    pass
Best Practices0Clever0
0ForkCompare with your solutionLink
Alpri Else

def parse_molecule (formula):
    chem_lst = []
    num_lst = []
    eFormula = expandCoefficients(expand(formula))
    for x in range(0, len(eFormula)):
        currChem = ''
        if eFormula[x].isupper():
            if x < len(eFormula)-1 and eFormula[x+1].isupper() or x == len(eFormula)-1:
                currChem = eFormula[x]
                if currChem not in chem_lst:
                    chem_lst.append(currChem)
                    num_lst.append(1)
                else:
                    num_lst[chem_lst.index(currChem)] += 1
            else:
                currChem = eFormula[x:x+2]
                if currChem not in chem_lst:
                    chem_lst.append(currChem)
                    num_lst.append(1)
                else:
                    num_lst[chem_lst.index(currChem)] += 1
    return {chem_lst[x]: num_lst[x] for x in range(0,len(num_lst))}
    
def expand(formula):
    start = 0
    end = 0
    multi = 0
    type = -1
    for x in range(0, len(formula)):
        if formula[x] == '(':
            start = x
            type = 0
        if formula[x] == '[':
            start = x
            type = 1
        if formula[x] == '{':
            start = x
            type = 2
        if formula[x] == ')' or (formula[x] == ']' and type == 1) or (formula[x] == '}' and type == 2):
            end = x
            if formula[x + 1].isdigit():
                multi = int(formula[x + 1])
            else:
                multi = 1
            break;
    if multi == 1:
        new =formula[0:start] + formula[start + 1:end]*multi + formula[end+1:]
    else:
        new = formula[0:start] + formula[start + 1:end]*multi + formula[end+2:]
    if type == -1: return formula
    return expand(new)

def expandCoefficients(formula):
    chem = ''
    multi = -1
    start = -1
    end = -1
    for x in range(0, len(formula)):
        if formula[x].isdigit() and formula[x] != "e":
            if x != len(formula) - 1 and formula[x].isdigit() and formula[x+1].isdigit():
                multi = int(formula[x: x+2])
                end = x+1
            else:
                multi = int(formula[x])
                end = x
            if formula[x -1].isupper():
                chem = formula[x-1]
                start = x-1
            else:
                chem = formula[x-2:x]
                start = x-2
            break;    
    
    new = formula[0:start] + chem*multi + formula[end+1:]
    if multi == -1: return formula
    return expandCoefficients(new)
       
    
    
    
    
    
            
Best Practices0Clever0
0ForkCompare with your solutionLink
Etrnls

import string
m = {'(':')', '[':']', '{':'}'}
def parse_molecule (formula):
    r, i = {}, 0
    while i < len(formula):
        if formula[i] in m:
            j = i + formula[i:].find(m[formula[i]])
            t = parse_molecule(formula[i + 1:j])
            i = j + 1
        elif i + 1 < len(formula) and formula[i + 1] in string.lowercase:
            t = {formula[i:i + 2]: 1}
            i = i + 2
        else:
            t = {formula[i:i + 1]: 1}
            i = i + 1
        n = 0
        while i < len(formula) and formula[i] in string.digits:
            n = n * 10 + ord(formula[i]) - ord('0')
            i = i + 1
        if n == 0:    n = 1
        for k, v in t.iteritems():
            r[k] = r.get(k, 0) + t[k] * n
    return r
        
        
Best Practices0Clever0
0ForkCompare with your solutionLink
zoyanhui

bracket_begin = ["(", "[", "{"]
bracket_end = [")", "]", "}"]
numbers = set(['1','2','3','4','5','6','7','8','9'])

def pop_atoms(atom_stack):
    ret = []
    brackets = []
    while True:
        c = atom_stack.pop()
        if c[0] in bracket_end:
            brackets.append(c[0])
        elif c[0] in bracket_begin:
            brackets.pop()
        else:
            ret.append(c)
        if not brackets:
            break
    return ret

def push_atoms(atom_nums, atom_stack):
    for atom_num in reversed(atom_nums):
        atom_stack.append(atom_num)

def summary(atom_stack):
    ret = {}
    for atom_num in atom_stack:
        if atom_num[0] in bracket_begin or atom_num[0] in bracket_end:
            continue
        cur_total = ret.get(atom_num[0], 0)
        ret[atom_num[0]] = atom_num[1] + cur_total
    return ret

def multiple_atom_nums(atom_stack, cur_num):
    if not cur_num:
        return
    atom_nums = pop_atoms(atom_stack)
    for atom_num in atom_nums:
        atom_num[1] *= int(cur_num)    
    push_atoms(atom_nums, atom_stack) 

def parse_molecule (formula):
    atom_stack = []
    cur_num = ""
    for c in formula:
        if c in numbers:
            cur_num += c
        else:
            multiple_atom_nums(atom_stack, cur_num) 
            cur_num = ""          
            if c >= 'a' and c <= 'z':
                atom_stack[-1][0] = atom_stack[-1][0] + c
            else:
                atom_stack.append([c, 1])
    multiple_atom_nums(atom_stack, cur_num)
    return summary(atom_stack)
Best Practices0Clever0
0ForkCompare with your solutionLink
sgriffis89

def parse_molecule(formula):

    array = []
    dictionary = {}
    hold = 0
    marked = 0
    for i in xrange(0, len(formula)):
        alpha_num = formula[i]
        if alpha_num.isdigit():
            use = int(alpha_num)

            if i != len(formula) - 1:
                if formula[i + 1].isdigit():
                    use = int(formula[i:i+2])
                elif formula[i - 1].isdigit():
                    use = 0

            if marked == 0 and use > 0:
                array[-1]['num'] *= int(use)
            elif use > 0:
                for i in array:
                    if hold == i['hold']:
                        i['num'] *= int(alpha_num)
                        i['hold'] -= 1
                marked = 0
                hold -= 1

        elif alpha_num == '(' or alpha_num == '[' or alpha_num == '{':
            hold += 1
            marked = 0
        elif alpha_num == ')' or alpha_num == ']' or alpha_num == '}':
            marked = 1

        elif alpha_num.islower():
            array[-1]['l'] += alpha_num
        else:
            array.append({'l': alpha_num, 'num': 1, 'hold': hold})

        # print alpha_num, marked, hold, array

    for i in array:

        if i['l'] in dictionary.keys():
            dictionary[i['l']] += int(i['num'])
        else:
            dictionary[i['l']] = int(i['num'])

    return dictionary
Best Practices0Clever0
0ForkCompare with your solutionLink
jmossel

import re
brackets = {']':'[', ')':'(', '}':'{'};

def parse_molecule (formula):
    d = {}
    multiplier = 1
    formula = list(formula)
    while len(formula) > 0:
        symbol = formula.pop()
        
        if symbol.isdigit():
            multiplier_str = symbol
            while symbol.isdigit():
                symbol = formula.pop()
                if symbol.isdigit():
                    multiplier_str = symbol + multiplier_str 
                else:
                    multiplier = int(multiplier_str)
        
        if symbol in brackets:
            index = len(formula)-formula[::-1].index(brackets[symbol])-1
            formula = formula[:index] + formula[index+1:]*multiplier
            multiplier = 1
            continue
        
        if re.match('[a-z]',symbol):
            symbol = formula.pop()+symbol
        
        d[symbol] = d.get(symbol,0) + multiplier
        multiplier = 1
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
mr1Stranger

from itertools import takewhile

# REFACTORING, wtite in 10 mins!!!

def is_lower(letter):
    return letter.isalpha() is True and letter.islower() is True

def is_multp(letter):
    return letter.isdigit()

def is_even(opened, closed):
    return opened == closed

def str_to_m(mult):
    if mult == "":
        return 1
    return int(mult)       # Not catch

def parse_molecule(formula):
    offset = 0
    stack = {}
    while offset < len(formula):
        elem = formula[offset]
        cursor = offset
        if elem.isalpha() is True and elem.isupper() is True:
            postfix = ''.join(list(takewhile(is_lower, formula[offset+1:])))
            cursor += len(postfix)
            elem += postfix
            multiplicator = ''.join(list(takewhile(is_multp, formula[cursor+1:])))
            if elem in stack:
                stack[elem] = stack[elem] + str_to_m(multiplicator)
            else:
                stack[elem] = str_to_m(multiplicator)
            offset = cursor + len(multiplicator)
        if elem == "(" or elem == "[" or elem == "{":
            cursor = offset + 1
            brackets = ""
            opened = 1
            closed = 0
            while opened > closed:
                brackets += formula[cursor]
                if formula[cursor] == "(" or formula[cursor] == "[" or formula[cursor] == "{":
                    opened += 1
                elif formula[cursor] == ")" or formula[cursor] == "]" or formula[cursor] == "}":
                    closed += 1
                cursor += 1
            offset = cursor
            multiplicator = str_to_m(''.join(list(takewhile(is_multp, formula[offset:]))))
            brackets = brackets[:-1]
            stack_r = parse_molecule(brackets)
            for k, v in stack_r.iteritems():
                if k in stack:
                    stack[k] = stack[k] + v * multiplicator
                else:                    
                    stack[k] = v*multiplicator
        else:
            offset += 1
    return stack
    
Best Practices0Clever0
0ForkCompare with your solutionLink
DeclanCrew

import string

def returnComponent(formula):
    entry = {"number":1,"value":""}
    brackets = {"[":"]","(":")","{":"}"}
    output = []
    i = 0
    while i < len(formula):
        if formula[i] in brackets.keys():
            if len(entry["value"]) > 0:
                output.append(entry)
            entry = {"number":1, "value":formula[i]}
            openBracket = formula[i]
            closeBracket = brackets[formula[i]]
            bracketCounter = 1
            while bracketCounter != 0:
                i += 1
                entry["value"] += formula[i]
                if formula[i] == openBracket:
                    bracketCounter += 1
                if formula[i] == closeBracket:
                    i += 1
                    bracketCounter -= 1
            continue
        elif formula[i] in string.digits:
            number = ""
            while i < len(formula) and formula[i] in string.digits:
                number += formula[i]
                i += 1
            entry["number"] = int(number)
            output.append(entry)
            entry = {"number":1,"value":""}
            continue
        elif formula[i] in string.ascii_uppercase and len(entry["value"]) > 0:
            output.append(entry)
            entry = {"number":1, "value":""}
            continue
        entry["value"] += formula[i]
        i += 1
    if len(entry["value"]) > 0:
        output.append(entry)
    return output
        
def evaluateBracket(inDict):
    output = []
    multiplier = inDict["number"]
    componentGenerator = returnComponent(inDict["value"][1:-1])
    for i in componentGenerator:
        i["number"] *= multiplier
        if i["value"][0] in ["(","{","["]:
                subSet = evaluateBracket(i)
                for j in subSet:
                    output.append(j)
        else:
            output.append(i)
    return output
        
def parse_molecule (formula):
    componentList = []
    for i in returnComponent(formula):
        if i["value"][0] in ["[","{","("]:
            bracketContents = evaluateBracket(i)
            for j in bracketContents:
                componentList.append(j)
        else:
            componentList.append(i)
    finalOutput = {}
    for i in componentList:
        if i["value"] in finalOutput.keys():
            finalOutput[i["value"]] += i["number"]
        else:
            finalOutput[i["value"]] = i["number"]
    print finalOutput
    return finalOutput
Best Practices0Clever0
0ForkCompare with your solutionLink
maurelio1234

from collections import  deque

def replace_par(text, repl):
    for i in xrange(0,len(repl),2):
      text = text.replace(repl[i], '(')
      text = text.replace(repl[i+1], ')')
    return text
    
def read_element(text):
  ret = ''
  if text[0].isupper():
    ret += text[0]
    for l in text[1:]:
      if l.islower():
        ret += l
      else:
        break
  
  return ret
def read_number(text):
  ret = ''
  for l in text:
    if l.isdigit():
      ret += l
    else:
      break
  
  return ret
      
def parse_molecule(formula):
  formula = replace_par(formula, '[]{}')
  
  d = deque()
  d.append({})
  i = 0
  
  while i<len(formula):
    
    element = read_element(formula[i:])
    if element:
      i += len(element)
      number = read_number(formula[i:])
      if number:
        i += len(number)
        number = int(number)
      else:
        number = 1
        
      val = 0
      if element in d[-1]:
          val += d[-1][element]
      d[-1][element] = val + number
    else:
      if formula[i]=='(':
        i += 1
        d.append({})
      elif formula[i]==')':
        i += 1
        number = read_number(formula[i:])
        if number:
          i += len(number)
          number = int(number)
        else:
          number = 1
          
        dq = d.pop()
          
        for k in dq:
          val = 0
          if k in d[-1]:
            val += d[-1][k]
          d[-1][k] = val + dq[k]*number
          
  return d[-1]
  
  
Best Practices0Clever0
0ForkCompare with your solutionLink
Okita Sougo

def parse_molecule (formula):
    atoms = dict()
    s = formula[0]
    count = ''
    i = 0
    stk = []
    while i < len(formula) :
        if s.isalpha():
            if i+1 < len(formula) and formula[i+1].islower():
                stk.append(formula[i:i+2])
                i += 2
                if i < len(formula):
                    s = formula[i]
                else:
                    s = ''
                if s.isupper() or s in ('(','[','{',')',']','}'):
                    stk.append(1)
            elif i+1 < len(formula) and (formula[i+1].isupper() or formula[i+1] in ('(','[','{',')',']','}')):
                stk.append(s)
                stk.append(1)
                i += 1
                if i < len(formula):
                    s = formula[i]
            else:
                stk.append(s)
                i += 1
                if i < len(formula):
                    s = formula[i]

        elif s.isdigit():
            while s.isdigit():
                count += s
                i += 1
                if i < len(formula):
                    s = formula[i]
                else:
                    s = ''
            stk.append(int(count))
            count = ''
        elif s in ('(','[','{'):
            stk.append(s)
            i += 1
            s = formula[i]
        elif s in (')',']','}'):
            temp_stk =[]
            el = stk.pop()
            if i + 1 < len(formula) and formula[i+1].isdigit():
                i += 1
                s = formula[i]
            else:
                i += 1
                if i < len(formula):
                    s = formula[i]
            while s.isdigit():
                count += s
                i += 1
                if i < len(formula):
                    s = formula[i]
                else:
                    s = ''
            if count != '':
                mul = int(count)
            else:
                mul = 1
            count = ''
            while el not in ('(','[','{'):
                if isinstance(el,int):
                    temp_stk.append(mul*el)
                else:
                    temp_stk.append(el)
                el = stk.pop()
            temp_stk.reverse()
            stk.extend(temp_stk)
    j = 0
    while j < len(stk):
        if j+1 < len(stk) and isinstance(stk[j+1],int):
            if atoms.has_key(stk[j]):
                atoms[stk[j]] += stk[j+1]
            else:
                atoms[stk[j]] = stk[j+1]
            j += 2
        else:
            if atoms.has_key(stk[j]):
                atoms[stk[j]] += 1
            else:
                atoms[stk[j]] = 1
            j += 1
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
marianosimone

from collections import Counter

def continues_token(token, other):
    if token.isdigit():
        return other.isdigit()
    if token.isalpha():
        return other.isalpha() and other.islower()
    return False

def tokenizer(formula):
    i = 0
    while i < len(formula):
        token = formula[i]
        j = i+1
        while j < len(formula) and continues_token(formula[i], formula[j]):
            token += formula[j]
            j += 1
        yield token
        i = j

OPENERS = set(['(', '[', '{'])
CLOSERS = set([')', ']', '}'])

def close_stack_level(stack, multiplier):
    prev = stack[-1][-1]
    if prev in CLOSERS:
        current_stack = stack.pop()
        current_stack.pop()  # get rid of the closer
        previous_stack = stack[-1]
        for element in current_stack:
            previous_stack.extend([element]*multiplier)
    else:
        stack[-1].extend([prev]*(multiplier-1))

def parse_molecule(formula):
    stack = [[]]
    prev = None
    for token in tokenizer(formula):
        if token.isdigit():
            close_stack_level(stack, int(token))
        if (token.isalpha() or token in OPENERS) and prev in CLOSERS:
            close_stack_level(stack, 1)
        if token.isalpha() or token in CLOSERS:
            stack[-1].append(token)
        if token in OPENERS:
            stack.append([])
        prev = token
    return Counter(stack[-1])
Best Practices0Clever0
0ForkCompare with your solutionLink
othanag

import re
from collections import Counter
def parse_molecule (formula):
       
    print formula
    s = formula
    y= ""
    x= ""
    
    if (s.find("(") != -1) :
        rep = s[s.find("("):s.find(")")+2]
        coef = s[s.find(")")+1]
        if coef.isdigit() == True :
            y = s.replace(rep,rep[1:len(rep)-2]*int(coef)) 
        else :
            y = s.replace(rep[0:len(rep)-1],rep[1:len(rep)-2]*1)
    else :
        y = formula
    
    s = y
    if (s.find("{") != -1) :
        rep = s[s.find("{"):s.find("}")+2]
        coef = s[s.find("}")+1]
        if coef.isdigit() == True :
            y = s.replace(rep,rep[1:len(rep)-2]*int(coef)) 
        else :
            y = s.replace(rep[0:len(rep)-1],rep[1:len(rep)-2]*1)
    else :
        y = formula
    
    s = y
    if (s.find("(") != -1) :
        rep = s[s.find("("):s.find(")")+2]
        coef = s[s.find(")")+1]
        if coef.isdigit() == True :
            y = s.replace(rep,rep[1:len(rep)-2]*int(coef)) 
        else :
            y = s.replace(rep[0:len(rep)-1],rep[1:len(rep)-2]*1)
    else :
        y = s
    
    print y
    s = y
    if (s.find("(") != -1) :
        rep = s[s.find("("):s.find(")")+2]
        coef = s[s.find(")")+1]
        if coef.isdigit() == True :
            y = s.replace(rep,rep[1:len(rep)-2]*int(coef)) 
        else :
            y = s.replace(rep[0:len(rep)-1],rep[1:len(rep)-2]*1)
    else :
        y = s
    s = y
    if (s.find("[") != -1) :
        rep = s[s.find("["):s.find("]")+2]
        rep2 = s[s.find("["):s.find("]")+3]
        print rep
        coef = s[s.find("]")+1]
        if s.find("]")+2 < len(s) : 
            coef2  = s[s.find("]")+2]
        else :
            coef2 = ""
        if coef2.isdigit() == True :
            
            y = s.replace(rep2,rep[1:len(rep)-2]*int(coef+coef2))
            print int(coef+coef2)
        else :
            y = s.replace(rep,rep[1:len(rep)-2]*int(coef)) 
            #y = s.replace(rep[0:len(rep)-1],rep[1:len(rep)-2]*1)
    else :
        y = s
    
    
    print y
    print "wawa"
    
    
    y =  re.findall('[A-Z][^A-Z]*', y)
    print y
    for i in range(0,len(y)) :
        match = re.match(r"([a-z]+)([0-9]+)", y[i], re.I)
        
        if match:
            items = match.groups()
            print items
            if items[1].isdigit() == True :
            
                print items[0]*(int(items[1]))
                y[i] = items[0]*(int(items[1]))
            
                #y = y.replace(y[i],y[i-1]*(int(y[i])-1))
    
    print y
    y = "".join(y)
    y =  re.findall('[A-Z][^A-Z]*', y)
    #print y
    print Counter(y)
    return Counter(y)
Best Practices0Clever0
0ForkCompare with your solutionLink
MattLoftus

def findMult(str):
    mult = ""
    if len(str) == 1:
        return 0
    else:
        for char in str[1:]:
            if char.isdigit():
                mult += char
            else:
                break
    if mult != "":
        return int(mult)
    else:
        return 0
               

def parse_molecule (formula, endToken = ""):
    #initialize res frquencies, counter, and current element
    res = {}
    i = 0
    element = ""
    #iterate over the characters in the formula
    while i < len(formula):
        char = formula[i]
        print "current element:  ", element
        print "current char:  ", char
        #if we encounter a new opening token, we need to determine what that
        #token is and recurse with the correct arguments
        if char == "[" or char == "(" or char == "{":
            if len(element) != 0:
                res[element] = 1
                element = ""
            closeToken = ""
            if char == "[":
                closeToken = "]"
            elif char == "(":
                closeToken = ")"
            else:
                closeToken = "}"
            #invoke parse_mol again with remainder or formula and closing token
            sub = parse_molecule(formula[i+1:], closeToken)
            subFreqs = sub[0]
            #add resulting frequencies to current frequencies
            for el in subFreqs:
                if el in res:
                    res[el] += subFreqs[el]
                else:
                    res[el] = subFreqs[el]
            i += sub[1] + 1
        #reach the closing token, first we want to add current
        #element to the res if it exists
        elif char == endToken:
            if element != "":
                if element in res:
                    res[element] += 1
                else:
                    res[element] = 1
            #then we want to check if there is a multiplier after the token
            mult = findMult(formula[i:])
            if mult != 0:
                for el in res:
                    res[el] *= mult
            return [res, i]
        #if the character is upper case and a letter
        #check if previous el needs to be added, then make new el    
        elif char.isalpha() and char.isupper():
            if len(element) != 0:
                if element in res:
                    res[element] += 1
                else:
                    res[element] = 1
            element = char
            if i == len(formula) - 1:
                if element in res:
                    res[element] += 1
                else:
                    res[element] = 1
        #if current character is lower case, add it to the current element
        elif char.islower():
            element += char
        elif char.isdigit():
            mult = findMult("("+formula[i:])
            if element in res:
                res[element] += mult
            else:
                res[element] = mult
            element = ""
        i += 1
    if "" in res:
        del res[""]
    return res
        
        
        
            
Best Practices0Clever0
0ForkCompare with your solutionLink
404_denied

def parse_molecule(formula):
    
    def _parser(expression, elements_stack=[], braces_stack=[]):
        """
        Return dictionary with every element containing in formula with number of occurences.
        Recursive EBNF rules parser.
        :param expression: Initial chemical formula
        :param elements_stack: Elements stack
        :param braces_stack: Braces stack 
        :return: Elements dictionary 
        """

        import re

        braces_dict = {"{": "}",
                    "[": "]",
                    "(": ")"}

        if not expression:
            raise SyntaxError("Empty string passed!")
        
        elements_stack = elements_stack or [{}]

        # EBNF rules
        element_rule = re.compile("([A-Z][a-z]?)(\d+)?").match(expression)
        left_brace_rule = re.compile("[\(\[\{]").match(expression)
        right_brace_rule = re.compile("[\)\]\}](\d+)?").match(expression)

        # Atom followed by an optional number (default is 1).
        if element_rule:
            tail = expression[len(element_rule.group()):]
            head = re.compile("([A-Z][a-z]?)").match(element_rule.group()).group()
            num = 1 if element_rule.group()[len(head):] == "" else int(element_rule.group()[len(head):])

            # If element is already in current stack dictionary - increase its value, else create new key
            if elements_stack[-1].get(head, False): 
                elements_stack[-1][head] += num 
            else:
                elements_stack[-1][head] = num 

        # Opening brace with optional delimiter
        elif left_brace_rule:
            tail = expression[len(left_brace_rule.group()):]
            braces_stack.append(left_brace_rule.group())
            elements_stack.append({})  

        # Closing brace with optional delimiter
        elif right_brace_rule:
            tail = expression[len(right_brace_rule.group()):]
            delim = re.compile("[\)\]\}]").match(right_brace_rule.group()).group()
            num = 1 if right_brace_rule.group()[len(delim):] == "" else int(right_brace_rule.group()[len(delim):])

            # Pop current stack element and combine with previous one
            if braces_dict[braces_stack.pop()] != delim:
                raise SyntaxError("un-matched right brace in '%s'" % (expression,))

            for (k, v) in elements_stack.pop().iteritems():
                if elements_stack[-1].get(k, False):
                    elements_stack[-1][k] += v * num
                else:
                    elements_stack[-1][k] = v * num

        # Wrong syntax
        else:
            raise SyntaxError("'%s' does not match any rule" % (expression,))

        # Continue parsing formula
        if len(tail) > 0:
            _parser(tail, elements_stack, braces_stack)
            return elements_stack[-1]

        # Expression is over - quit
        else:
            return elements_stack[-1]

    return _parser(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
dipeshy

import re

def formulaToDict(formula):
    counter = {}
    m = re.findall(r'[A-Z][a-z]?\d*', formula)
    for x in m:
        m2 = re.match(r'([A-Z][a-z]?)(\d+)?', x)
        if m2:
            element = m2.group(1)
            if m2.group(2):
                count = int(m2.group(2))
            else:
                count = 1

            if element in counter:
                value = counter[element]
            else:
                value = 0
            
            counter[element] = value + count

    return counter

def evaluate(e, multiplier = 1):
    counter = {}
    result = ""
    m = re.findall(r'[A-Z][a-z]?[0-9]*', e)
    for x in m:
        m2 = re.match(r'([A-Z][a-z]?)(\d+)?', x)
        if m2:
            element = m2.group(1)
            if m2.group(2):
                count = int(m2.group(2))
            else:
                count = 1

            if element in counter:
                value = counter[element]
            else:
                value = 0
            
            counter[element] = value + count
    
    for element, count in counter.iteritems():
         result = result + element + str(count * multiplier)
    
    return result
    
def parse_molecule(formula):
    result = {}
    pattern = re.compile('(?:[\(\[\{])([^\(\[\{\)\]\}]+)(?:[\)\]\}])(\d+)?')
    expression = pattern.search(formula)
    while expression:
        if expression.group(2):
            found_multiplier = int(expression.group(2))
        else: 
            found_multiplier = 1

        result = evaluate(expression.group(1), found_multiplier)
        formula = pattern.sub(result, formula, 1)
        expression = pattern.search(formula)
    
    return formulaToDict(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
egillet

def parse_molecule (formula):
    #print("parse_molecule(%s)" % formula)
    m = {}
    i = 0
    while i < len(formula):
        l = formula[i]
        if l in "({[":
            nested = 0
            for j in range(i+1, len(formula)):
                if formula[j] in "({[":
                    nested += 1
                elif formula[j] in "]})":
                    if nested == 0:
                        break
                    else:
                        nested -=1
            nested_m = parse_molecule(formula[i+1:j])
            nested_mul = 0
            while j < len(formula)-1 and formula[j+1].isdigit():
                nested_mul = nested_mul*10 + int(formula[j+1])
                j += 1
            nested_mul = max(1, nested_mul)
            for k in nested_m:
                if k in m:
                    m[k] += nested_m[k]*nested_mul
                else:
                    m[k] = nested_m[k]*nested_mul
            i = j
        else:
            atom = l
            if i < len(formula)-1 and formula[i+1] >= 'a' and formula[i+1] <= 'z':
                atom += formula[i+1]
                i += 1
            mult = 0
            while i < len(formula)-1 and formula[i+1].isdigit():
                mult = mult *10 + int(formula[i+1])
                i += 1
            mult = max(mult, 1)
            if atom in m:
                m[atom] += mult
            else:
                m[atom] = mult  
        i += 1
    return m 
Best Practices0Clever0
0ForkCompare with your solutionLink
lihongchun2007

import re
def parse_molecule (formula):
    elements = re.findall(r'[A-Z][a-z]*|[0-9]+|[\[\(\{\}\)\]]{1}', formula)
    
    node = Node()
    for idx, element in enumerate(elements):
        if element.isalpha():
            if idx + 1 < len(elements) and elements[idx + 1].isdigit():
                n = Node()
                n.element = element
                n.count = int(elements[idx + 1])
                n.parent = node
                node.child.append(n)
            else:
                n = Node()
                n.element = element
                n.count = 1
                n.parent = node
                node.child.append(n)
        elif element in ['(', '[', '{']:
            n = Node()
            n.element = None
            n.count = 1
            n.parent = node
            node.child.append(n)

            node = n
        elif element in [')', ']', '}']:
            if idx + 1< len(elements) and elements[idx + 1].isdigit():
                node.count = int(elements[idx + 1])
            node = node.parent

    return node.cal_elements()

class Node:
    def __init__(self):
        self.element = None
        self.count = 1
        self.child = []
        self.parent = None

    def cal_elements(self, scale=1):
        if len(self.child) == 0:
            return {self.element: self.count*scale}

        elements = {}
        for n in self.child:
            subElements = n.cal_elements(self.count*scale)

            for e in subElements:
                if e in elements:
                    elements[e] += subElements[e]
                else:
                    elements[e] = subElements[e]

        return elements
    
Best Practices0Clever0
0ForkCompare with your solutionLink
sakana378

def push(a, b, n):
    if n == 0:
        n = 1
    for x in b:
        if x not in a:
            a[x] = 0
        a[x] += b[x] * n
    b.clear()

def parse_molecule (formula):
    element = ''
    atom = {}
    current = {}
    num = 0
    i = 0
    
    while i < len(formula):
        x = formula[i]
        if x.isupper():
            push(atom, current, num)
            num = 0
            element = x
            current[element] = 1
        if x.islower():
            del current[element]
            element += x
            current[element] = 1
            
        if x.isdigit():
            num = num * 10 + int(x)
            
        if x in '([{':
            push(atom, current, num)
            num = 0
            j = formula[i+1:].index({'(':')', '[':']', '{':'}'}[x])
            current = parse_molecule(formula[i+1:i+1+j])
            i += j
            
        i += 1
                
    if len(current) > 0:
        push(atom, current, num)
        
    #print atom
    return atom
Best Practices0Clever0
0ForkCompare with your solutionLink
zhykzhykzhyk

def parse_molecule (formula):
    def tokens():    
        tokenType = 'initial'
        token = ''
        for c in formula:
            if c.isdigit():
                if tokenType != 'number':
                    yield tokenType, token
                    tokenType = 'number'
                    token = ''
                token += c
            elif c.isupper():
                yield tokenType, token
                tokenType = 'element'
                token = c
            elif c.islower():
                assert tokenType == 'element'
                token += c
            elif c in "([{":
                yield tokenType, token
                tokenType = 'openBracket'
                token = c
            elif c in ")]}":
                yield tokenType, token
                tokenType = 'closeBracket'
                token = c
            else:
                assert not 'valid character'
        yield tokenType, c
        
    atomStack = [{}]
    def close():
        atoms = atomStack.pop()
        for k, v in atoms.iteritems():
            try:
                atomStack[-1][k] += v
            except KeyError:
                atomStack[-1][k] = v
        
    for tokenType, token in tokens():
        if tokenType == 'element':
            close()
            atomStack.append({token: 1})
        elif tokenType == 'closeBracket':
            close()
        elif tokenType == 'openBracket':
            close()
            atomStack.append({})
            atomStack.append({})
        elif tokenType == 'number':
            factor = int(token)
            for k in atomStack[-1]:
                atomStack[-1][k] *= factor
        elif tokenType == 'initial':
            atomStack.append({})
        else:
            assert not 'valid token'
    
    close()
    assert len(atomStack) == 1
    return atomStack[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
grizlupo

import re
from collections import defaultdict

tokens_re = re.compile('|'.join((
    r'(?P<atom>([A-Z][a-z]*)(\d*))',
    r'(?P<left>[[{(])',
    r'(?P<right>([]})])(\d*))')))

def tokenize(s):
    groupindex = tokens_re.groupindex
    pos, n = 0, len(s)
    while pos < n:
        m = tokens_re.match(s, pos)
        if not m:
            return
        kind, value = m.lastgroup, m.groupdict()[m.lastgroup]
        if kind != 'left':  # 'atom' or 'right'
            i = groupindex[kind]
            count = m.group(i+2)
            value = m.group(i+1), int(count) if count else 1
        pos = m.end()
        yield kind, value

def parse(xs):
    stack = [[]]
    for kind, value in tokenize(xs):
        if kind in 'left':
            lst = []
            stack[-1].append(lst)
            stack.append(lst)
        elif kind in 'right':
            lst = stack.pop()
            if not stack:
                raise ValueError('error: opening bracket is missing')
            stack[-1][-1] = (lst, value[1])
        else:
            stack[-1].append(value)
    if len(stack) > 1:
        raise ValueError('error: closing bracket is missing')
    return stack.pop()
    
def count_atom(atom_list):
    atoms = defaultdict(int)
    for name, count in atom_list:
        if isinstance(name, list):
            multiply = count
            for name, count in count_atom(name).items():
                atoms[name] += count * multiply
        else:
            atoms[name] += count
    return atoms

def parse_molecule(formula):
    return count_atom(parse(formula))
Best Practices0Clever0
0ForkCompare with your solutionLink
junkainiu

import re
from collections import defaultdict

atom_pattern = re.compile(r'[A-Z]')
sub_atom_pattern = re.compile(r'[a-z]')
num_pattern = re.compile(r'\d')
br_start_pattern = re.compile(r'\[|\{|\(')
br_end_pattern = re.compile(r'\]|\}|\)')
def get_num(formula, i):
    r = re.match(r'\d+', formula[i:])
    len = r.span()[1] - r.span()[0]
    result = int(r.group())
    return result,len
def calculate_br_pos(formula):
    result = []
    pair_pattern = re.compile(r'\[\w+\]|\{\w+\}|\(\w+\)')
    while pair_pattern.search(formula):
        br_pos = pair_pattern.search(formula).span()
        br_len = br_pos[1] - br_pos[0]
        result.append(br_pos)
        formula = pair_pattern.sub('a'*br_len, formula, 1)
    return result

def parse_molecule(formula):
    i = 0
    result = defaultdict(dict)
    br_position = calculate_br_pos(formula)
    while i<len(formula):
        try:
            if atom_pattern.match(formula[i]):
                name = formula[i]
                if sub_atom_pattern.match(formula[i+1]):
                    name = formula[i] + formula[i+1]
                    if num_pattern.match(formula[i+2]):
                        num,num_len = get_num(formula, i+2)
                        result[name].update({i+2 : num})
                        i = i+2+num_len
                    else:
                        result[name].update({i+1 : 1})
                        i += 2
                elif num_pattern.match(formula[i+1]):
                    num,num_len = get_num(formula, i+1)
                    result[name].update({i+1 : num})
                    i = i + 1 + num_len
                else:
                    result[name].update({i : 1})
                    i += 1
            elif br_start_pattern.match(formula[i]):
                i += 1
            elif br_end_pattern.match(formula[i]):
                if num_pattern.match(formula[i+1]):
                    num,num_len = get_num(formula, i+1)
                    result = add_br_end_num(result, i+1, num, br_position)
                    i += 1 + num_len
                else:
                    result = add_br_end_num(result, i+1, 1, br_position)
                    i += 1
            else:
                i += 1
        except IndexError:
            if num_pattern.match(formula[len(formula)-1]):
                if atom_pattern.match(formula[i]):
                    num,num_len = get_num(formula, i+1)
                    result[name].update({i+1, num})
                    i = i + 1 + num_len
                elif br_end_pattern.match(formula[i]):
                    num,num_len = get_num(formula, i+1)
                    result = add_br_end_num(result, i+1, num, br_position)
                    i += 1 + num_len
                else:
                    i += 1
            elif br_end_pattern.match(formula[len(formula)-1]):
                if atom_pattern.match(formula[i]):
                    result[name].update({i : 1})
                    i += 1
                else:
                    i += 1
            elif sub_atom_pattern.match(formula[len(formula)-1]):
                result[name].update({i+1 : 1})
                i += 2
            elif atom_pattern.match(formula[len(formula)-1]):
                result[name].update({i : 1})
                i += 1
            continue
    result = calculate_result(result)
    print result
    return result

def add_br_end_num(result, i, v, br_position):
    for elem in br_position:
        if elem[1] == i:
            for value in result.itervalues():
                for key in value.keys():
                    if key > elem[0] and key < elem[1]:
                        value[key] = int(value[key]) * int(v)
    return result

def calculate_result(result):
    result = {key:sum([int(v) for v in value.itervalues()]) for key,value in result.iteritems()}
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
maghkor

import re

def parse_molecule (formula):
    f = formula
    f = re.sub('[\[\{]', '(', f)
    f = re.sub('[\]\}]', ')', f)

    
    n = len(f)
    a = []
    i = 0 
    while i < n:
        if f[i].isupper():
            a.append(f[i])
            i += 1
        elif f[i].islower():
            a[-1] += f[i]
            i += 1
        elif f[i].isdigit():
            sum = 0
            while i < n and f[i].isdigit():
                sum = sum * 10 + ord(f[i]) - ord('0')
                i += 1
            a.append(sum)
        else:
            a.append(f[i])
            i += 1
    res = [{}]
    n = len(a)
    i = 0
    while i < n:
        if re.match(r'^[A-Z][a-z]?$', a[i]):
            elem = a[i]
            if i + 1 < n and isinstance(a[i + 1], int):
                cc = a[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            if not elem in res[-1]:
                res[-1][elem] = cc
            else:
                res[-1][elem] += cc
        elif a[i] == '(':
            res.append({})
            i += 1
        elif a[i] == ')':
            if i + 1 < n and isinstance(a[i + 1], int):
                cc = a[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            for k in res[-1]:
                if not k in res[-2]:
                    res[-2][k] = cc * res[-1][k]
                else:
                    res[-2][k] += cc * res[-1][k]
            res.pop()
    return res.pop()
Best Practices0Clever0
0ForkCompare with your solutionLink
dorpuppet

from collections import defaultdict

brackets = {'(':')', '[':']', '{':'}'}
numeric = map(lambda x: str(x), range(10))
def isnumeric(c):
    return c in numeric

def parse_molecule(formula):
    return calc(parse(formula))

def calc(stack):
    d = defaultdict(lambda: 0)
    for atom in stack:
        if isinstance(atom, list):
            add(d,calc(atom))
        elif isinstance(atom, tuple):
            add(d,calc(atom[0]), atom[1])
        else:
            d[atom]+=1
    return d

def parse(formula):
    stack = []
    while formula:
        c = formula[0]
        formula = formula[1:]
        if c.isupper():
            stack += [c]
        elif c.islower():
            stack[-1] += c
        elif isnumeric(c):
            if isinstance(stack[-1], tuple):
                stack[-1] = (stack[-1][0], stack[-1][1]*10 + int(c))
            elif isinstance(stack[-1], list):
                stack[-1] = (stack[-1], int(c))
            else:
                stack[-1] = ([stack[-1]], int(c))
        elif c in brackets:
            i = formula.find(brackets[c])
            stack += [parse(formula[:i])]
            formula = formula[i+1:]
    return stack

def add(d, cur_d, mul = 1):
    for a in cur_d:
        d[a] += (cur_d[a]*mul)
Best Practices0Clever0
0ForkCompare with your solutionLink
turzhad

braces = ['(', '{', '[']
closing_braces = [')', '}', ']']

def add_atom(atom, n, total_atoms):
    if atom in total_atoms:
        total_atoms[atom] += n
    else:
        total_atoms[atom] = n

def multiply_atoms(atoms, n, total_atoms):
    for atom in atoms:
        add_atom(atom, n, total_atoms)

def add_atoms(atoms, m, total_atoms):
    for (atom, n) in atoms.items():
        add_atom(atom, n * m, total_atoms)

def parse_molecule(formula):
    stack = [{}]
    last_atoms = {}
    k = 0
    while k < len(formula):
        c = formula[k]
        m = 1
        if c.isdigit():
            k += 1
            while k < len(formula) and c.isdigit():
                c += formula[k]
                k += 1
            k -= 1
            if len(c) > 1:
                k -= 1
                c = c[:-1]
            m = int(c)
        add_atoms(last_atoms, m, stack[-1])
        if c in closing_braces:
            last_atoms = stack[-1]
            del stack[-1]
            k += 1
            continue
        last_atoms = {}
        if c in braces:
            stack.append({})
        elif not c.isdigit():
            if k + 1 < len(formula) and formula[k+1].islower():
                c += formula[k+1]
                k += 1
            last_atoms[c] = 1
        k += 1
    add_atoms(last_atoms, 1, stack[0])
    return stack[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
BNC

def parse_molecule(molecule):
    stat = 0 # 0 = majuscule, 1 = miniscule, 2 = number post single atom, 3 = bracket, 4 = number post bracket
    number = ''
    atom = ''
    bracket = {}
    bracket_open_ref = '([{'
    bracket_close_ref = ')]}'
    majuscule_ref = 'AZERTYUIOPQSDFGHJKLMWXCVBN'
    number_ref = '0123456789'
    n = len(molecule)
     
    contained_atoms = {}
    i = 0
     
    while i < n:
        if molecule[i] in majuscule_ref:
            if stat in [0,1] and atom != '':
                if atom in contained_atoms.keys():
                    contained_atoms[atom] += 1
                else:
                    contained_atoms[atom] = 1
                    
            if stat == 2:
                if atom in contained_atoms.keys():
                    contained_atoms[atom] += int(number)
                else:
                    contained_atoms[atom] = int(number)
                number = ''
                
            if stat == 3:
                for key,val in bracket.items():
                    if key in contained_atoms.keys():
                        contained_atoms[key] += val
                    else:
                        contained_atoms[key] = val
                bracket = {}
                
            if stat == 4:
                number = int(number)
                for key,val in bracket.items():
                    if key in contained_atoms.keys():
                        contained_atoms[key] += number*val
                    else:
                        contained_atoms[key] = val*number
                bracket = {}
                number = ''
                
            atom = molecule[i]
            stat = 0
            
        elif molecule[i] in number_ref:
            if stat in [0,1,2]:
                stat = 2
                 
            if stat in [3,4]:
                stat = 4
                
            number += molecule[i]
            
        elif molecule[i] in bracket_open_ref:
            j = i+1
            k = bracket_open_ref.index(molecule[i])
            while j < n and molecule[j] not in bracket_close_ref[k]:
                j += 1
                
            if stat in [0,1] and atom != '':
                if atom in contained_atoms.keys():
                    contained_atoms[atom] += 1
                else:
                    contained_atoms[atom] = 1
                    
            if stat == 2:
                if atom in contained_atoms.keys():
                    contained_atoms[atom] += int(number)
                else:
                    contained_atoms[atom] = int(number)
                number = ''
                
            if stat == 3:
                for key,val in bracket.items():
                    if key in contained_atoms.keys():
                        contained_atoms[key] += val
                    else:
                        contained_atoms[key] = val
                
            if stat == 4:
                number = int(number)
                for key,val in bracket.items():
                    if key in contained_atoms.keys():
                        contained_atoms[key] += number*val
                    else:
                        contained_atoms[key] = val*number
                number = ''
                
            bracket = parse_molecule(molecule[i+1:j])
            stat = 3
            i = j
        
        else:
            atom += molecule[i]
            stat = 1
        
        i += 1
    
    if stat in [0,1] and atom != '':
        if atom in contained_atoms.keys():
            contained_atoms[atom] += 1
        else:
            contained_atoms[atom] = 1
                    
    elif stat == 2:
        if atom in contained_atoms.keys():
            contained_atoms[atom] += int(number)
        else:
            contained_atoms[atom] = int(number)
                
    elif stat == 3:
        for key,val in bracket.items():
            if key in contained_atoms.keys():
                contained_atoms[key] += val
            else:
                contained_atoms[key] = val
                
    elif stat == 4:
        number = int(number)
        for key,val in bracket.items():
            if key in contained_atoms.keys():
                contained_atoms[key] += number*val
            else:
                contained_atoms[key] = val*number
    
    return contained_atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
jkappler

dict_sep = {")" : "(", "]": "[", "}" : "{"}

def parse_molecule (formula):
    f_lst = []

    i = 0
    while i < len(formula):
        if i < len(formula) - 1 and formula[i + 1].islower():
            f_lst.append(formula[i] + formula[i + 1])
            if i < len(formula) - 2 and (formula[i + 2].isupper() or (formula[i + 2] in "([{}])")):
                f_lst.append('1')
            i += 1
        elif formula[i].isdigit():
            value = formula[i]
            j = i + 1
            while j < len(formula):
                if formula[j].isdigit():
                    value += formula[j]
                    j += 1
                else:
                    break
            f_lst.append(value)
            i += (j - i - 1)
        elif i < len(formula) - 1 and formula[i].isalpha() and (formula[i + 1].isupper() or (formula[i + 1] in "([{}])")):
            f_lst.append(formula[i])
            f_lst.append('1')
        elif i == len(formula) - 1 and formula[i].isalpha():
            f_lst.append(formula[i])
            f_lst.append('1')
        else:
            f_lst.append(formula[i])

        i += 1

    while True:

        i = 0

        while i < len(f_lst):
            if f_lst[i] in ")]}":
                char_find = f_lst[i]
                multip = 1
                if i < len(f_lst) - 1 and f_lst[i + 1].isdigit():
                    multip = int(f_lst.pop(i + 1))

                f_lst.pop(i)
                j = i - 1

                while f_lst[j] != dict_sep.get(char_find):
                    if f_lst[j].isdigit():
                        f_lst[j] = str(int(f_lst[j]) * multip)
                    j -= 1

                f_lst.pop(j)
                break

            i+= 1

        if f_lst.count("[") == 0 and f_lst.count("(") == 0 and f_lst.count("{") == 0:
            break


    final_dict = {}

    i = 0
    while i < len(f_lst):
        if f_lst[i] not in final_dict.keys():
            final_dict.update({f_lst[i]: int(f_lst[i + 1])})
        else:
            final_dict.update({f_lst[i]: int(f_lst[i + 1]) + final_dict.get(f_lst[i])})

        i += 2

    return final_dict
Best Practices0Clever0
0ForkCompare with your solutionLink
GBy

def parse_molecule (formula):

    def dic_add(dica, dicb):
        return dict(
            (k, int(dica.get(k, 0)) + int(dicb.get(k, 0))) for
             k in set().union(dica.keys(), dicb.keys()))

    def dic_mul(dic, k):
        for key in dic:
            dic[key] *= k
        return dic

    def char_type(c):
        if c.isdigit():
            return "d"
        elif c.islower():
            return "l"
        elif c.isupper():
            return "C"
        elif c in "{[(":
            return "o"
        elif c in "}])":
            return "c"
        else:
            raise ValueError(c)
    
    match_continued = {"d": ["d"],
                       "l": ["l", "d"],
                       "C": ["l", "d"],
                       "o": [],
                       "c": ["d"]}
    splt = []
    acc = ""
    type_continued = []
    for c in formula:
        if char_type(c) not in type_continued:
            splt += [acc]
            acc = c
            type_continued = match_continued[char_type(c)]
        else:
            acc += c
    splt = splt[1:] + [acc]
            
    stack = [{}]
    for c in splt:
        if char_type(c[0]) == "o":
            stack += [{}]
        elif char_type(c[0]) == "c":
            k =  int(c[1:]) if len(c) > 1  else 1
            to_add = dic_mul(stack.pop(), k)
            stack[-1] = dic_add(stack[-1], to_add)
        elif char_type(c[0]) == "C":
            k = ''.join(p for p in c if p.isdigit())
            atom = ''.join(p for p in c if not(p.isdigit()))
            k = int(k) if len(k) > 0 else 1
            to_add = {atom: k}
            stack[-1] = dic_add(stack[-1], to_add)
        else:
            print char_type(c[0])
            raise ValueError(c, char_type(c[0]))
    return stack[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
ITSOES

from collections import Counter
import re
class C(Counter):
    def __init__(self, string):
        result = re.match('([A-Z][a-z]?)([0-9]*)', string)
        if result:
            k, v = result.groups()
            self.update(Counter([k]*int(v or 1)) + C(string[len(k+v):]))
        elif string:
            k, v = re.match('((?:\[).*?(?:\])|(?:\().*?\)|(?:\{).*?\})([0-9]*)', string).groups()
            self.update(C(k[1:-1]*int(v or 1)) + C(string[len(k+v):]))   
parse_molecule = lambda formula: C(formula)
Best Practices0Clever1
0ForkCompare with your solutionLink
LMH

import re
def parse_molecule (mole):
    ans = {}
    for x in re.findall("(([A-Z][a-z]?)|\{([^\}]+)\}|\[([^\]]+)\]|\(([^\)]+)\))(\d*)", mole):
        if(re.match("[A-Z][a-z]?", x[0])):
            ans[x[0]] = ans[x[0]] + int(x[-1] or 1) if x[0] in ans else int(x[-1] or 1)
        else:
            partialAns = parse_molecule(x[2] or x[3] or x[4])
            ans = {k: ans.get(k, 0) + partialAns.get(k, 0) * int(x[-1] or 1) for k in set(ans) | set(partialAns) }
    return ans
Best Practices0Clever1
0ForkCompare with your solutionLink
jwoest

import collections

def parse_molecule(formula):
    elements = expand_elements(formula)
    return dict(collections.Counter(elements))

def expand_elements(string):
    # expands a formula to a list of elements
    open_brackets = ['(', '{', '[']
    close_brackets = [')', '}', ']']
    
    strcopy = string
    element_list = []

    while strcopy:
        if strcopy[0].isupper():
            token = strcopy[0]
            strcopy = strcopy[1:]
            if strcopy and strcopy[0].islower():
                token += strcopy[0]
                strcopy = strcopy[1:]

        elif strcopy[0] in open_brackets:
            closing_bracket = close_brackets[open_brackets.index(strcopy[0])]
            strcopy = strcopy[1:]

            bracketed = ''
            for c in strcopy:
                if c != closing_bracket:
                    bracketed += c
                    strcopy = strcopy[1:]
                else:
                    strcopy = strcopy[1:]
                    break
            token = expand_elements(bracketed)

        elif strcopy[0] in close_brackets:
            return element_list

        count = 1
        if strcopy and strcopy[0].isdigit():
            number = ''
            while strcopy and strcopy[0].isdigit():
                number += strcopy[0]
                strcopy = strcopy[1:]
            count = int(number)

        if isinstance(token, str):
            element_list += [token] * count
        elif isinstance(token, list):
             element_list += token * count

    return element_list
Best Practices0Clever0
0ForkCompare with your solutionLink
Lsrus

from collections import defaultdict

def parse_molecule(formula):
    atoms = defaultdict(int)
    last = ''
    multiplier = ''
    i = 0
    while i < len(formula):
        character = formula[i]
        if character >= 'a' and character <= 'z':
            last += character
            i += 1
            continue
        elif character >= '1' and character <= '9':
            multiplier += character
            i += 1
            continue
        if last:
            add_to_dictionary(last, multiplier, atoms)
            last = ''
            multiplier = ''
        if character == '(' or character == '[' or character == '{':
            closing_bracket = match_bracket(formula, i)
            last = parse_molecule(formula[i + 1:closing_bracket])
            i = closing_bracket + 1
        else:
            last += character
            i += 1
    if last:
        add_to_dictionary(last, multiplier, atoms)
    return atoms
    
def match_bracket(formula, opening_bracket_pos):
    bracket_count = 1
    for i in range(opening_bracket_pos + 1, len(formula)):
        character = formula[i]
        if character == '(' or character == '[' or character == '{':
            bracket_count += 1
        elif character == ')' or character == ']' or character == '}':
            bracket_count -= 1
            if bracket_count == 0:
                return i
                    
def add_to_dictionary(molecules, multiplier, dictionary):
    if not multiplier:
        multiplier = 1
    if type(molecules) is str:
        dictionary[molecules] += int(multiplier)
    else:
        for atom, quantity in molecules.iteritems():
            dictionary[atom] += quantity * int(multiplier)
Best Practices0Clever0
0ForkCompare with your solutionLink
ValdarMoridin

import re
from collections import defaultdict

def update(d1, d2):
    for k in d2: 
        d1[k] += d2[k]
    return d1

def parse_molecule(formula, outer = True):
    result = defaultdict(int)
    tmp = defaultdict(int)
    while formula:
        atom_match = re.match(r"(?P<element>[A-Z][a-z]?)|(?P<multiplier>\d+)|(?P<subexpr>[[{(])|(?P<endsub>[]})])", formula)
        end = atom_match.span()[1]
        atom, formula = formula[:end], formula[end:]
        if atom_match.group('multiplier'):
            for k in tmp:
                tmp[k] *= int(atom_match.group())
            result = update(result, tmp)
            tmp.clear()
        if atom_match.group('element'):
            result = update(result, tmp)
            tmp.clear()
            tmp[atom_match.group()] = 1 
        if atom_match.group('subexpr'):
            result = update(result, tmp)
            tmp, formula = parse_molecule(formula, False)
        if atom_match.group('endsub'):
            break
    result = update(result, tmp)
    return result if outer else (result, formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
priceethanp

def parse_molecule (formula):
    elements = {}
    currentElement = ""
    currentMultiplier = ""
    multipliers = [1]
    beginBrackets = ["(","[","{"]
    endBrackets = [")","]","}"]
    currentDepth = 1
    for char in reversed(formula):
        if char.isupper():
            #new element, pushout at current multiplier
            currentElement = char+currentElement
            if currentMultiplier != "":
                multipliers.append(int(currentMultiplier))
                currentMultiplier=""
            if currentElement in elements:
                elements[currentElement] += reduce(lambda x, y: x*y, multipliers)
            else:
                elements[currentElement] = reduce(lambda x, y: x*y, multipliers)
            currentElement = ""
            if len(multipliers) > currentDepth:
                multipliers.pop()
        if char.islower():
            currentElement+=char
            if currentMultiplier != "":
                multipliers.append(int(currentMultiplier))
                currentMultiplier=""
        if char.isdigit():
            currentMultiplier = char+currentMultiplier
        if char in beginBrackets:
            multipliers.pop()
            currentDepth-=1
        if char in endBrackets:
            if currentMultiplier != "":
                multipliers.append(int(currentMultiplier))
                currentMultiplier=""
            currentDepth+=1 
            if currentDepth > len(multipliers):
                multipliers.append(1)   

    return elements
Best Practices0Clever0
0ForkCompare with your solutionLink
frall

import urllib, urllib2
import json
def parse_molecule (formula):
    ccurl = 'http://www.chemcalc.org/chemcalc/mf'
    mf = formula.replace('[','(').replace(']',')').replace('{','(').replace('}',')')
    params = {'mf': mf,'isotopomers':'jcamp,xy'}
    response = urllib2.urlopen(ccurl, urllib.urlencode(params))
    jsondata = response.read()
    data = json.loads(jsondata)
    result = []
    for dct in data['parts'][0]['ea']:
      result.append((dct['element'], dct['number']))
    return dict(result)
Best Practices0Clever0
1ForkCompare with your solutionLink
Drymonade

def find_atoms(string):
    result = {}
    for i in range(len(string)):
        if string[i] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ": 
            if i == len(string) - 1:
                result[string[i]] = 0
            elif string[i+1] in "abcdefghijklmnopqrstuvwxyz":
                result[string[i] + string[i+1]] = 0
            elif string[i+1] not in "abcdefghijklmnopqrstuvwyz":
                result[string[i]] = 0
    return result   

def parse_molecule (formula):
    print formula
    
    result = find_atoms(formula)
    
    for k in range(10):
        p = len(formula)
        
        for i in range(p):
            if formula[i] in "123456789":
                                    
                mult = 1
                
                if i < len(formula)-1:
                    if formula[i+1] in "123456789":
                        mult = int(formula[i] + formula[i+1]) - 1
                    else: 
                        mult = int(formula[i])
                else: 
                    mult = int(formula[i])      
                
                    
                
                if formula[i-1] in result.keys():
                    formula = formula[:i-1] + mult*formula[i-1] + formula[i+1:]
                    p = len(formula)
                elif formula[i-2] + formula[i-1] in result.keys():
                    formula = formula[:i-2] + mult*(formula[i-2] + formula[i-1]) + formula[i+1:]
                    p = len(formula)
                elif formula[i-1] == "]":
                    if i < len(formula)-1:
                        if formula[i+1] in "123456789":
                            mult = int(formula[i] + formula[i+1]) - 1
                        else: 
                            mult = int(formula[i])
                    else: 
                        mult = int(formula[i])  
                    for j in range(i-1, 0, -1):
                        if formula[j] == "[":
                            formula = formula[:j] + mult*formula[j+1:i-1] + formula[i+1:]
                            p = len(formula)
                elif formula[i-1] == ")":
                    if i < len(formula)-1:
                        if formula[i+1] in "123456789":
                            mult = int(formula[i] + formula[i+1]) - 1
                        else: 
                            mult = int(formula[i])
                    else: 
                        mult = int(formula[i])  
                    
                    for j in range(i-1, 0, -1):
                        if formula[j] == "(":
                            formula = formula[:j] + mult*formula[j+1:i-1] + formula[i+1:]
                            p = len(formula)
                elif formula[i-1] == "}":
                    if i < len(formula)-1:
                        if formula[i+1] in "123456789":
                            mult = int(formula[i] + formula[i+1]) - 1
                        else: 
                            mult = int(formula[i])
                    else: 
                        mult = int(formula[i])  
                    
                    for j in range(i-1, 0, -1):
                        if formula[j] == "{":
                            formula = formula[:j] + mult*formula[j+1:i-1] + formula[i+1:]
                            p = len(formula)
      
    for i in range(len(formula)):
        if i < len(formula) - 1:
            if formula[i] + formula[i+1] in result.keys():
                 result[formula[i]+formula[i+1]] += 1
            elif formula[i] in result.keys():
                result[formula[i]] += 1
        else: 
            if formula[i] in result.keys():
                result[formula[i]] += 1
      
    print formula
    print result
    return result
    
Best Practices0Clever0
0ForkCompare with your solutionLink
fredfang

def parse_molecule(formula):
    counts = {}
    expansion = expand(formula)
    for i in xrange(0, len(expansion)):
        atom = ''
        if expansion[i].isupper():
            atom += expansion[i]
            for c in expansion[i+1:]:
                if c.islower():
                    atom += c
                else:
                    break
            if atom in counts.keys():
                counts[atom] += 1
            else:
                counts[atom] = 1
    return counts

def expand(formula):
    brackets = {
        ')': '(',
        ']': '[',
        '}': '{',
    }
    expansion = '';
    for i in xrange(0, len(formula)):
        if formula[i].isdigit():
            multiplier = find_multiplier(formula[i:])
            if formula[i-1].isalpha():
                expansion += find_atom(formula[:i]) * multiplier
            elif formula[i-1] in brackets:
                expansion += expand(find_nested_molecule(formula[:i-1], brackets[formula[i-1]])) * multiplier
        elif formula[i].isalpha():
            expansion += formula[i]
    return expansion

def find_multiplier(string):
    multiplier = ''
    for c in string:
        if c.isdigit():
            multiplier += c
        else:
            break
    return int(multiplier) - 1

def find_atom(string):
    atom = ''
    for c in reversed(string):
        atom = c + atom
        if c.isupper():
            return atom

def find_nested_molecule(string, closing_bracket):
    nested_molecule = ''
    for c in reversed(string):
        if c == closing_bracket:
            return nested_molecule
        else:
            nested_molecule = c + nested_molecule
Best Practices0Clever0
0ForkCompare with your solutionLink
IseeVoices

def parse_molecule (formula):
    #for ease of use I transformed the string into a list and made all types of parenthesis be the same : ()
    formula = list(formula.replace("[","(").replace("]",")").replace("{","(").replace("}",")"))
    y = 1
    #now I process the list so that afer every string and ")" there is a number (for example CO2 would be tranformed in C1O2)
    while y<len(formula):
    if formula[y].islower():
      formula[y-1] = formula[y-1] + formula[y]
      del formula[y]
    elif formula[y].isdigit():
      if formula[y-1].isdigit():
        formula[y-1] = formula[y-1] + formula[y]
        del formula[y]
      else:
        y = y + 1
    elif formula[y-1] not in "(" and not formula[y-1].isdigit():
      formula = formula[:y] + ["1"] + formula[y:]
      y = y + 2
    else:
      y = y + 1
    if formula[-1].isalpha():
    formula = formula + ["1"]
    # here I search for parenthesis' and "solve" them
    while formula.count(")"):
        y = formula.index(")")
        aux = int(formula[y+1])
        x = y - 1
        while formula[x]!="(":
            if formula[x].isdigit():
                formula[x] = str(int(formula[x]) * aux)
            x = x - 1
        formula = formula[:x] + formula[x+1:y] + formula[y+2:]
    sol = {}
    x = 0
    while x < len(formula):
    if formula[x] in sol.keys():
      sol[formula[x]] = sol[formula[x]] + int(formula[x+1])
    else:
      sol[formula[x]] = int(formula[x+1])
    x = x + 2

    return sol
Best Practices0Clever0
0ForkCompare with your solutionLink
lubiekielbase

import re
from collections import defaultdict

def split_parents(str):
  parts = []
  cur = ''
  cnt = 0
  for c in str:
    if c in '()[]{}':
      if (cnt == 0 and (c in '({[')) or (cnt == 1 and (c in ')}]')):
        if cur:
          parts.append(cur)
        cur = ''
      else:
        cur += c

      if c in '({[':
        cnt += 1
      else:
        cnt -= 1
    else:
      cur += c

  if cur: parts.append(cur)
  return parts

def parse_simple(formula):
  ans = {}
  for part in re.finditer(r'([A-Z][a-z]*)(\d*)', formula):
    (name, mul) = part.group(1), part.group(2)
    mul = int(mul) if mul else 1
    ans[name] = mul
  return ans

def parse_molecule (formula):
  parts = split_parents(formula)
  if len(parts) == 1:
    return parse_simple(parts[0])

  ans = defaultdict(int)
  for id, p in enumerate(parts):
    cur = parse_molecule(p)
    mul = 1
    if id + 1 < len(parts):
      first_digit = re.search(r'^(\d+)', parts[id+1])
      if first_digit:
        mul = int(first_digit.group(1))
        parts[id+1] = parts[id+1][len(first_digit.group(1)):]
    for k,v in cur.items():
      ans[k] += cur[k]*mul

  return dict(ans)
Best Practices0Clever0
0ForkCompare with your solutionLink
ezetter

import re
from collections import defaultdict

def parse_molecule (formula):
    if len(formula) == 0:
        return {}
    oposing_brackets = {'[':']','{':'}','(':')'}
    num_mols = defaultdict(int)
    rexp1 = re.compile('([\[\{\(])')
    m = rexp1.search(formula)
    muitiplier = 1
    if m:
        p1 = m.span()[0] + 1
        p2 = formula.find(oposing_brackets[m.group(0)])
        num_mols = parse_molecule(formula[p1:p2])
        try:
            muitiplier = int(formula[p2+1])
            for k in num_mols.keys():
                num_mols[k] = num_mols[k] * muitiplier
            r_mols = parse_molecule(formula[p2+2:])
        except ValueError:
            r_mols = parse_molecule(formula[p2+1:])

        l_mols = parse_molecule(formula[:p1-1])
        for k, v in l_mols.iteritems():
            num_mols[k] += int(v)

        for k, v in r_mols.iteritems():
            num_mols[k] += int(v)
        return num_mols
    for mol in re.findall('([A-Z][a-z]?)([1-9]*)',formula):
        if len(mol[1]) > 0:
            num_mols[mol[0]] += int(mol[1])
        else:
            num_mols[mol[0]] += 1
    return num_mols
Best Practices0Clever0
0ForkCompare with your solutionLink
flytaly

def parse_molecule(formula):
    def parser(tokens, mul=1):
        in_bracket = []
        elem_mul = 1
        for token in tokens:
            if not in_bracket:
                if token in brackets:
                    in_bracket = [token, 1]
                    temp = []
                elif token.isdigit():
                    elem_mul = int(token)
                else:
                    result[token] = result.get(token, 0) + elem_mul * mul
                    elem_mul = 1
            else:
                if token == brackets[in_bracket[0]] and in_bracket[1] == 1:
                    parser(temp, mul * elem_mul)
                    elem_mul = 1
                    in_bracket = []
                elif token == brackets[in_bracket[0]] and in_bracket[1] > 1:
                    in_bracket[1] -= 1
                else:
                    temp.append(token)
    
    result = {}
    tokens = []
    brackets = {')': '(', ']': '[', '}': '{', '(': ')', '[': ']', '{': '}'}
    
    for ch in formula:
        if ch.islower():
            tokens[-1] += ch
        elif len(tokens) and tokens[-1].isdigit() and ch.isdigit():
            tokens[-1] += ch
        else:
            tokens.append(ch)


    parser(tokens[::-1])

    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
Pachelbel

stream_pos = 0

def parse_molecule (formula):

    def next_token(move_forward):
        global stream_pos
        state = 0
        kind = None
        text = ''
        pos = stream_pos
        result = None
        while pos < len(formula):
            
            text += formula[pos]
            if state == 0:
                if formula[pos].isalpha():
                    state = 1
                    kind = 'atom'
                elif formula[pos].isdigit():
                    state = 2
                    kind = 'number'
                elif formula[pos] in ['(', '{', '[']:
                    kind = 'lpar'
                    pos += 1
                    break
                elif formula[pos] in [')', '}', ']']:
                    kind = 'rpar'
                    pos += 1
                    break
                else:
                    print 'error'
                    break
            elif state == 1:
                if not formula[pos].isalpha() or formula[pos].isupper():
                    text = text[:-1]
                    break
            elif state == 2:
                if not formula[pos].isdigit():
                    text = text[:-1]
                    break
            pos += 1

        if move_forward:
            stream_pos = pos
        if kind is None:
            return ('eof', '')
        return (kind, text)

    # molecule ::= 
    #               <ATOM> NUMBER? molecule 
    #               | LPAR molecule RPAR number? molecule?

    def molecule():
        global stream_pos
        result = {}
      
        (type, text) = next_token(True)
        intermediate = {}

        if type == 'eof':
            return {}
        elif type == 'atom':
            intermediate[text] = 1
        elif type == 'lpar':
            intermediate = molecule()
            # consume rpar
            closing_par_token = next_token(True)
            if closing_par_token[0] != 'rpar':
                return {}
        # number ?
        (type, text) = next_token(False)

        if type == 'number':
            number = next_token(True) # consume token
            count = int(number[1])

            for key in intermediate:
                intermediate[key] = intermediate[key]*count
        (type, text) = next_token(False)
        if type in ['number', 'atom', 'lpar']:
            result = molecule()
        else:
            result = {}
        # merge the dicts
        for key in intermediate:
            result[key] = result.setdefault(key, 0) + intermediate[key]
        return result

    global stream_pos 
    stream_pos = 0
    result = molecule()
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
tjbk

import re
def parse_molecule(formula):
    res = {}
    #Convert square and flower brackets to parenthesis
    if(re.search(r"\[", formula)):
        formula = re.sub(r"\[",r"(",formula)
        formula = re.sub(r"\]",r")",formula)
    if(re.search(r"\{", formula)):
        formula = re.sub(r"\{",r"(",formula)
        formula = re.sub(r"\}",r")",formula)
    while(re.search(r"\(", formula)):
        formula = yes_brackets(formula)
    print formula
    res = no_brackets(formula)
    return res

def no_brackets(formula):
    res = {}
    elements = re.findall(r"([A-Z][a-z]?)(\d\d?)*", formula)
    for elem in elements:
        atm = 1
        if (elem[1] != ''):
            atm = elem[1]
        if(elem[0] not in res):
            res[elem[0]] = int(atm)
        else:
            res[elem[0]] += int(atm)
    return res

def yes_brackets(formula):
    match4 = re.search(r"\([\w\d]+\)(\d\d?)*", formula);
    newform = "" 
    if match4:
        num = ""
        if match4.group(1):
            num = match4.group(1)
            innerContent = ""
            elements = re.findall(r"([A-Z][a-z]?)(\d\d?)*", match4.group())
            for elem in elements:
                innerContent += elem[0]
                if(elem[1] == ''):
                    atm =1
                else:
                    atm = elem[1]
                innerContent += str(int(num) * int(atm))
        else:
            innerContent = re.sub(r"\(", r"", match4.group())
            innerContent = re.sub(r"\)", r"", innerContent)
        newform = re.sub(r"\([\w\d]+\)(\d)?", innerContent, formula, 1)
        match4 = re.search(r"\([\w\d]+\)(\d)?", newform);
    if newform:
        formula = newform
    return formula

Best Practices0Clever0
0ForkCompare with your solutionLink
linnal

import re
from collections import deque

def parse_molecule (formula):
    container = {}
    m1 = re.compile("[A-Z][a-z]?|[1-9]+|[\{\}\(\)\[\]]")
    res = reversed(m1.findall(formula))
    # print res

    _mul = 1
    _temp = 1
    _mul_queue = deque()
    for i, elem in enumerate(res):
        if elem.isdigit():
            _temp = int(elem)
            pass
        elif elem.isalpha():
            if elem in container:
                container[elem] += _mul * _temp
            else:
                container[elem] = _mul * _temp
            _temp = 1

        else:
            if elem == "}" or elem == ")" or elem == "]":
                _mul_queue.append(_temp)
                _mul *= _temp
                pass
            else:
                _mul = _mul/_mul_queue.pop()

            _temp = 1

    return container
Best Practices0Clever0
0ForkCompare with your solutionLink
fxxf

     
       
import re

def parse_molecule (formula):
    close_par = '{[('
    open_par = "}])"

    atoms = {}

    regexp = re.compile("[A-Z][a-z]?|[1-9][0-9]*|[\{\}\[\]\(\)]")

    mul_temp = 1
    mul_stack = 1
    stack = []

    for c in reversed(regexp.findall(formula)):

        if c.isdigit():
            mul_temp = int(c)
        elif c in open_par:
            stack.append((c, mul_temp))
            mul_stack *= mul_temp
            mul_temp = 1
        elif c in close_par:
            if len(stack)>0:
                par, mul = stack.pop()
                mul_stack = mul_stack // mul
        else:
            prev_value = atoms[c] if c in atoms else 0
            atoms[c] = prev_value + mul_temp * mul_stack
            mul_temp = 1

    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
00kevn

from string import ascii_lowercase, ascii_uppercase, digits

class Molecule:
    def __init__(self, atom=None):
        self.atoms = {}
        if atom:
            self.atoms[atom] = 1
    
    def __mul__(self, other):
        for atom, count in self.atoms.iteritems():
            self.atoms[atom] = count*other
        return self       
    
    def __add__(self, other):
        if len(other.atoms.keys()) == 0:
            return
        for atom, count in other.atoms.iteritems():
            if atom in self.atoms:
                self.atoms[atom] += count
            else:
                self.atoms[atom] = count
        return self
    
    def __len__(self):
        return len(self.atoms.keys())
    
    def __repr__(self):
        return str(self.atoms)
    
    def __str__(self):
        return str(self.atoms)

def parse_molecule (formula):
    stack = []
    chars = list(formula)
    molecule = Molecule()
    while  len(chars) > 0: 
        c = chars.pop(0)
        if c in ascii_uppercase:
            if len(chars) > 0 and chars[0] in ascii_lowercase:
                c+= chars.pop(0)
            stack.append(Molecule(c))
        elif c in digits:
            multiplier = int(c)
            while len(chars) > 0 and chars[0] in digits:
                multiplier = multiplier * 10 + int(chars.pop(0))
            stack.append(stack.pop()*multiplier)
        elif c in '([{':
            stack.append(c)
        elif c in ')]}':
            m = stack.pop()
            next = stack.pop()
            while str(next) not in '({[':
                m = m + next
                next = stack.pop()
            stack.append(m)
    while len(stack) > 1:
        stack.append(stack.pop() + stack.pop())
    return stack[0].atoms
            
        
Best Practices0Clever0
0ForkCompare with your solutionLink
00kevn

from string import ascii_lowercase, ascii_uppercase, digits

class Molecule:
    def __init__(self, atom=None):
        self.atoms = {}
        if atom:
            self.atoms[atom] = 1
    
    def __mul__(self, other):
        for atom, count in self.atoms.iteritems():
            self.atoms[atom] = count*other
        return self       
    
    def __add__(self, other):
        if len(other.atoms.keys()) == 0:
            return
        for atom, count in other.atoms.iteritems():
            if atom in self.atoms:
                self.atoms[atom] += count
            else:
                self.atoms[atom] = count
        return self
    
    def __len__(self):
        return len(self.atoms.keys())
    
    def __repr__(self):
        return str(self.atoms)
    
    def __str__(self):
        return str(self.atoms)

def parse_molecule (formula):
    stack = []
    chars = list(formula)
    molecule = Molecule()
    # TODO, change how this is done. it clearly needs to be a stack
    # You push atoms and [()] to the stack  and you pop when you hit 
    # a multiplier or the end. Easy peasy
    while  len(chars) > 0: 
        c = chars.pop(0)
        if c in ascii_uppercase:
            if len(chars) > 0 and chars[0] in ascii_lowercase:
                c+= chars.pop(0)
            stack.append(Molecule(c))
        elif c in digits:
            multiplier = int(c)
            while len(chars) > 0 and chars[0] in digits:
                multiplier = multiplier * 10 + int(chars.pop(0))
            stack.append(stack.pop()*multiplier)
        elif c in '([{':
            stack.append(c)
        elif c in ')]}':
            m = stack.pop()
            next = stack.pop()
            while str(next) not in '({[':
                m = m + next
                next = stack.pop()
            stack.append(m)
    while len(stack) > 1:
        stack.append(stack.pop() + stack.pop())
    return stack[0].atoms
            
        
Best Practices0Clever0
0ForkCompare with your solutionLink
clneto

def parse_molecule (formula):
    pair = { '[' : ']', '{' : '}', '(' : ')'}     
    def get_quantity(formula, k):
        many = 1
        o_k = k+1
        if(o_k < len(formula) and formula[o_k].isdigit()):
            size = 1
            while(o_k+size<len(formula) and formula[o_k+size].isdigit()):
                size += 1
            many = int(formula[o_k:o_k+size])
            k = o_k+size
        else:
            k = o_k
        return k, many
        
    def parse_step(formula):
        print(formula)
        form_dic = dict()
        k = 0
        while k < len(formula):
            letter = formula[k]
            if(letter == '[' or letter == '{' or letter == '('):
                closes_at = k + list(formula[k:]).index(pair[letter])
                sub_dic = parse_step(formula[k+1:closes_at])
                k, many = get_quantity(formula, closes_at)
                for key in sub_dic:
                    sub_dic[key] = sub_dic[key]*many
                    if key in form_dic:
                        form_dic[key] += sub_dic[key]
                    else:
                        form_dic[key] = sub_dic[key]
                                
            elif(not letter.isdigit() and letter.isupper()):
                o_k = k+1
                while(o_k < len(formula) and formula[o_k].islower()):
                    o_k += 1
                elem = formula[k:o_k]
                k, many = get_quantity(formula, o_k-1)
                if not elem in form_dic:
                    form_dic[elem] = many
                else:
                    form_dic[elem] += many
            else:
                k+=1
        return form_dic
                
    return parse_step(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
pio_05

start_braces = '{[('
end_braces = '}])'


def parse_molecule(formula):
    answer = {}
    i = 0
    while i < len(formula):
        if is_capital_letter(formula[i]):
            j = i + 1
            try:
                while is_n_capital_letter(formula[j]):
                    j += 1
            except IndexError:
                pass
            atom = formula[i:j]
            n, i = check_number(formula, j)
            if atom in answer:
                answer[atom] += n
            else:
                answer[atom] = n

        if i >= len(formula):
            break

        if formula[i] in start_braces:
            sb = start_braces.find(formula[i])
            eb = end_braces[sb]
            bn = 1
            j = i + 1
            while bn != 0:
                if formula[j] == sb:
                    bn += 1
                elif formula[j] == eb:
                    bn -= 1
                j += 1
            inner_answer = parse_molecule(formula[i + 1:j - 1])
            n, i = check_number(formula, j)
            for k, v in inner_answer.iteritems():
                if k in answer:
                    answer[k] += v * n
                else:
                    answer[k] = v * n

    return answer


def is_letter(c):
    if c in start_braces or c in end_braces or c.isdigit():
        return False
    return True


def is_capital_letter(c):
    if is_letter(c) and c.upper() == c:
        return True
    return False


def is_n_capital_letter(c):
    if is_letter(c) and not is_capital_letter(c):
        return True
    return False


def check_number(formula, j):
    try:
        if formula[j].isdigit():
            k = j + 1
            try:
                while formula[k].isdigit():
                    k += 1
                n = int(formula[j:k])
            except IndexError:
                try:
                    n = int(formula[j:k-1])
                except ValueError:
                    n = int(formula[j])
        else:
            k = j
            n = 1
    except IndexError:
        n = 1
        k = j
    return n, k
Best Practices0Clever0
0ForkCompare with your solutionLink
Fikar

import string
def parse_molecule (formula):
    upper = string.uppercase
    lower = string.lowercase
    digits = string.digits
    start = '([{'
    terminal = ')]}'
    stack = []
    priority = []
    elements = {}
    for i,char in enumerate(formula):
        if char in start:
            stack.append({})
            priority.append(char)
        elif char in terminal:
            nested = stack.pop(-1)
            priority.pop(-1)
            if i<len(formula)-1 and formula[i+1] in digits:
                num = ''
                while i<len(formula)-1 and formula[i+1] in digits:
                    num += formula[i+1]
                    i += 1
                for k,v in nested.items():
                    nested[k] = v*int(num)
            if priority:
                for k,v in nested.items():
                    stack[-1][k] = stack[-1].get(k,0)+v
            else:
                for k,v in nested.items():
                    elements[k] = elements.get(k,0)+v
        elif char in upper:
            element = char
            while i<len(formula)-1 and formula[i+1] in lower:
                element+=formula[i+1]
                i+=1
            num = ''
            while i<len(formula)-1 and formula[i+1] in digits:
                num += formula[i+1]
                i += 1
            num = int(num) if num else 1
            if priority:
                stack[-1][element] = stack[-1].get(element,0)+num
            else:
                elements[element] = elements.get(element,0)+num
    return elements
            
Best Practices0Clever0
0ForkCompare with your solutionLink
Anton-Baton

import re
from collections import defaultdict
OPEN = "([{"
CLOSE = ")]}"
def parse_molecule(formula):
    print formula
    elems = re.findall(r"[\)\]\x7b]|[\(\[\x7d]|[A-Z][a-z]?|[\d]+", formula)

    last = elems[0]
    elements = [last]
    for elem in elems[1:]:
        if not last.isdigit() and not elem.isdigit() and last not in OPEN + CLOSE:
            elements.append('1')
            # last = '1'

        last = elem
        elements.append(elem)
        #last = elem
    if elements[-1].isalpha():
        elements.append('1')

    print elements
    d = defaultdict(int)
    f = list()
    nested = list()
    for elem in elements:
        if elem not in CLOSE:
            if nested:
                if elem.isdigit():
                    num = int(elem)
                    for part in nested:
                        if part.isdigit():
                            part = str(int(part)*num)
                        f.append(part)

                else:
                    f.extend(nested)
                    f.append(elem)

                nested = []
            else:
                f.append(elem)
        else:
            poped = f.pop()
            while poped not in OPEN:
                nested.append(poped)
                poped = f.pop()
            nested.reverse()
    char = f[0]
    for elem in f[1:]:
        if elem.isdigit():
            d[char] += int(elem)
        else:
            char = elem
    return dict(d.items())
    
    
    
Best Practices0Clever0
0ForkCompare with your solutionLink
scottaconnors

def parse_molecule (formula):
    open_brackets = ['(', '{', '[']
    close_brackets = [')', '}', ']']
    atom = ""
    digs = ""
    mult = 1
    mult_stack = [1]
    res = {}
    
    for idx in range(len(formula) - 1, -1, -1):
        ch = formula[idx]
        nxt = formula[idx - 1] if idx > 0 else None
            
        if ch.isdigit():
            digs = ch + digs
            if nxt.isalpha():
                mult = int(digs)
        elif ch in close_brackets:
            if digs:
                mult_stack.append(int(digs))
                digs = ""
        elif ch in open_brackets:
            if len(mult_stack) > 1:
                mult_stack.pop()
        elif ch.isupper():
            atom = ch + atom
            mult *= reduce(lambda x, y: x*y, mult_stack)
            res[atom] = res[atom] + mult if atom in res else mult
            mult = 1
            digs = ""
            atom = ""
        elif ch.islower():
            atom = ch + atom

    return res        
            
            
Best Practices0Clever0
0ForkCompare with your solutionLink
NatiAris

import re
def parse_molecule (formula):
    al = set(re.findall('[A-Z][a-z]*', formula))
    atoms = dict([(t,0) for t in al])
    parsed = re.findall('([A-Z][a-z]?|\d+|\W)', formula)
    parsed.reverse()
    brackets = {')' : '(', ']' : '[', '}' : '{'}
    stack = [1]
    for elem in parsed:
        try:
            temp = int(elem)
            stack.append(temp)
        except ValueError:
            if elem in brackets.values():
                stack.pop()
                stack.pop()
            elif elem in brackets.keys():
                stack.append(elem)
            else:
                mult = 1
                for el in stack:
                    if type(el) == int:
                        mult *= el
                atoms[elem] += mult
                if (type(stack[-1]) == int) and len(stack) > 1:
                    stack.pop()
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
Robin_Jadoul

from collections import Counter
def _parse_molecule (formula):
    def get_number():
        s = ""
        while formula and formula[0].isdigit():
            s += formula.pop(0)
        if s:
            return int(s)
        return 1

    d = Counter()
    if not formula:
        return d
        
    while formula:
        if formula[0] in ")}]":
            formula.pop(0)
            n = get_number()
            for k in d:
                d[k] *= n
            return d
        elif formula[0] in "({[":
            formula.pop(0)
            d.update(_parse_molecule(formula))
        else:
            s = formula.pop(0)
            while formula and formula[0].islower():
                s += formula.pop(0)
            d[s] += get_number()
    return d
    
def parse_molecule(formula):
    return dict(_parse_molecule(list(formula)))
Best Practices0Clever0
0ForkCompare with your solutionLink
p.rzepecki

import re

def parse_molecule (formula):
    stack, result = [], {}
    if isinstance(formula, basestring):
        tokens = [t for t in re.split('([0-9]+|[A-Z][a-z]*|\(|\)|\{|\}|\]|\[)', formula) if t]
    else:
        tokens = formula
    brackets = {'}': '{', ']': '[', ')': '('}
    stack = []
    for token in tokens:
        if isinstance(token, dict):
            for k, v in token.items():
                result[k] = result.get(k, 0) + v
        elif token.isdigit():
            element = stack.pop()
            if isinstance(element, basestring):
                stack.append({element: int(token)})
            elif isinstance(element, dict):
                stack.append({
                    k: v * int(token)
                for (k, v) in element.items()})
            else:
                raise ValueError(element)
        elif token.isalpha():
            stack.append(token)
        else:
            if token in brackets.values():
                stack.append(token)
            else:
                element = None
                molecule = []
                while element != brackets[token]:
                    element = stack.pop()
                    if element != brackets[token]:
                        molecule.append(element)
                stack.append(parse_molecule(molecule[::-1]))
    while stack:
        element = stack.pop()
        if isinstance(element, dict):
            for k, v in element.items():
                result[k] = result.get(k, 0) + v
        elif isinstance(element, basestring):
            result[element] = result.get(element, 0) + 1
    return result                
                    
Best Practices0Clever0
0ForkCompare with your solutionLink
a_duhovnik

def parse_molecule (formula):
    f = ''.join((reversed(formula)))
    f = str(f)
    print(f)
    d = dict()
    mul = 1
    next = 1
    mn = []
    strr = ''
    i = 0
    while i < len(f):
        ch = f[i]
        k = i+1
        if '0' <= str(ch) <= '9':
            while '0' <= str(f[k]) <= '9':
                ch += str(f[k])
                k += 1
            i = k - 1
            ch = ''.join(reversed(ch))
            print(ch, 'before')
            ch = int(ch)
            print(ch, 'after')
            next = ch
        if ch in [']', ')', '}']:
            mul *= next
            mn.append(next)
            next = 1
        if ch in ['[', '(', '{']:
            mul /= mn.pop()
        if 'a' <= str(ch) <= 'z':
            strr += str(ch)
        if 'A' <= str(ch) <= 'Z':
            strr += str(ch)
            ch = ''.join(reversed(strr))
            if not ch in d.keys():
                d[ch] = next*mul
            else:
                d[ch] += next*mul
            next = 1
            strr = ''
        i += 1
    print(d)
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
nonZero

#! python3
from collections import Counter


def count(stack):
    d = Counter()
    symbol = None
    for x in stack:
        if isinstance(x, str) and x.isalpha():
            symbol = Counter({x: 1})
            d += symbol
            continue
        if isinstance(x, Counter):
            symbol = x
            d += symbol
            continue
        if x.isdigit():
            assert symbol
            d += mul(symbol, int(x) - 1)
            symbol = None
            continue
        assert False
    return d


def mul(c, n):
    return Counter({k: v * n for k, v in c.items()})


def parse_molecule(formula):
    previous = []
    current = []
    for c in formula:
        if c.isupper():
            current.append(c)
            continue
        if c.islower():
            assert current[-1].isalpha()
            current[-1] += c
            continue
        if c.isdigit():
            if isinstance(current[-1], str) and current[-1].isdigit():
                current[-1] += c
            else:
                current.append(c)
            continue
        if c in "([{":
            previous.append(current)
            current = []
            continue
        if c in "})]":
            d = count(current)
            current = previous.pop()
            current.append(d)
            continue
        assert False

    return dict(count(current))
Best Practices0Clever0
0ForkCompare with your solutionLink
ver0man

import re


def parse_molecule(formula):
    # Parse the bracket.. multiply element inside bracket by the number outside
    patterns = ['\([^\)]+\)\d?', '\[[^\]]+\]\d?', '\{[^\}]+\}\d?']
    for pattern in patterns:
        matches = re.findall(pattern, formula)
        for match in matches:
            alt = parse_bracket(match[1:-2], int(match[-1])) if match[-1].isdigit() else parse_bracket(match[1:-1], 1)
            formula = formula.replace(match, alt)

    # Add up all molecule numbers
    molecule = {key: 0 for key in re.findall('[A-Z][a-z]?', formula)}
    keys = re.findall('[A-Z][a-z]?\d*', formula)
    for key in keys:
        if key[-1].isdigit():
            name, num = ''.join([char for char in key if char.isalpha()]), ''.join([char for char in key if char.isdigit()])
            molecule[name] += int(num)
        else:
            molecule[key] += 1

    return molecule


def parse_bracket(string, times):
    elements = re.findall('[A-Z][a-z]?\d*', string)
    alt = ''
    for element in elements:
        if element[-1].isdigit():
            alt += ''.join([char for char in element if char.isalpha()]) + str(int(''.join([char for char in element if char.isdigit()])) * times)
        else:
            alt += element + str(times)
    return alt
Best Practices0Clever0
0ForkCompare with your solutionLink
smw5qz

def parse_molecule (f):
    #create empty dict and convert formula to list
    d = {}
    f = list(f) 
    #prepare molecule list, with two important features:
    #--grouping lowercase letters with capital letter to left
    #--grouping side-by-size digits together, to be double digit # 
    i = 0
    count = len(f)
    while i < count:
      if f[i].islower():
        f[i-1] = f[i-1] + f[i]
        del f[i]
        count = count - 1
      elif (i+1) < count and f[i].isdigit() and f[i+1].isdigit():
        f[i] = f[i] + f[i+1]
        del f[i+1]
        count = count - 1
      i=i+1
    print f
    
    #create array to hold counts for atoms, w/ len = len(f)
    index = [1 for i in range(len(f))]

    #set dict values for atoms in list to be 0
    for x in range(len(f)):
      if f[x].isalpha():
        d[f[x]] = 0
    
    #arrays to find opening and closing brackets
    close = [')','}',']']
    opens = ['(','{','[']
    
    #update index with counts
    for x in range(len(f)):
      #handles numbers with symbol to left
      if f[x].isdigit() and f[x-1].isalpha():
        index[x-1] = index[x-1] * int(f[x])
      #handles numbers with closing bracket to left
      elif f[x].isdigit() and close.index(f[x-1]) != -1:
        for y in range(len(f)-x,len(f)):
          if list(reversed(f))[y] in opens and opens.index(list(reversed(f))[y]) == close.index(f[x-1]):
            for z in range(len(f)-y,x):
              if f[z].isalpha():
                index[z] = index[z] * int(f[x])
            break
                
    #update dict to reflect2 totals for each atom
    for x in range(len(f)):
      if f[x].isalpha():
        d[f[x]] = d[f[x]] + index[x]
    #return dict
    return d
      
      
Best Practices0Clever0
0ForkCompare with your solutionLink
thomasjpfan

import re
from collections import Counter

def parse_molecule (formula):
  def next_molecule(position):
    view = formula[position:]
    match = re.match('(?P<name>[A-Z][a-z]*)(?P<amount>\d*)', view)
    amount = match.group('amount')
    name = match.group('name')
    length = len(amount) + len(name)
    amount = int(match.group('amount')) if match.group('amount') else 1
    return {match.group('name'): amount}, position + length
  def next_amount(position):
    if position == len(formula):
      return 1, position
    view = formula[position:]
    match = re.match('(?P<amount>\d*)', view)
    amount = match.group('amount')
    length = len(amount)
    amount = int(match.group('amount')) if match.group('amount') else 1
    return amount,  position + length
    
  molecule_stack = [Counter({})]
  i = 0
  while (i < len(formula)):
    current_char = formula[i]
    if current_char in ['[', '{', '(']:
      i += 1
      molecule_stack.append(Counter({}))
      continue
    elif current_char in [']', '}', ')']:
      amount, i = next_amount(i+1)
      last = molecule_stack.pop()
      last =  Counter({k:amount*v for k, v in last.iteritems()})
      # update intelligently
      molecule_stack[-1] += last
      continue
        
    # Get number
    molecule, i = next_molecule(i)
    molecule_stack[-1] += Counter(molecule)
      
  return dict(molecule_stack[0])
Best Practices0Clever0
0ForkCompare with your solutionLink
akvachov

def parse_molecule(formula):
    def parse_element(key):
        s = key
        if formula[key].isalpha() and formula[key].isupper():
            key += 1
            while key < len(formula) and formula[key].isalpha() and formula[key].islower():
                key += 1
            return formula[s:key], key
        else:
            return None
            
    def parse_number(key):
        s = key
        while key < len(formula) and formula[key].isdigit():
            key += 1
        
        return (1, s) if s == key else (int(formula[s:key]), key)
            
    brackets = {'}': '{', ')': '(', ']': '['}
    brackets_stack = []
    elements = []
    i = 0
    while i < len(formula):
        elem = parse_element(i)
        if elem is not None:
            el, i = elem
            number, i = parse_number(i)
            elements.append((el, number))
        elif formula[i] in brackets.values():
            brackets_stack.append((formula[i], len(elements)))
            i += 1
        elif formula[i] in brackets:
            if not len(brackets_stack) or brackets_stack[-1][0] != brackets[formula[i]]:
                return False
            i += 1
            number, i = parse_number(i)
            _, key = brackets_stack.pop()
            
            while key < len(elements):
                elements[key] = (elements[key][0], elements[key][1] * number)
                key += 1
            
        else:
            return False

    if len(brackets_stack):
        return False
    else:
        result = {}
        for el in elements:
            if el[0] in result:
                result[el[0]] += el[1]
            else:
                result[el[0]] = el[1]
        return result
Best Practices0Clever0
0ForkCompare with your solutionLink
chessmanyaki

import re

def parse_molecule (formula):
    formula = re.sub('[\[\{]', '(', formula)
    formula = re.sub('[\]\}]', ')', formula)
    n = len(formula)
    temp = []
    i = 0
    while i < n:
        if formula[i].isupper():
            temp.append(formula[i])
            i += 1
        elif formula[i].islower():
            temp[-1] += formula[i]
            i += 1
        elif formula[i].isdigit():
            val = 0
            while i < n and formula[i].isdigit():
                val = val * 10 + ord(formula[i]) - ord('0')
                i += 1
            temp.append(val)
        else:
            temp.append(formula[i])
            i += 1
    res = [{}]
    n = len(temp)
    i = 0
    while i < n:
        if re.match(r'^[A-Z][a-z]?$', temp[i]):
            elem = temp[i]
            if i + 1 < n and isinstance(temp[i + 1], int):
                cc = temp[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            if not elem in res[-1]:
                res[-1][elem] = cc
            else:
                res[-1][elem] += cc
        elif temp[i] == '(':
            res.append({})
            i += 1
        elif temp[i] == ')':
            if i + 1 < n and isinstance(temp[i + 1], int):
                cc = temp[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            for k in res[-1]:
                if not k in res[-2]:
                    res[-2][k] = cc * res[-1][k]
                else:
                    res[-2][k] += cc * res[-1][k]
            res.pop()
    return res.pop()
Best Practices0Clever0
0ForkCompare with your solutionLink
pkut

def parse_elem(formula, pos):
    elem_name = ""
    elem_count = 1
    end_pos = pos
    if formula[pos].isupper():
        end_pos = pos + 1
        if end_pos < len(formula) and formula[end_pos].islower():
            end_pos += 1
        elem_name = formula[pos:end_pos]
        if end_pos < len(formula) and formula[end_pos].isdigit():
            start_pos = end_pos
            while end_pos < len(formula) and formula[end_pos].isdigit():
                end_pos += 1
            
            elem_count = int(formula[start_pos:end_pos])
        return (end_pos, elem_name, elem_count)
    #dealing with a group
    return (pos, None, None)       

def parse_subgroup(formula, pos):
    opening_char = formula[pos]
    if opening_char == '(':
        closing_char = ')'
    elif opening_char == '[':
        closing_char = ']'
    elif opening_char == '{':
        closing_char = '}'
    else:
        raise ValueError("Not a subgroup to parse")
        
    nesting = 1
    end_pos = pos + 1
    
    while nesting and end_pos < len(formula):
        if formula[end_pos] == opening_char:
            nesting += 1
        elif formula[end_pos] == closing_char:
            nesting -= 1
        end_pos += 1
        
    if nesting:
        raise ValueError("Unmatched brackets")
    
    multiplier = 1
    if end_pos < len(formula) and formula[end_pos].isdigit():
        start_num_pos = end_num_pos = end_pos
        while end_num_pos < len(formula) and formula[end_num_pos].isdigit():
            end_num_pos += 1        
        multiplier = int(formula[start_num_pos:end_num_pos])
        
    inner_counts = parse_molecule(formula[pos+1:end_pos-1])
    
    if multiplier > 1:
        end_pos = end_num_pos
        for k in inner_counts:
            inner_counts[k] *= multiplier  
            
    return end_pos, inner_counts

from collections import defaultdict

def parse_molecule (formula):
    pos = 0
    outdict = defaultdict(int)
    while pos < len(formula):
        pos, elem_name, elem_count = parse_elem(formula, pos)
        if elem_name:
            outdict[elem_name] += elem_count
        else:
            pos, inner_counts = parse_subgroup(formula, pos)
            for k in inner_counts:
                outdict[k] += inner_counts[k]
    return outdict
            
    pass
Best Practices0Clever0
0ForkCompare with your solutionLink
advant, MMMAAANNN

import re
def parse_molecule (formula):
    for br in "[{":
        formula = formula.replace(br, "(")
    for br in "]}":
        formula = formula.replace(br, ")")
    while "(" in formula:
        clsbr = formula.find(")")
        opnbr = clsbr - formula[:clsbr][::-1].find("(")
        subformula = formula[opnbr:clsbr]
        subindex = re.match("\)([0-9]*)", formula[clsbr:]).group(1)
        z = "(" + subformula + ")" + subindex
        subindex = 1 if not subindex else int(subindex)
        simplified = [str(a) + str(n * subindex) for a, n in parse_molecule(subformula).iteritems()]
        formula = formula.replace(z, ''.join(simplified))
    formula = re.sub("([a-zA-Z0-9])([A-Z])", r"\1 \2", formula)
    formula = re.sub("([a-zA-Z0-9])([A-Z])", r"\1 \2", formula)
    formula = re.sub("([A-Za-z]+)([0-9]*)", r"\1:\2", formula)
    els = [element.split(":") for element in formula.split(" ")]
    elements = [(el[0], (int(el[1]) if el[1] else 1)) for el in els]
    atoms = {}
    for a, n in elements:
        if a not in atoms:
            atoms[a] = n
        else:
            atoms[a] += n
    return atoms
Best Practices0Clever1
0ForkCompare with your solutionLink
BillTuer

braces = {")": "(", "}": "{", "]": "["}

def applyModifier(mdict, mul):
    for key in mdict:
        mdict[key] *= mul

def readAtom(molecule, index):
    result = molecule[index]
    index += 1
    while index < len(molecule) and molecule[index].islower():
        result += molecule[index]
        index += 1
    return (result, index)

def readNumber(molecule, index):
    result = ""
    while index < len(molecule) and molecule[index].isdigit():
        result += molecule[index]
        index += 1
    return (int(result), index)

def scanForSub(molecule, index):
    stack = [molecule[index]]
    index += 1
    while index < len(molecule):
        current = molecule[index]
        if current in braces:
            if stack.pop() != braces[current]:
                raise AttributeError("Brace Error: %s %s" % (molecule, index))
        elif current in braces.values():
            stack.append(current)
        if len(stack) < 1:
            return index
        index += 1

def parse_molecule(molecule):
    stack = []
    index = 0
    while index < len(molecule):
        current = molecule[index]
        if current.isdigit():
            multiplier, index = readNumber(molecule, index)
            applyModifier(stack[-1], multiplier)
        elif current.isalnum():
            atom, index = readAtom(molecule, index)
            stack.append({atom: 1})
        elif current in braces.values():
            subend = scanForSub(molecule, index)
            sub = molecule[index+1:subend]
            index = subend+1
            subDict = parse_molecule(sub)
            stack.append(subDict)
    result = {}
    for sDict in stack:
        for mol, count in sDict.items():
            if mol not in result:
                result[mol] = 0
            result[mol] += count
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
abednego

from collections import defaultdict
import re

def parse_molecule (f):
  brackets = ["()", "[]", "{}"]
  regexes = map(
    lambda s: re.compile(r"\%s(.*?)\%s([0-9]*)" % (s[0], s[1])),
    brackets)
  
  while True:
    for r in regexes:
      m = r.search(f)
      if m is not None:
        cnt = int(m.group(2)) if m.group(2) else 1
        f = f[:m.start(0)] + m.group(1) * int(cnt) + f[m.end(0):]
        break
    else:
      break
      
  regex = re.compile(r"([A-Z][a-z]?)([0-9]*)")
  ans = defaultdict(int)
  while f:
    m = regex.search(f)
    assert m is not None
    assert m.start(0) == 0
    cnt = int(m.group(2)) if m.group(2) else 1
    ans[m.group(1)] += cnt
    f = f[m.end(2):]
    
  return ans
Best Practices0Clever0
0ForkCompare with your solutionLink
GLUTEN_FREE_EBOLA

def parse_molecule(formula):
    #THIS IS
    #THE WORST PROGRAM 
    #EVER WRITTEN
    atom_dict = {}

    
        
    def count_atom(formula, atom_dict, moltimes, molmol):
        atom = ''
        n = 0 
        while formula != '':
            if len(formula) == 1:
                if formula not in atom_dict:
                    atom_dict[formula] = 0
                atom_dict[formula] += moltimes*molmol
                formula = ''
            else:
                if formula[n+1].isupper():
                    if formula[n] not in atom_dict:
                        atom_dict[formula[n]] = 0
                    atom_dict[formula[n]] += moltimes*molmol
                    formula = formula[1:]
                else:
                    if formula[n+1].isdigit():
                        num = ''
                        j = n
                        while formula[j+1].isdigit():
                            num+= formula[j+1]
                            j+= 1
                            if j == len(formula) -1:
                                break
                        if formula[n] not in atom_dict:
                            atom_dict[formula[n]] = 0
                        atom_dict[formula[n]] += int(num)*moltimes*molmol
                        formula = formula[1+len(num):] ####
                    else:
                        if formula[n+1].islower() and n+2 == len(formula):
                            if formula not in atom_dict:
                                atom_dict[formula] = 0
                            atom_dict[formula] += moltimes*molmol
                            formula = ''
                        else: 
                            if formula[n+1].islower() and formula[n+2].isupper():
                                if formula[n:n+2] not in atom_dict:
                                    atom_dict[formula[n:n+2]] = 0
                                atom_dict[formula[n:n+2]] += moltimes*molmol
                                formula = formula[2:]
                            else:
                                num = ''
                                j = n
                                while formula[j+2].isdigit():
                                    num+= formula[j+2]
                                    j+= 1
                                    if j+2 == len(formula):
                                        break
                                if formula[n:n+2] not in atom_dict:
                                    atom_dict[formula[n:n+2]] = 0
                                atom_dict[formula[n:n+2]] += int(num)*moltimes*molmol           
                                formula = formula[len(num)+2:]                        
        return formula, atom_dict, moltimes, molmol   
    
    
      
                            
    def count_molecule(formula, atom_dict, moltimes, molmol):
        molmol = 1
        while '(' in formula:
            atoms = ''
            num =''
            atoms+= formula[formula.index('('):formula.index(')')+1]
            if formula[formula.index(')')+1].isdigit():
                num = ''
                j = formula.index(')')+1
                while formula[j].isdigit():
                    num+= formula[j]
                    j+= 1
                    if j == len(formula):
                        break            
            if num != '':
                molmol *= int(num)  
            count_atom(atoms[1:-1], atom_dict, moltimes, molmol)    
            molmol = 1  ########
            formula = formula[:formula.index('(')] +formula[formula.index(')')+1+len(num):]
        return formula, atom_dict, moltimes, molmol          
    
    
    def count_salt(formula, atom_dict, moltimes,molmol):
        num = ''
        atom = ''
        if '[' in formula:
            atoms = ''
            atoms+= formula[formula.index('['):formula.index(']')+1]
            if formula.index(']') < len(formula) -1:
                if formula[formula.index(']')+1].isdigit():
                    num = ''
                    j = formula.index(']')+1
                    while formula[j].isdigit():
                        num+= formula[j]
                        j+= 1
                        if j == len(formula):
                            break
            if num != '':
                moltimes *= int(num)
            leftover, x , y, z = count_molecule(atoms[1:-1], atom_dict, moltimes,molmol)  
            count_atom(leftover, atom_dict, moltimes, molmol)
            formula = formula[:formula.index('[')] +formula[formula.index(']')+1+len(num):]
              
        return formula, atom_dict, moltimes, molmol 
    
    
    def curly_salt(formula, atom_dict, moltimes, molmol):
        num = ''
        atom = ''
        if '{' in formula:
            atoms = ''
            atoms+= formula[formula.index('{'):formula.index('}')+1]
            if formula.index('}') < len(formula) -1:
                if formula[formula.index('}')+1].isdigit():
                    num = ''
                    j = formula.index('}')+1
                    while formula[j].isdigit():
                        num+= formula[j]
                        j+= 1
                        if j == len(formula):
                            break
            if num != '':
                moltimes = int(num)
            leftover, x, y, z = count_salt(atoms[1:-1], atom_dict, moltimes, molmol)
            leftover, x , y, z = count_molecule(leftover, atom_dict, moltimes, molmol)  
            count_atom(leftover, atom_dict, moltimes, molmol)
            formula = formula[:formula.index('{')] +formula[formula.index('}')+1+len(num):]
              
        return formula, atom_dict, moltimes, molmol 
        
    
    formula, atom_dict, moltimes, molmol = curly_salt(formula, atom_dict, 1, 1)
    moltimes = 1
    formula, atom_dict, moltimes, molmol = count_salt(formula, atom_dict, moltimes, molmol)
    moltimes = 1  
    formula, atom_dict, moltimes, molmol = count_molecule(formula, atom_dict, moltimes,molmol)
    moltimes = 1
    formula, atom_dict, moltimes, molmol = count_atom(formula, atom_dict, moltimes, molmol)
    return atom_dict
    

    

    
        
                
      
          
                
            
                
    
    
Best Practices0Clever0
0ForkCompare with your solutionLink
yangyanzhan

def parse_molecule (formula):
    import re
    def gen_num(raw):
        p = re.compile(r"(\d+)")
        m = p.match(raw)
        if m:
            return int(m.group(1)), raw[len(m.group(1)):]
        else:
            return 1, raw
    def gen_ele(raw):
        if not raw:
            return None, 1, raw
        s0 = raw[0]
        if s0.isalpha():
            if len(raw) == 1:
                return s0, 1, ""
            s1 = raw[1]
            if s1.isalpha() and s1.islower():
                num, raw = gen_num(raw[2:])
                return s0 + s1, num, raw
            num, raw = gen_num(raw[1:])
            return s0, num, raw
        return None, 1, raw
    def should_cur(raw):
        if not raw:
            return False
        s0 = raw[0]
        if s0 in "[](){}":
            return True
        return False
    def com_p(p):
        dic = {
            "[": "]",
            "(": ")",
            "{": "}",
            "": "hehe"
        }
        return dic[p]
    def cur(raw, p=""):
        res = {}
        addons = []
        rep_num = 1
        while len(raw) > 0:
            # print(raw)
            if should_cur(raw):
                p1 = raw[0]
                if com_p(p) == p1:
                    raw = raw[1:]
                    rep_num, raw = gen_num(raw)
                    break
                else:
                    addon, raw = cur(raw[1:], p1)
                    addons.append(addon)
            ele, num, raw = gen_ele(raw)
            if ele in res:
                res[ele] += num
            else:
                res[ele] = num
        for addon in addons:
            for key, value in addon.items():
                if key in res:
                    res[key] += value
                else:
                    res[key] = value
        for key in res:
            res[key] *= rep_num
        if None in res:
            del res[None]
        return res, raw
    res = cur(formula)
    return res[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
ChristianECooper

class Mol(object):
    """Data structure used in processing""" 
    def __init__(self, depth, element=None, multiple=None):
        self.depth = depth
        self.elements = {element: 1} if element else None
        self.multiple = multiple

def parse_molecule(formula):
    opens = "([{"    
    closes = ")]}"
    
    def get_char_type(c):
        """Identify character type"""
        if 'a' <= c <= 'z':
            return "c" # Lower char
        if 'A' <= c <= 'Z':
            return "C" # Upper char
        if '0' <= c <= '9':
            return "D" # Digit
        if c in opens or c in closes:
            return "B" # Bracket
        raise ValueError("Cannot classify character: {}".format(c))
        
    # Assign a type and precedence depth
    depth = 0
    tokens = []
    for c in formula:
        tokens.append([c, get_char_type(c), depth])
        if c in opens:
            depth += 1
        if c in closes:
            depth -= 1

    # Merge element names and multi-digit numbers
    i = 0
    merge_it = lambda a, b: (a[1] == 'C' and b[1] == 'c') or (a[1] == 'D' and b[1] == 'D')
    while i < len(tokens) - 1:
        if merge_it(tokens[i], tokens[i+1]):
            tokens[i][0] = tokens[i][0] + tokens[i+1][0]
            del tokens[i+1]
        else:
            i += 1

    # Identify group closes followed by immediate group opens, and inject a 1 group-multiplier
    i = 0
    while i < len(tokens) - 1:
        a, b = tokens[i], tokens[i+1]
        if a[1] == 'B' and b[1] == 'B' and a[0] in closes and b[0] in opens:
            # Insert a dummy 1 count
            tokens[i:i+2] = [a, ['1', 'D', a[2]-1], b]
        i += 1

    # Convert everything but brackets into Mol instances
    tokens = [Mol(d, element=t) if c == 'C' else Mol(d, multiple=int(t)) for t, c, d in tokens if c != "B"]
    
    # Merge down - phase 1 apply direct multiples
    i = 0
    while i < len(tokens) - 1:
        a, b = tokens[i], tokens[i+1]
        if a.depth == b.depth and b.multiple is not None:
            b.elements = {}
            for el, count in a.elements.iteritems():
                b.elements[el] = count * b.multiple
            b.multiple = None
            del tokens[i]
        i += 1
    
    
    # Merge down - phase 2 - Merge element groups on the same level and apply group multiples
    depth = lambda m: m.depth
    while len(tokens) > 1:
        # Start from deepest and work to shallowest groups
        max_depth = max(map(depth, tokens))
        i = 0
        while i < len(tokens) - 1:
            a, b = tokens[i], tokens[i+1]
            if a.depth == max_depth and b.depth == max_depth:
                # Merge the Mol instances together
                for el, count in a.elements.iteritems():
                    b.elements[el] = b.elements.get(el, 0) + count
                del tokens[i]
                continue

            if a.depth == max_depth and b.depth == max_depth - 1:
                if b.multiple is not None:
                    # Multiply first Mol instance by the second
                    b.elements = {}
                    for el, count in a.elements.iteritems():
                        b.elements[el] = count * b.multiple
                    b.multiple = None
                    del tokens[i]
                else:
                    # No multiple to apply, just promote first Mol instance up a level
                    a.depth -= 1
            i += 1
            
    # Should be only 1 Mol instance left by now, and it contains all the elements and their counts
    return tokens[0].elements
Best Practices0Clever0
0ForkCompare with your solutionLink
upkl

def d_add(d1, d2):
    # add d2 to d1 (in-place)
    for element in d2.keys():
        if d1.has_key(element):
            d1[element] = d1[element] + d2[element]
        else:
            d1[element] = d2[element]

def get_number(formula):
    if not formula:
        return 1, ""
    if "01234566789".find(formula[0]) < 0:
        return 1, formula
    n = 0
    while formula and "01234566789".find(formula[0]) >= 0:
        n = 10 * n + int(formula[0])
        formula = formula[1:]
    return n, formula

def parse_molecule (formula):
    (rv, f) = do_parse (formula)
    return rv

def do_parse (formula):
    if not formula:
        return {}, ""
    if "ABCDEFGHIJKLMNOPQRSTUVWXYZ".find(formula[0]) > -1:
        atom = formula[0]
        formula = formula[1:]
        while (formula and "abcdefghijklmnopqrstuvwxyz".find(formula[0]) > -1):
            atom = atom + formula[0]
            formula = formula[1:]
        (n, formula) = get_number(formula)
        rv = {atom: n}
    elif "([{".find(formula[0]) > -1:
        (rv, f) = do_parse(formula[1:])
        if (not f) or (formula[0] == "(" and f[0] != ")") or (formula[0] == "[" and f[0] != "]") or (formula[0] == "{" and f[0] != "}"):
            raise RuntimeError("bracket mismatch")
        (n, formula) = get_number(f[1:])
        for e in rv.keys():
            rv[e] = rv[e] * n
    elif ")]}".find(formula[0]) > -1:
        return {}, formula
    else:
        raise RuntimeError("unexpected character")
    (rv2, f) = do_parse(formula)
    d_add(rv, rv2)
    return (rv, f)
Best Practices0Clever0
0ForkCompare with your solutionLink
inzune

from string import lowercase, digits

braces = dict(zip('{[(', '}])'))

def parse_molecule (formula):
    formula = list(formula)
    
    def parse_number():
        number = []
        while formula and formula[0] in digits:
            number.append(formula.pop(0))
        return int(''.join(number))
        
    def expand_braces():
        brace = formula.pop(0)
        brace_count = 1
        sub_stack = []
        atom = formula.pop(0)
        while atom != braces[brace] and brace_count:
            if atom == brace: 
                brace_count += 1
            elif atom == braces[brace]: 
                brace_count -= 1
            else: sub_stack.append(atom)
            atom = formula.pop(0)
        ammount = 1
        if formula and formula[0] in digits:
            ammount = parse_number()
        formula.extend(sub_stack*ammount)
        
    def split_molecule(): 
        res = []
        while formula:
            lookahead = formula[0]
            if lookahead in lowercase:
                res.append(res.pop() + formula.pop(0))
            elif lookahead in braces:
                expand_braces()
            elif lookahead in digits:
                ammount = parse_number()
                atom = res.pop()
                res.extend([atom]*ammount)
            else: res.append(formula.pop(0))
        return res
    
    atoms = {} 
    extendet_formula = split_molecule()
    for i in extendet_formula:
        atoms[i] = atoms.get(i, 0) + 1
    return atoms

    
Best Practices0Clever0
0ForkCompare with your solutionLink
wverne

import re
from collections import Counter

"""
Grammar (EBNF):

molecule    ::= group, { group }
group       ::= ( atom | start-group, molecule, end-group ), [ count ]
atom        ::= upper-char, { lower-char }
count       ::= digit, { digit }
upper-char  ::= 'A' | 'B' | ... | 'Z'
lower-char  ::= 'a' | 'b' | ... | 'z'
digit       ::= '0' | '1' | ... | '9'
start-group ::= '(' | '[' | '{'
end-group   ::= ')' | ']' | '}'
"""

def parse_molecule(formula):
    tokens = tokenize(formula)
    return dict(count_molecule(tokens))
    
def count_molecule(tokens):
    groups = split_groups(tokens)
    counts = Counter({})
    for group in groups:
        counts += Counter(count_group(group))
    return counts
        
def split_groups(tokens):
    groups = []
    i = 0
    depth = 0
    while i < len(tokens):
        if is_atom(tokens[i]):
            if ((i < len(tokens) - 1) and
                    is_count(tokens[i+1])):
                groups.append(tokens[i:i+2])
                i = i+2
            else:
                groups.append(tokens[i:i+1])
                i = i+1
        else:
            end = find_end_of_group(tokens[i:]) + i
            if ((end < len(tokens) - 1) and
                    is_count(tokens[end+1])):
                groups.append(tokens[i:end+2])
                i = end+2
            else:
                groups.append(tokens[i:end+1])
                i = end+1
    return groups
            
def find_end_of_group(tokens):
    depth = 0
    for i, token in enumerate(tokens):
        if is_start_group(token):
            depth += 1
        if is_end_group(token):
            depth -= 1
        if depth == 0:
            return i
    
def count_group(tokens):
    if is_atom(tokens[0]):
        if len(tokens) > 1:
            return { tokens[0]: int(tokens[1]) }
        else:
            return { tokens[0]: 1 }
    else:
        if is_count(tokens[-1]):
            counts = Counter()
            single_count = count_molecule(tokens[1:-2])
            for i in range(0, int(tokens[-1])):
                counts += single_count
            return counts
        else:
            return count_molecule(tokens[1:-1])
            
def is_atom(token):
    return token.isalpha()
    
def is_count(token):
    return token.isdigit()
    
def is_start_group(token):
    return token in ('(', '[', '{')
    
def is_end_group(token):
    return token in (')', ']', '}')
        
def tokenize(formula):
    return re.findall("[0-9]+|[A-Z][a-z]*|[\[\]{}()]", formula);
Best Practices0Clever0
0ForkCompare with your solutionLink
alexanderpas

import re

def parse_molecule (formula):
  formula = formula.replace("{", "(")
  formula = formula.replace("}", ")")
  formula = formula.replace("[", "(")
  formula = formula.replace("]", ")")
  
  tokens = re.findall("[A-Z][a-z]?|[0-9]+|\(|\)", formula)
  
  if len(tokens) is 1:
    return {tokens[0]: 1}
  
  parts = []
  indentation = 0
  for item in tokens:
    if indentation is 0:
      if item.isdigit():
        parts += [parts.pop()] * int(item)
      elif item is '(':
        indentation += 1
        parts.append('')
      else:
        parts.append(item)
    else:
      if item is '(':
        indentation += 1
      if item is ')':
        indentation -= 1
      if indentation is not 0:
        parts[-1] += item
  
  output = {}
  
  for item in parts:
    for element, amount in parse_molecule(item).iteritems():
      if element in output.keys():
        output[element] += amount
      else:
        output[element] = amount
  return output
Best Practices0Clever0
0ForkCompare with your solutionLink
poocritter43

import re

def parse_molecule (formula):
 p = ['[','(','{']
 print "Original Formula",formula
 ##################
 # If no brackets #
 ##################
 if any(i in formula for i in p) == False:
  print "In if"
  print formula
  string = '(\w\d+)'
  tmp = re.findall(string, formula)
  for i in tmp:
   expand = i[0] * int(i[1:])
   formula = formula.replace(i,expand)
   #-------------
  string2 = '(\w[a-z]\d+)'
  tmp = re.findall(string2, formula)
  for i in tmp:
   if len(i) > 2:
    expand = i[0:2] * int(i[3:])
    formula = formula.replace(i,expand)
    print formula
  dx = {}
  set_x = set(re.findall('([A-Z][a-z]|[A-Z])', formula))
  for i in set_x:
   dx[i] = formula.count(i)
  print dx
  return dx
 ##################################
 #while any(i in formula for i in p):
 while '(' in formula or '[' in formula or '{' in formula:
  print "Restart while"
  #First RE: multiply molecule by number directly next to it first.
  #'KKKK[ON(SOOO)2]2'
  string = '([A-Z]\d)'
  tmp = re.findall(string, formula)
  for i in tmp:
   expand = i[0] * int(i[-1])
   formula = formula.replace(i,expand)
   print formula
  
  #####################################
  #RE: Gets rid of Mg2
  string2 = '(\w[a-z]\d)'
  tmp = re.findall(string2, formula)
  for i in tmp:
   if len(i) > 2:
    expand = i[0:2] * int(i[-1])
    formula = formula.replace(i,expand)
    print formula
  
  #Second RE: breaking down the brackets
  #####################################
  print "breaking down brackets on", formula
  string = '([\(\[\{][\w\d]*[\)\]\}]\d)'
  tmp = re.findall(string,formula)
  print "this is tmp", tmp
  for i in tmp:
   print "doing ", i  
   expand = i[1:-2] * int(i[-1])
   formula = formula.replace(i,expand)   
   print formula
   
  if not re.findall(string,formula): 
   #Gets rid of brackets with no purpose
   string = '([\(\[\{]\w*[\)\]\}])'
   tmp = re.findall(string,formula)
   for i in tmp:
    formula = formula.replace(i,i[1:-1])
   print 'done with loop'
   print formula
   if '[' in formula:
    print '[ still there'
 #Wrap it all up create dict
 dx = {}
 set_x = set(re.findall('([A-Z][a-z]|[A-Z])', formula))
 set_x = sorted(set_x)[::-1]
 for i in set_x:
  dx[i] = formula.count(i)
  formula = formula.replace(i,'')
 print dx
 return dx
Best Practices0Clever0
0ForkCompare with your solutionLink
zhuli19901106, JenniferGerald

import re

def parse_molecule (formula):
    f = formula
    f = re.sub('[\[\{]', '(', f)
    f = re.sub('[\]\}]', ')', f)
    
    # Tokenizer
    n = len(f)
    a = []
    i = 0
    while i < n:
        if f[i].isupper():
            a.append(f[i])
            i += 1
        elif f[i].islower():
            a[-1] += f[i]
            i += 1
        elif f[i].isdigit():
            val = 0
            while i < n and f[i].isdigit():
                val = val * 10 + ord(f[i]) - ord('0')
                i += 1
            a.append(val)
        else:
            a.append(f[i])
            i += 1
    res = [{}]
    n = len(a)
    i = 0
    while i < n:
        if re.match(r'^[A-Z][a-z]?$', a[i]):
            elem = a[i]
            if i + 1 < n and isinstance(a[i + 1], int):
                cc = a[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            if not elem in res[-1]:
                res[-1][elem] = cc
            else:
                res[-1][elem] += cc
        elif a[i] == '(':
            res.append({})
            i += 1
        elif a[i] == ')':
            if i + 1 < n and isinstance(a[i + 1], int):
                cc = a[i + 1]
                i += 2
            else:
                cc = 1
                i += 1
            for k in res[-1]:
                if not k in res[-2]:
                    res[-2][k] = cc * res[-1][k]
                else:
                    res[-2][k] += cc * res[-1][k]
            res.pop()
    return res.pop()
    
1 similar code variation is grouped with this oneShow Variations
Best Practices0Clever0
0ForkCompare with your solutionLink
poocritter43

import re

def parse_molecule (formula):
 p = ['[','(','{']
##################
 # If no brackets #
 ##################
 if any(i in formula for i in p) == False:
  string = '(\w\d+)'
  tmp = re.findall(string, formula)
  for i in tmp:
   expand = i[0] * int(i[1:])
   formula = formula.replace(i,expand)
   #-------------
  string2 = '(\w[a-z]\d+)'
  tmp = re.findall(string2, formula)
  for i in tmp:
   if len(i) > 2:
    expand = i[0:2] * int(i[3:])
    formula = formula.replace(i,expand)
  dx = {}
  set_x = set(re.findall('([A-Z][a-z]|[A-Z])', formula))
  for i in set_x:
   dx[i] = formula.count(i)
  return dx
 #while any(i in formula for i in p):
 while '(' in formula or '[' in formula or '{' in formula:
  string = '([A-Z]\d)'
  tmp = re.findall(string, formula)
  for i in tmp:
   expand = i[0] * int(i[-1])
   formula = formula.replace(i,expand)
  
  #####################################
  string2 = '(\w[a-z]\d)'
  tmp = re.findall(string2, formula)
  for i in tmp:
   if len(i) > 2:
    expand = i[0:2] * int(i[-1])
    formula = formula.replace(i,expand)
  #####################################
  string = '([\(\[\{][\w\d]*[\)\]\}]\d)'
  tmp = re.findall(string,formula)
  for i in tmp:
   expand = i[1:-2] * int(i[-1])
   formula = formula.replace(i,expand)   
   
  if not re.findall(string,formula): 
   #Gets rid of brackets with no purpose
   string = '([\(\[\{]\w*[\)\]\}])'
   tmp = re.findall(string,formula)
   for i in tmp:
    formula = formula.replace(i,i[1:-1])
 #Wrap it all up create dict
 dx = {}
 set_x = set(re.findall('([A-Z][a-z]|[A-Z])', formula))
 set_x = sorted(set_x)[::-1]
 for i in set_x:
  dx[i] = formula.count(i)
  formula = formula.replace(i,'')
 print dx
 return dx
Best Practices0Clever0
0ForkCompare with your solutionLink
Giedrius

def parse_molecule(formula, end = '', ctx = None):
    brackets = {'(': ')', '[': ']', '{': '}'}
    
    def read_end():
        if end == '' and ctx.p >= len(formula):
            ctx.r = ''
            return True
        if formula[ctx.p] == end:
            ctx.r = formula[ctx.p]
            ctx.p += 1
            return True
        return False
        
    def read_bracket():
        if formula[ctx.p] in brackets:
            ctx.r = formula[ctx.p]
            ctx.p += 1
            return True
        return False
    
    def read_index():
        p = ctx.p
        while ctx.p < len(formula) and formula[ctx.p].isdigit():
            ctx.p += 1
        ctx.r = formula[p:ctx.p]
        return p < ctx.p
    
    def read_atom():
        p = ctx.p
        if formula[ctx.p].isupper():
            ctx.p += 1
            while ctx.p < len(formula) and formula[ctx.p].islower():
                ctx.p += 1
        ctx.r = formula[p:ctx.p]
        return p < ctx.p
        
    def parse_index():
        return int(ctx.r) if read_index() else 1

    if not ctx:
        class Ctx:
            def __init__(self):
                self.p = 0
                self.r = ''
        ctx = Ctx()

    res = {}
    while not read_end():
        if read_bracket():
            inner = parse_molecule(formula, brackets[ctx.r], ctx)
            index = parse_index()
            res.update({k: res.get(k, 0) + v * index for k, v in inner.items()})
        elif read_atom():
            atom = ctx.r
            index = parse_index()
            res[atom] = res.get(atom, 0) + index
        else:
            raise ValueError, 'Invalid syntax at ' + pos

    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
zieglerk

opening = "([{"
closing = ")]}"
import re
from collections import Counter

def atomCount(formula):
  """assume neither brackets nor numbers, then the tricky part are lowercase letters."""
  print 'call atomCount'
  print re.sub('()([A-Z])', r'\1 \2', formula).split()
  return Counter(re.sub('()([A-Z])', r'\1 \2', formula).split())

def index_first_digit(formula):
  I = [i for i, c in enumerate(formula) if c.isdigit()]
  return min(I) if I else -1

def expand_at(formula, i):
    """use the number at position i and the group preceeding it"""
    print 'call with', formula, i
    j = i
    num = formula[j]
    while formula[j+1:] and formula[j + 1].isdigit():
      j += 1
        num += formula[j]
    num = int(num)
    post = formula[j+1:]
    pre = formula[:i]
    delimiter = pre[-1]
    print num, post, pre, delimiter 
    if delimiter in closing:
    print 'in deli case'
    match = opening[closing.index(delimiter)]
    j = len(pre) - pre[::-1].index(match) - 1
    group = pre[j+1:-1]
    pre = pre[:j]
    else:
    print 'in letter case'
    j = len(pre) - min([i for i, c in enumerate(reversed(pre)) if c.isupper()]) - 1
    group = pre[j:]
    pre = pre[:j]    
    return pre + group*num + post

def parse_molecule(formula):
  print formula, index_first_digit(formula)
  while index_first_digit(formula) > -1:
    print 'in loop'
    i = min([i for i, c in enumerate(formula) if c.isdigit()])
    formula = expand_at(formula, i)
        print formula
  formula = formula.translate(None, opening + closing)
  return atomCount(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
dimrozakis

def parse_molecule(molecule):
    brackets = {'{': '}', '[': ']', '(': ')'}
    counters = {}
    pos = 0
    while pos < len(molecule):
        if molecule[pos] in brackets.keys():
            nesting = [molecule[pos]]
            pos += 1
            start = pos
            while nesting and pos < len(molecule):
                if molecule[pos] in brackets.keys():
                    nesting.append(molecule[pos])
                elif molecule[pos] in brackets.values():
                    if brackets[nesting[-1]] != molecule[pos]:
                        raise Exception()
                    nesting.pop()
                pos += 1
            pcounters = parse_molecule(molecule[start:pos-1])
        elif molecule[pos].isupper():
            element = molecule[pos]
            pos += 1
            if pos < len(molecule) and molecule[pos].islower():
                element += molecule[pos]
                pos += 1
            pcounters = {element: 1}
        num = ''
        while pos < len(molecule) and molecule[pos].isdigit():
            num += molecule[pos]
            pos += 1
        num = int(num) if num else 1
        for element in pcounters:
            counters[element] = counters.get(element, 0) + pcounters[element] * num
    return counters
Best Practices0Clever0
0ForkCompare with your solutionLink
nguyen_v

import re
parens = {")":"(", "]":"[", "}":"{"}

def parse_molecule(formula):
    f = to_infix(filter(lambda x: x != "", 
            re.split(r"([^a-z\d][a-z]*)", 
            formula)))
    return count_all(solve_infix(f))
    
def count_all(f):
    d = {}
    for e in f:
        if e in d.keys(): d[e] += 1 
        else: d[e] = 1
    return d

def solve_infix(f):
    r = []
    for e in f:
        if e.isalpha(): r.append(e)
        elif e.isdigit(): r.append(int(e))
        elif e == "*": r.append(r.pop() * r.pop())
        elif e == "+": r.append(r.pop() + r.pop())
    return filter(lambda x: x != "", 
            re.split(r"([^a-z\d][a-z]*)", 
            r[0]))

def to_infix(f):
    f, o, r = add_ops(f),[], []
    for e in f:
        if e.isalnum(): r.append(e)
        elif e in "+*" or e in parens.values(): 
            if e == "+" and o and o[-1] in "+*": 
                r.append(o.pop())
            elif o and o[-1] == e: 
                r.append(o.pop())
            o.append(e)
        elif e in parens.keys():
            t = o.pop()
            while t != parens[e]:
                r.append(t)
                t = o.pop()
    return r + o[::-1]

def add_ops(f):
    temp, prev = [f[0]], f[0]
    for e in f[1:]:
        if prev.isdigit():
            if e in parens.values(): temp += ["+"] + [e]
            elif e in parens.keys(): temp += [e]
            else: temp += ["+"] + [e]
        elif prev.isalpha():
            if e in parens.values(): temp += ["+"] + [e]
            elif e in parens.keys(): temp += [e]
            elif e.isdigit(): temp += ["*"] + [e]
            else: temp += ["+"] + [e]
        elif prev in parens.values() + parens.keys():
            if prev in parens.keys() and e in parens.values():
                temp += ["+"] + [e]
            elif e in parens.values() + parens.keys(): 
                temp += [e]
            elif e.isdigit(): temp += ["*"] + [e]
            elif prev in parens.keys() and e.isalpha():
                temp += ["+"] + [e]
            else: temp += [e]
        prev = e
    return temp
Best Practices0Clever0
0ForkCompare with your solutionLink
Djaler

def parse_molecule(f):
    atoms = {}

    brackets = ('(', ')'), ('[', ']'), ('{', '}')
    while True:
        for open, close in brackets:
            open = f.find(open)
            close = f.find(close)
            if open != -1 and close != -1:
                inner = f[open + 1: close]
                if f[close + 1].isdigit():
                    num = int(f[close + 1])
                    f = f.replace(f[open: close + 2], inner * num)
                else:
                    f = f.replace(f[open: close + 1], inner)
                break
        else:
            break

    def parse_number(start):
        if start + 1 == len(f):
            return int(f[start])
        for j in xrange(start + 1, len(f)):
            if not f[j].isdigit():
                return int(f[start:j])

    def add_to_dict(atom, num=1):
        atoms[atom] = atoms.get(atom, 0) + num

    for i, char in enumerate(f):
        if not char.isupper():
            continue
        if i + 1 == len(f) or f[i+1].isupper():
            add_to_dict(char)
        elif f[i+1].isdigit():
            add_to_dict(char, parse_number(i + 1))
        elif i + 2 == len(f) or f[i+2].isupper():
            add_to_dict(char + f[i + 1])
        else:
            add_to_dict(char + f[i+1], parse_number(i+2))
    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
jimbolatte

def add_dict(dict1,dict2):
    for x in dict1:
        if x in dict2:
            dict2[x] += dict1[x]
        else:
            dict2[x] = dict1[x]
    return dict2


def parse_molecule (formula):
    OPA = {'(':')',
           '[':']',
           '{':'}'
          }
    mol_count = {}

    def next_token(k):
        token = ''
        m = k
        try:
            s = formula[m]
            if s.isalpha() and s.isupper():
                token = s
                s = formula[m+1]
                while s.isalpha() and s.islower():
                    token += s
                    m += 1
                    s = formula[m+1]
            elif s.isdigit():
                while s.isdigit():
                    token += s
                    m += 1
                    s = formula[m]
            elif s in OPA:
                closing = formula.index(OPA[s],m)
                token = formula[m:closing+1]
        except IndexError:
            return token

        return token



    k = 0
    while k < len(formula):
        multi = 1
        current = next_token(k)
        next = next_token(k+len(current))
        elements = {}
        if current == "":
            return mol_count

        if current[0] in OPA:
            elements = parse_molecule(current[1:-1])

        if current.isalpha():
            elements = {current: 1}

        k += len(current)

        if next.isdigit():
            for x in elements:
                elements[x] *= int(next)
            k += len(next)
        elif elements == {}:
            return elements

        add_dict(elements, mol_count)

    return mol_count
Best Practices0Clever0
0ForkCompare with your solutionLink
atk-

import re

def multiply(atoms, multiplier):
    for k, v in atoms.items():
        atoms[k] *= multiplier
    return atoms

def merge(d1, d2):
    for k, v in d2.items():
        d1[k] = d1.get(k, 0) + v
    return d1

def parse_queue(q):
    res = {}
    atom = None
    
    while q:
        t = q.pop(0)
        if re.match("[A-Z][a-z]?", t):
            atom = t
            res[atom] = res.get(atom, 0) + 1
        elif re.match("[0-9]+", t):
            count = int(t)
            if type(atom) == str:
                res[atom] = res.get(atom, 0) + (count - 1)
            elif type(atom) == dict:
                res = merge(res, multiply(atom, count - 1))
        elif t == '(':
            atom = parse_queue(q)
            for a, c in atom.items():
                res[a] = res.get(a, 0) + c
        elif t == ')':
            return res
        
    return res
            
def parse_molecule (formula):
    # make all parentheses equal
    formula = formula.replace("[", "(").replace("]", ")").replace("{", "(").replace("}", ")")
    
    # split formula into tokens: parentheses, atoms or numbers
    tokens = re.findall("([A-Z][a-z]?|[0-9]+|\(|\))", formula)    
            
    print tokens
    ret = parse_queue(tokens)
    print ret
    return ret        
Best Practices0Clever0
0ForkCompare with your solutionLink
Unencrypted

import re
def parse_molecule (formula):
    open_braces = ["(", "[", "{"]
    close_braces = [")", "]", "}"]
    brack_multiply = []
    last_multiply = 1
    total_current_multiply = 1
    return_dict = {}
    token_array = re.findall(r'([A-Z]{1}[a-z]{0,1}|[0-9]+|[\[\]\(\)\{\}]?)', formula)[::-1]
    print (token_array)
    for token in token_array:
        if token.isdigit():
            total_current_multiply *= int(token)
            last_multiply = int(token)
        elif token.isalpha():
            return_dict[token] = total_current_multiply + return_dict.get(token, 0)
            total_current_multiply /= last_multiply
            last_multiply = 1
        elif token in open_braces:
            total_current_multiply /= brack_multiply.pop()
            last_multiply = 1
        else:
            brack_multiply.append(last_multiply)
            last_multiply = 1
    return return_dict
Best Practices0Clever0
0ForkCompare with your solutionLink
timp

import re
def parse_molecule(x):
    m = re.search(r'[\(\{\[].+[\)\}\]][^\d]',x)
    while m:
        t = m.group(0)
        x = x.replace(t,t[1:-2]+t[-1])
        m = re.search(r'[\(\{\[].+[\)\}\]][^\d]',x)
    m = re.search(r'[A-Z][a-z]?\d+',x)
    while m:
        t = m.group(0)
        n = ''.join([c for c in t if c.isdigit()]) if len(t)>1 else ''
        x = x.replace(t,t[:-len(n)]*int(n)) if n else x
        m = re.search(r'[A-Z][a-z]?\d+',x)
    m = re.search(r'[\(\{\[]\w+[\)\}\]]\d+',x)
    while m:
        t = m.group(0)
        n = ''.join([c for c in t if c.isdigit()]) if len(t)>1 else ''
        s = [c for c in t if c.isalpha()]
        for i in xrange(1,len(s)):
            if s[i].islower(): s[i-1]+=s[i];s[i]=''
        s = ''.join(s)*int(n) if n else ''.join(s)
        x = x.replace(t,s)
        m = re.search(r'[\(\{\[]\w+[\)\}\]]\d+',x)
    m = re.search(r'[a-z][A-Z]|[A-Z][A-Z]',x)
    while m:
        t = m.group(0)
        x = x.replace(t,t[:1]+' '+t[1:])
        m = re.search(r'[a-z][A-Z]|[A-Z][A-Z]',x)
    x = x.split()
    u,r = sorted(list(set(x))),{}
    for s in u: r[s] = x.count(s)
    return r
Best Practices0Clever0
0ForkCompare with your solutionLink
portify

from collections import defaultdict
import re

def insert(data, arg, n):
  if type(arg) == defaultdict:
    for k, v in arg.items():
      data[k] += v * n
  else:
    data[arg] += n

def parse(formula, i, term=None):
  data = defaultdict(int)
  arg = None
  
  while i < len(formula):
    if arg != None:
      m = re.match(r"[0-9]+", formula[i:])
      if m:
        n = int(m.group(0))
        i += m.end()
      else:
        n = 1
      
      insert(data, arg, n)
      arg = None
      
      if i >= len(formula):
        break
    
    if term == formula[i]:
      i += 1
      break
      
    f = "([{".find(formula[i])
    if f != -1:
      arg, i = parse(formula, i+1, ")]}"[f])
    else:
      m = re.match(r"([A-Z][a-z]*)", formula[i:])
      i += m.end()
      arg = m.group(0)
  
  if arg != None:
    insert(data, arg, 1)
  
  return data, i

def parse_molecule (formula):
    return parse(formula, 0)[0]
Best Practices0Clever0
0ForkCompare with your solutionLink
chanshik

bracket_pair = {
    '(': ')',
    '{': '}',
    '[': ']',
}


def is_bracket(s):
    return s == '(' or s == '{' or s == '['


def mole(formula, idx):
    if idx >= len(formula):
        return ('', -1)

    ch = formula[idx]
    if ch.isdigit():
        return ('', idx)
    elif is_bracket(ch):
        return ('', idx)

    mole = ch
    idx += 1
    while idx < len(formula):
        if formula[idx].islower():
            mole += formula[idx]
        else:
            break

        idx += 1

    return (mole, idx)


def factor(formula, idx):
    if idx >= len(formula):
        return (1, -1)

    ch = formula[idx]
    if not ch.isdigit():
        return (1, idx)

    factor = int(formula[idx])
    idx += 1
    while idx < len(formula):
        if formula[idx].isdigit():
            factor = int(formula[idx]) + factor * 10
        else:
            break

        idx += 1

    return (factor, idx)


def mole_group(formula, idx):
    if idx >= len(formula):
        return ('', -1)

    ch = formula[idx]
    if not is_bracket(ch):
        return ('', idx)

    start = idx
    idx += 1
    while idx < len(formula) - 1:
        if formula[idx] == bracket_pair[ch]:
            return (formula[start + 1:idx], idx + 1)

        idx += 1

    return ('', -1)


def parse_molecule (formula):
    if len(formula) == 0:
        return {}

    formula_len = len(formula)
    atoms = {}
    idx = 0

    while idx != -1 and idx < formula_len:
        token_mole, idx = mole(formula, idx)
        if token_mole != '':
            token_factor, idx = factor(formula, idx)

            if token_mole in atoms:
                atoms[token_mole] += token_factor
            else:
                atoms[token_mole] = token_factor

        else:  # mole or mole_group.
            token_group, idx = mole_group(formula, idx)
            group_atoms = parse_molecule(token_group)

            token_factor, idx = factor(formula, idx)  # mole_group can have a factor.
            group_atoms = {k:v * token_factor for k, v in group_atoms.items()}

            for k, v in group_atoms.items():
                if k not in atoms:
                    atoms[k] = v
                else:
                    atoms[k] += v

    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
Standish

def parse_molecule (formula):
    print formula
    lower=[]
    upper=[]
    paren1=[]
    paren2=[]
    brack1=[]
    brack2=[]
    brace1=[]
    brace2=[]
    num=[]
    for i,j in enumerate(formula):
        if j=='(':
            paren1.append(i)
        elif j==')':
            paren2.append(i)
        elif j=='[':
            brack1.append(i)
        elif j==']':
            brack2.append(i)
        elif j in ('abcdefghijklmnopqrstuvwxyz'):
            lower.append(i)
        elif j in ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'):
            upper.append(i)
        elif j=='{':
            brace1.append(i)
        elif j=='}':
            brace2.append(i)
        else:
            num.append(i)
    thing=[]
    for i in upper: 
        if i+1 in lower:
            if not (formula[i]+formula[i+1]) in thing:
                thing.append(formula[i]+formula[i+1])
        else:
            if not formula[i] in thing:
                thing.append(formula[i])
    bpair=[]
    ppair=[]
    apair=[]
    for i,j in enumerate(brack1):
        try:
            a=int(formula[brack2[i]+1])
        except:
            a=1
        bpair.append([j,brack2[i] ,a] )
    for i,j in enumerate(paren1):
        try:
            a=int(formula[paren2[i]+1])
        except:
            a=1
        ppair.append([j,paren2[i],a] )
    for i,j in enumerate(brace1):
        try:
            a=int(formula[brace2[i]+1])
        except:
            a=1
        ppair.append([j,brace2[i],a] )
    mult=[]
    for i in range(0,len(formula)):
        mult.append(1)
    for i in ppair: 
        for j in range(i[0]+1,i[1]):
            mult[j]*=int(i[2])
    for i in bpair: 
        for j in range(i[0]+1,i[1]):
            mult[j]*=int(i[2])
    count=[0]*len(thing)
    for i in upper: 
        if i+1 in lower: 
            index=i+2
            if index in num:
                number=int(formula[index])
                if index+1 in num: 
                    number=int(formula[index]+formula[index+1])
                for k in range(0,len(count)):
                    if thing[k]==formula[index-2]+formula[index-1]:
                        count[k]+=number*mult[index-1]
            else:
                for k in range(0,len(count)):
                    if thing[k]==formula[index-2]+formula[index-1]:
                        count[k]+=mult[index-1]
        else: 
            index=i+1
            if index in num:
                number=int(formula[index])
                if index+1 in num: 
                    number=int(formula[index]+formula[index+1])
                for k in range(0,len(count)):
                    if thing[k]==formula[index-1]:
                        count[k]+=number*mult[index-1]
            else:
                for k in range(0,len(count)):
                    if thing[k]==formula[index-1]:
                        count[k]+=mult[index-1]
    printout={}
    for i in range(0,len(count)):
        printout[thing[i]]=(count[i])
    print printout
    return printout
Best Practices0Clever0
0ForkCompare with your solutionLink
kucuny

import re

def parse_molecule(fomula):
    if fomula == '':
        return {}

    temp_res = []

    inner_regexp = re.compile('([\(\[\{]((?:[A-Z][a-z]?\d*)+)[\)\]\}](\d*))')
    sub_regexp = re.compile('([A-Z][a-z]?)(\d*)')

    inner_matches = inner_regexp.findall(fomula)
    while len(inner_matches) > 0:
        for match in inner_matches:
            sub_matches = sub_regexp.findall(match[1])

            count = 1
            if match[2] != '':
                count = int(match[2])

            for sub_match in sub_matches:
                sub_count = 1
                if sub_match[1] != '':
                    sub_count = int(sub_match[1])

                temp_res.append((sub_match[0], sub_count * count))

            temp_elem = []
            for elem, count in temp_res:
                temp_elem.append(elem + str(count))

            fomula = fomula.replace(match[0], ''.join(temp_elem))
            temp_res = []

        inner_matches = inner_regexp.findall(fomula)

    sub_matches = sub_regexp.findall(fomula)
    for sub_match in sub_matches:
        sub_count = 1
        if sub_match[1] != '':
            sub_count = int(sub_match[1])

        temp_res.append((sub_match[0], sub_count))

    result = {}
    for elem, count in temp_res:
        if elem in result:
            result[elem] += count
        else:
            result[elem] = count

    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
zsszabo

class chemical(object):
  def __init__(self, symbol, crv, rect, curl ):
    self.symbol = symbol
    self.count = 1
    self.crv = crv
    self.rect = rect
    self.curl = curl
  
def num_count(str, i):
# this function returns the length of numeral substring in str starting from pos i-1,
# given there is a numeral at pos i - 1
  if len(str) <= i:
    return 1
  le = 1  
  while  i < len(str) and str[i].isdigit():
    i += 1
    le += 1
  return le

def parse_molecule (formula):
  # going through the formula and get the objects
  element_list = []
  i = 0
  curveB = 0
  rectangB = 0
  curlyB = 0
  while i < len(formula):
    if formula[i].isupper():
      if i + 1 < len(formula) and  formula[i + 1].islower():
        element_list += [chemical(formula[i:i+2],curveB, rectangB, curlyB)]
        i += 2
      else:
        element_list += [chemical(formula[i], curveB, rectangB, curlyB)]
        i += 1  
    elif formula[i] == "(":
      curveB += 1
      i += 1
    elif formula [i] ==  "[":
      rectangB += 1
      i += 1
    elif formula [i] ==  "{":
      curlyB += 1
      i += 1
    elif formula[i].isdigit():
      le = num_count(formula, i+1)
      element_list[-1].count = int(formula[i:i+le])
      i += le
    elif formula[i] == ")":
      if i + 1 < len(formula) and formula[i+1].isdigit():
        le = num_count(formula, i+2)
        mu = int(formula[i+1:i+1+le])
        for elem in element_list:
          if elem.crv == curveB:
            elem.count *= mu
            elem.crv -= 1
      
        curveB -= 1 
        i += le + 1
      else:
        for elem in element_list:
          if elem.crv == curveB:
            elem.crv -= 1
            
        curveB -= 1
        i += 1  
    elif formula[i] == "]":
      if i + 1 < len(formula) and formula[i+1].isdigit():
        le = num_count(formula, i+2)
        mu = int(formula[i+1:i+1+le])
        for elem in element_list:
          if elem.rect == rectangB:
            elem.count *= mu
            elem.rect -= 1
      
        rectangB -= 1 
        i += le + 1
      else:
        for elem in element_list:
          if elem.rect == rectangB:
            elem.rect -= 1
      
        i += 1 
        rectangB -= 1
    elif formula[i] == "}":
      if i + 1 < len(formula) and formula[i+1].isdigit():
        le = num_count(formula, i+2)
        mu = int(formula[i+1:i+1+le])
        for elem in element_list:
          if elem.curl == curlyB:
            elem.count *= mu
            elem.curl -= 1
      
        curlyB -= 1 
        i += le + 1
      else:
        for elem in element_list:
          if elem.curl == curlyB:
            elem.curl -= 1
            
        i += 1
        curlyB -= 1     
      
  res = {}
  for elem in element_list:
    res[elem.symbol] = 0
    
  for elem in element_list:
    res[elem.symbol] += elem.count
     
  return res
         
Best Practices0Clever0
0ForkCompare with your solutionLink
GNX

import re

def expand(m):
    return m.group(1)*int(m.group(2))

def parse_molecule (formula):
    # Remove useless brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({](\w+)[\])}](\D)', r'\1\2', formula)
    # expand simple atoms
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'([A-Z][a-z]?)(\d+)', expand, formula)
    # Decompose inner brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({]((?:[A-Z][a-z]?)+)[\])}](\d+)', expand, formula)
    # Remove useless brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({](\w+)[\])}](\D)', r'\1\2', formula)
    dict={}
    i=0
    while i<len(formula):
        a=formula[i]
        if i+1<len(formula) and re.match(r'[a-z]', formula[i+1]):
            a+=formula[i+1]
            i+=1
        i+=1
        if a in dict:
            dict[a]+=1
        else:
            dict[a]=1
    return dict
Best Practices0Clever0
0ForkCompare with your solutionLink
GNX

import re

def expand_atom(m):
    return m.group(1)*int(m.group(2))

def expand_par(m):
    return m.group(1)*int(m.group(2))

def parse_molecule (formula):
    # Remove useless brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({](\w+)[\])}](\D)', r'\1\2', formula)
    # expand simple atoms
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'([A-Z][a-z]?)(\d+)', expand_atom, formula)
    # Decompose inner brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({]((?:[A-Z][a-z]?)+)[\])}](\d+)', expand_par, formula)
    # Remove useless brackets
    oldf=''
    while oldf!=formula:
        oldf=formula
        formula=re.sub(r'[[({](\w+)[\])}](\D)', r'\1\2', formula)
    dict={}
    i=0
    while i<len(formula):
        a=formula[i]
        if i+1<len(formula) and re.match(r'[a-z]', formula[i+1]):
            a+=formula[i+1]
            i+=1
        i+=1
        if a in dict:
            dict[a]+=1
        else:
            dict[a]=1
    return dict
Best Practices0Clever0
0ForkCompare with your solutionLink
lesha.duduk

from pprint import pprint as pp

def _parse_str(formula):
    l = 0
    lst = []
    
    lf = len(formula)
    while l < lf:
        r = l + 2 if (l<lf-1 and  formula[l+1].isalpha() and 
                      formula[l+1].islower() or
                      formula[l:l+2].isdigit()) else l + 1
        lst.append(formula[l:r])
        l = r
    return lst


def _find_pair_bracket(lst, i):
    stack = 1
    l = i-1
    while l >= 0:
        c = lst[l]
        if c in "([{":
            stack -= 1
        elif c in ")]}":
            stack += 1

        if stack == 0:
            return l
        l -= 1


def _parse_nesting(lst):
    d = {}
    count = 1
    i = len(lst) - 1
    while i >= 0:
        c = lst[i]
        if c.isdigit():
            count = int(c)
        elif c in ")]}":
            l = _find_pair_bracket(lst, i)
            nested_d = _parse_nesting(lst[l+1:i])
            for key in nested_d:
                if key in d:
                    d[key] += nested_d[key] * count
                else:
                    d[key] = nested_d[key] * count
            count = 1
            i = l
        else:
            if c in d:
                d[c] += count
            else:
                d[c] = count
            count = 1
        i -= 1
    return d


def parse_molecule (formula):
    lst = _parse_str(formula)
    d = _parse_nesting(lst)
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
Rsol

def parse_molecule(formula):
    """
    For a given chemical formula represented by a string,
    count the number of atoms of each element contained in the molecule
    Formulas may have brackets in them. Brackets may be round, square or curly.
    Brackets are assumed to be in correct pairs
    :param formula: string: chemical formula
    :return: dict: atom: number
    """
    
    caps = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lows = "abcdefghijklmnopqrstuvwxyz"
    nums = "0123456789"
    open_par = "[{("
    close_par = ")}]"

    par_level = 0
    internal_formula = ""

    atoms = {}

    # loop along the formula
    idx = 0
    while idx < len(formula):

        # if open parenthesis
        if formula[idx] in open_par:
            par_level += 1

            # find the whole inside expression
            for idy in range(idx+1, len(formula)):
                idx += 1
                if formula[idy] in open_par:
                    par_level += 1
                elif formula[idy] in close_par:
                    par_level -= 1
                if par_level == 0:
                    break
                else:
                    internal_formula += formula[idy]
            
            # and evaluate it recursively
            temp_atoms = parse_molecule(internal_formula)
            internal_formula = ""

            # complete the multiplier of the internal expression
            number = ""
            for idy in range(idx+1, len(formula)):
                if formula[idy] in nums:
                    number += formula[idy]
                else:
                    break
                idx += 1
            if number != "":
                number = int(number)
            else:
                number = 1
            for atom, num in temp_atoms.items():
                if atom in atoms:
                    atoms[atom] += num * number
                else:
                    atoms[atom] = num * number
        
        # if not inside parenthesis
        
        # caps letter implies new atom
        elif formula[idx] in caps:
            atom = formula[idx]

            # complete the atom with the following lower letters
            for idy in range(idx+1, len(formula)):
                if formula[idy] in lows:
                    atom += formula[idy]
                    idx += 1
                else:
                    break

            # complete the number of atoms
            number = ""
            for idy in range(idx+1, len(formula)):
                if formula[idy] in nums:
                    number += formula[idy]
                    idx += 1
                else:
                    break
            if number != "":
                number = int(number)
            else:
                number = 1

            # add new atom to dict
            if atom in atoms:
                atoms[atom] += number
            else:
                atoms[atom] = number

        idx += 1

    return atoms
Best Practices0Clever0
0ForkCompare with your solutionLink
GodMode-On

from string import digits

def count_nums(text, position):
    '''
    Returns how many digits in a row in text, starting from pos.
    '''
    
    if not text[position].isdigit():
        return False
    count = 0
    while text[position].isdigit():
        count += 1
        position += 1
        if position == len(text):
            return count
    return count
    
    
def get_rid_of_brackets(molecule):
    '''
    Something like that:
    K4[ON(SO3)2]2 -> K4ONSO3SO3ONSO3SO3
    '''
    brackets = {'(' : ')',
                '[' : ']',
                '{' : '}'}
                
    while any(bracket in molecule for bracket in brackets.keys()):
        for i in range(len(molecule)-1, -1, -1):
            if molecule[i] in brackets.values():
                for j, element in list(enumerate(molecule))[::-1]:
                    if element in brackets.keys():
                        if brackets[element] == molecule[i]:
                            start = molecule[:j]
                            in_brackets = molecule[j+1:i]
                            number_len = count_nums(molecule, i+1)
                            times = int(molecule[i+1:i+number_len+1]) if number_len else 1
                            end = molecule[i+number_len+1:]
                            break
                molecule = start + in_brackets * times + end
                break
    return molecule
    
def molecule_to_atoms(molecule):
    '''
    Something like that:
    H2SO3 -> ['H2', 'S', 'O3']
    '''
    
    molecule_without_brackets = get_rid_of_brackets(molecule)
    molecule_split = ''
    for element in molecule_without_brackets:
        if element.isupper():
            molecule_split += ' ' + element
        else:
            molecule_split += element           
    return molecule_split.lstrip().split()
    
def parse_molecule(molecule):
    '''
    Returns number of atoms of each element contained in the molecule
    '''
    
    atom_list = molecule_to_atoms(molecule)
    
    result = dict()
    for element in atom_list:
        if any(digit in element for digit in digits):
            if element[1].isdigit():
                atom = element[0]
                count = element[1:]
                
            else:
                atom = element[:2]
                count = element[2:]
        else:
                atom = element
                count = 1
        if atom in result.keys():
            result[atom] += int(count)
        else:
            result[atom] = int(count)
    return result
Best Practices0Clever0
0ForkCompare with your solutionLink
jolaf

from collections import defaultdict
from re import compile as reCompile

PATTERN = reCompile(r'([A-Z][a-z]*)([0-9]*)|([\(\[\{])|([\)\]\}])([0-9]*)')

def calc(iterator):
    ret = defaultdict(lambda: 0)
    for (atom, number, openBrace, closeBrace, braceNumber) in iterator:
        if atom:
            ret[atom] += int(number or 1)
        elif openBrace:
            for (atom, number) in calc(iterator).iteritems():
                ret[atom] += number
        elif closeBrace:
            if braceNumber:
                braceNumber = int(braceNumber or 1)
                for (atom, number) in ret.iteritems():
                    ret[atom] *= braceNumber
            break
    return ret

def parse_molecule(formula):
    return calc(iter(PATTERN.findall(formula)))
Best Practices0Clever2
0ForkCompare with your solutionLink
gauchj, Bernard7777

import re

tokre = re.compile('[A-Z][a-z]*'
    '|[0-9]+'
    '|[\[{(]'
    '|[]})]')

def parse_molecule(mol):
    return parse_toks(tokre.findall(mol))

def add_coll(res, cur_coll, num):
    for elem, n in cur_coll.items():
        res[elem] = res.get(elem, 0) + n*num


def parse_toks(mol):
    res = {}
    x = enumerate(mol)
    cur_coll = None
    for i, tok in x:
        if re.match('[0-9]+', tok):
            # number - add current element n times
            num = int(tok)
            add_coll(res, cur_coll, num)
            cur_coll = None
        elif re.match('[A-Z][a-z]*', tok):
            if cur_coll:
                add_coll(res, cur_coll, 1)
            cur_coll = {tok: 1}
        elif re.match('[\[({]', tok):
            if cur_coll:
                add_coll(res, cur_coll, 1)
            # find matching parenthesis
            parenstack = {'(': 0, '[': 0, '{': 0}
            parenstack[tok] = 1
            start = i+1
            while True:
                i, tok = next(x)
                if re.match('[\[({]', tok):
                    parenstack[tok] += 1
                elif re.match('[\])}]', tok):
                    parenstack[{')': '(', ']': '[', '}': '{'}[tok]] -= 1
                if sum(parenstack.values()) == 0:
                    cur_coll = parse_toks(mol[start:i])
                    break
        else:
            raise ValueError('must not happen')
    if cur_coll:
        add_coll(res, cur_coll, 1)
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
CaptainFaramir

def parse_molecule(formula):
    formula_dict = {}
    for bracket in '[{':
        formula = formula.replace(bracket, '(')
    for bracket in ']}':
        formula = formula.replace(bracket, ')')
    
    if '(' in formula:
        has_bracket = True
    else:
        has_bracket = False
    while has_bracket:
        for i in range(len(formula)):
            if formula[i] == ')':
                break
        for j in range(len(formula[:i])-1, -1, -1):
            if formula[j] == '(':
                break
        print i, j
        if i+1 == len(formula) or not formula[i+1].isdigit():
            sub_formula = formula[j: i+1]
            tmp = sub_formula + '1'
        else:
            sub_formula = formula[j: i+2]
            tmp = sub_formula
        parsed_sub_formula = parse_paren(tmp)
        formula = formula.replace(sub_formula, parsed_sub_formula)
        if '(' in formula:
            has_bracket = True
        else:
            has_bracket = False

    print formula
    i = 0
    while i < len(formula):
        j = i+1
        if j < len(formula) and formula[j].islower():
            j += 1
        tmp = formula[i: j]
        if j < len(formula) and formula[j].isdigit():
            k = j+1
            if k < len(formula) and formula[k].isdigit():
                formula_dict[tmp] = formula_dict.get(tmp, 0) + int(formula[j: k+1])
                i = k+1
            else:
                formula_dict[tmp] = formula_dict.get(tmp, 0) + int(formula[j])
                i = j+1
        elif j < len(formula) and formula[j].isupper():
            formula_dict[tmp] = formula_dict.get(tmp, 0) + 1
            i = j
        elif j == len(formula):
            formula_dict[tmp] = formula_dict.get(tmp, 0) + 1
            break

    return formula_dict
        
        
        
    

def parse_paren(sub_formula):
    result = {}
    times = int(sub_formula[-1])
    i = 1
    while i < len(sub_formula)-2:
        j = i+1
        if sub_formula[j].islower():
            j += 1
        tmp = sub_formula[i: j]
        if sub_formula[j].isdigit():
            k = j+1
            if k < len(sub_formula)-2 and sub_formula[k].isdigit():
                result[tmp] = result.get(tmp, 0) + int(sub_formula[j: k+1])*times
                i = k+1
            else:
                result[tmp] = result.get(tmp, 0) + int(sub_formula[j])*times
                i = j+1
        elif sub_formula[j].isupper() or sub_formula[j] == ')':
            result[tmp] = result.get(tmp, 0) + 1*times
            i = j

    t = []
    for key, val in result.iteritems():
        t.append(key)
        t.append(str(val))
    return ''.join(t)
Best Practices0Clever0
0ForkCompare with your solutionLink
kpeker

def parse_numstr(s,i):
    numstr = ""
    while i < len(s) and s[i].isdigit():   # get atom count
        numstr += s[i]
        i += 1
    return int(numstr) if numstr else 1, i

def parse_molecule(formula):
    paran = {"(":")", "[":"]", "{":"}"}
    d = {}
    i = 0
    while i < len(formula):
        # if a paranthesis, recursively parse inside the paranthesis,
        #   then merge with current dict, also multiplying with index of the paranthesis
        if formula[i] in paran:
            cnt,ix = 1,i+1
            while ix < len(formula):    # find the closing paranthesis for this one
                if formula[ix] == formula[i]: cnt += 1
                elif formula[ix] == paran[formula[i]]: cnt -= 1
                if cnt==0: break
                ix += 1
            if cnt != 0: return "Unbalanced paranthesis."
            d1 = parse_molecule(formula[i+1:ix])
            i = ix + 1
            mult,i = parse_numstr(formula,i)
            for k,v in d1.items():      # merge with existing dict, using whole multiplier
                if k in d: d[k] += v*mult
                else: d[k] = v*mult
        else:
            key = formula[i]
            i += 1
            if i < len(formula) and formula[i].islower():   # e.g. Mg
                key += formula[i]
                i += 1
            val,i = parse_numstr(formula,i)
            if key in d: d[key] += val
            else: d[key] = val
    return d
Best Practices0Clever0
0ForkCompare with your solutionLink
cwhy

# No regex, roughly O(n). Correct me if wrong.
from collections import Counter
def parse_molecule (formula):
  L = ['{', '[', '(']
  R = ['}', ']', ')']
  atom_stack = [Counter()]
  l = len(formula)
  n_str = ''
  atom = ''
  i = 0
  while i < l:
    c = formula[i]
    inext = i + 1
    if atom != '' and not c.islower():
      atom = ''
    if c in L:
      atom_stack.append(Counter())
    elif c in R:
      last = atom_stack.pop()
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        for _k in last.keys():
          last[_k] = last[_k] * int(n_str)
        n_str = ''
      atom_stack[-1] += last
    elif c.isupper():
      a = c
      while inext < l and formula[inext].islower():
        a += formula[inext]
        inext += 1
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        atom_stack[-1][a] += int(n_str)
        n_str = ''
      else:
        atom_stack[-1][a] += 1
    i = inext

    # print atom_stack
  return dict(atom_stack[-1])
Best Practices0Clever0
0ForkCompare with your solutionLink
cwhy

from collections import Counter
def parse_molecule (formula):
  L = ['{', '[', '(']
  R = ['}', ']', ')']
  atom_stack = [Counter()]
  l = len(formula)
  n_str = ''
  atom = ''
  for i, c in enumerate(formula):
    if c.islower() or c.isdigit():
      continue
    if atom != '' and not c.islower():
      atom = ''
    if c in L:
      atom_stack.append(Counter())
    elif c in R:
      last = atom_stack.pop()
      inext = i + 1
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        for _k in last.keys():
          last[_k] = last[_k] * int(n_str)
        n_str = ''
      atom_stack[-1] += last
    else:
      a = c
      inext = i + 1
      while inext < l and formula[inext].islower():
        a += formula[inext]
        inext += 1
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        atom_stack[-1][a] += int(n_str)
        n_str = ''
      else:
        atom_stack[-1][a] += 1

    # print atom_stack
  return dict(atom_stack[-1])
Best Practices0Clever0
0ForkCompare with your solutionLink
cwhy

from collections import Counter
def parse_molecule (formula):
  L = ['{', '[', '(']
  R = ['}', ']', ')']
  # br = {l:r for l, r in zip(L,R)}
  # layer = {l:0 for l in L}
  # layer = {'(':0, '[':0, '{':0}
  atoms = dict()
  atom = ''
  atom_stack = [Counter()]
  l = len(formula)
  n_str = ''
  for i, c in enumerate(formula):
    if c.islower() or c.isdigit():
      continue
    if atom != '' and not c.islower():
      # atoms[atom] = atoms.get(atom, 0) + 1
      atom = ''
    if c in L:
      atom_stack.append(Counter())
    elif c in R:
      last = atom_stack.pop()
      inext = i + 1
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        for _k in last.keys():
          last[_k] = last[_k] * int(n_str)
        n_str = ''
      atom_stack[-1] += last

    else:
      a = c
      inext = i + 1
      while inext < l and formula[inext].islower():
        a += formula[inext]
        inext += 1
      while inext < l and formula[inext].isdigit():
        n_str += formula[inext]
        inext += 1
      if n_str != '': 
        atom_stack[-1][a] += int(n_str)
        n_str = ''
      else:
        atom_stack[-1][a] += 1

    # print atom_stack
  return dict(atom_stack[-1])
Best Practices0Clever0
0ForkCompare with your solutionLink
RecursiveDarkness

from collections import Counter

# WARNING dont watch this Code haha gonna have to redo it because of the chaos i've produced! But it works :D
def parse_molecule (formula):
    formula = list(formula)
    formula = handleNums(handleSymbols(formula))
    newForm = []
    for i in range(0, len(formula)):
        if formula[i].isdigit():
            newForm.append("*")
        newForm.append(formula[i])
    formula = solveNonBrackets(newForm)
    
    if(bracketsExist(formula)):
        formula = solveBrackets(formula)
    newForm = Counter(formula)
    formula = {}
    for key in newForm:
        formula[str(key)] = newForm[key]
    return formula

def bracketsExist(formula):
    for item in formula:
        if item == "(" or item == ")" or item == "[" or item == "]":
            return True
    return False
    
def handleNums(formula):
    newForm = []
    helpStr = ""
    for i in range(0, len(formula)):
        if  formula[i].isdigit():
            helpStr += formula[i]
        else:
            if helpStr != "":
                newForm.append(helpStr)
            newForm.append(formula[i])
            helpStr = ""
    if helpStr != "":
        newForm.append(helpStr)
    return newForm
    
def handleSymbols(formula):
    newForm = []
    i = 0
    while i < len(formula)-1:
        if ord(formula[i+1]) < 123 and ord(formula[i+1]) > 96:
            newForm.append(formula[i] + formula[i+1])
            i += 1
        else:
            newForm.append(formula[i])
        i += 1
    while i < len(formula):
        newForm.append(formula[i])
        i += 1
    return newForm
    
def solveNonBrackets(formula):
    newForm = []
    i = 0
    while i < len(formula)-2:
        if formula[i+1] == "*" and formula[i] != ")" and formula[i] != "]" and formula[i] != "}":
            newForm.extend(list(eval("'" + formula[i] + "'" + formula[i+1] + formula[i+2])))
            i+=2
        else:
            newForm.append(formula[i])
        i += 1
    while i < len(formula):
        newForm.append(formula[i])
        i += 1
    return newForm
    
def solveBrackets(formula):
    newForm = []
    helpStr = ""
    for i in range(0, len(formula)):
        if  formula[i] != "(" and formula[i] != ")" and formula[i] != "[" and formula[i] != "]" and formula[i] != "*" and not formula[i].isdigit() and formula[i] != "{" and formula[i] != "}":
            helpStr += formula[i]
        else:
            if helpStr != "":
                newForm.append(helpStr)
            newForm.append(formula[i])
            helpStr = ""
    if helpStr != "":
        newForm.append(helpStr)
    formula = newForm
    newForm = []
    i = 0
    
    while i < len(formula)-2:
        if formula[i] == "(" and formula[i+3] == "*":
            newForm.append(eval("'" + formula[i+1] + "'" + formula[i+3] + formula[i+4]))
            i += 5
        elif formula[i] == "(":
            newForm.append(formula[i+1])
            i += 3
        else:
            newForm.append(formula[i])
            i += 1
    while i < len(formula):
        newForm.append(formula[i])
        i += 1
    
    formula = newForm
    newForm = []
    
    helpStr = ""
    for i in range(0, len(formula)):
        if formula[i].isalpha() :#and formula[i].isupper():
            helpStr += formula[i]
        else:
            if helpStr != "":
                newForm.append(helpStr)
            newForm.append(formula[i])
            helpStr = ""
    if helpStr != "":
        newForm.append(helpStr)
        
    formula = newForm
    newForm = []
    i = 0
    
    while i < len(formula)-2:
        if formula[i] == "[" and formula[i+3] == "*":
            newForm.append(eval("'" + formula[i+1] + "'" + formula[i+3] + formula[i+4]))
            i += 5
        elif formula[i] == "[":
            newForm.append(formula[i+1])
            i += 3
        else:
            newForm.append(formula[i])
            i += 1
    while i < len(formula):
        newForm.append(formula[i])
        i += 1
        
    formula = newForm
    newForm = []
    
    helpStr = ""
    for i in range(0, len(formula)):
        if formula[i].isalpha() :#and formula[i].isupper():
            helpStr += formula[i]
        else:
            if helpStr != "":
                newForm.append(helpStr)
            newForm.append(formula[i])
            helpStr = ""
    if helpStr != "":
        newForm.append(helpStr)
        
    formula = newForm
    newForm = []
    i = 0
    
    while i < len(formula)-2:
        if formula[i] == "{" and formula[i+3] == "*":
            newForm.append(eval("'" + formula[i+1] + "'" + formula[i+3] + formula[i+4]))
            i += 5
        elif formula[i] == "{":
            newForm.append(formula[i+1])
            i += 3
        else:
            newForm.append(formula[i])
            i += 1
    while i < len(formula):
        newForm.append(formula[i])
        i += 1
    
    formula = []
    for item in newForm:
        formula.extend(handleSymbols(list(item)))
    return sorted(formula)
Best Practices0Clever0
0ForkCompare with your solutionLink
scasagrande

import re

def parse_molecule(formula):
    stack = []
    # Make the brackets uniform
    formula = formula.replace('[','(').replace('{','(')
    formula = formula.replace(']',')').replace('}',')')
    # Add 1's to everything to make things easier
    formula = list(formula)
    formula2 = []
    for i in xrange(len(formula)):
        if i > 0:
            if not formula[i].islower() and not formula[i-1].isdigit() and not formula[i].isdigit():
                if formula[i-1] != '(':
                    formula2 += ['1']
        formula2 += formula[i]
    if not formula2[-1].isdigit():
        formula2 += ['1']
    formula = formula2
    del(formula2)
    # Next, expand all brackets
    while '(' in formula:
        for i in xrange(len(formula)):
            if formula[i] == '(':
                stack.append(i)
            elif formula[i] == ')':
                start = stack.pop()
                subform = expand_formula(formula[start+1:i],formula[i+1])
                formula = formula[:start] + list(subform) + formula[i+2:]
                break
    # Split this up with regex
    formula = re.findall(r'([A-Z][a-z]?)([0-9]+)',''.join(formula))
    # And now pack this into a dictionary
    formula_d = {}
    for item in formula:
        if item[0] in formula_d:
            formula_d[item[0]] += int(item[1])
        else:
            formula_d[item[0]] = int(item[1])
    return formula_d

def expand_formula(formula, n):
    formula = re.findall(r'([A-Z][a-z]?)([0-9]+)',''.join(formula))
    for idx,item in enumerate(formula):
        formula[idx] = (item[0], str(int(item[1])*int(n)))
    return ''.join([item[0] + item[1] for item in formula])
Best Practices0Clever0
0ForkCompare with your solutionLink
rmanish04


brackets = ["[", "{","("]
close_brackets = ["]","}",")"]
molecules_dict = dict()
factors = list()
temp_dict_list = list()
brackets_count = 0
def update(temp_dict, count):
    insertion = (temp_dict_list[brackets_count-1] if brackets_count else
    molecules_dict)
    for key in temp_dict:
        if key in insertion:
            insertion[key] += count*temp_dict[key]
        else:
            insertion[key] = count*temp_dict[key]
def parse_molecule(formula):
    multiplier = 1
    array = list(formula)
    f_array = list()
    global molecules_dict
    molecules_dict = dict()
    prev = ""
    for i,elem in enumerate(array):
        if elem.islower() or (elem.isdigit() and prev.isdigit()):
            del f_array[-1]
            f_array.append(''.join(array[i-1:i+1]))
        else:
            f_array.append(elem)
        prev = elem
    global temp_dict_list, brackets_count
    insertion = molecules_dict
    for i,elem in enumerate(f_array):
        if elem.isdigit():
            continue
        elif elem in brackets:
            temp_dict_list.append(dict())
            insertion = temp_dict_list[brackets_count]
            brackets_count += 1
        elif elem in close_brackets:
            brackets_count -= 1
            count = int(f_array[i+1]) if f_array[i+1].isdigit() else 1
            update(temp_dict_list[brackets_count], count)
            del temp_dict_list[brackets_count]
            insertion = (temp_dict_list[brackets_count-1] if brackets_count else
            molecules_dict)
        else:
            next_elem = f_array[i+1] if i+1 < len(f_array) else '1'
            curr_value = int(next_elem) if next_elem.isdigit() else multiplier
            if elem in insertion:
                insertion[elem] += curr_value
            else:
                insertion[elem] = curr_value
    return molecules_dict
Best Practices0Clever0
0ForkCompare with your solutionLink
doctornick5

def apply_numer(stack, numer):
    if stack and stack[-1] in [')', ']', '}']:
        mul = int(numer) if numer else 1
        prev = len(stack) - 1 - stack[::-1].index({')': '(', ']': '[', '}': '{'}[stack[-1]])
        stack = stack[:prev] + [(e[0], e[1] * mul) for e in stack[prev + 1:-1]]
    elif numer:
        stack[-1] = (stack[-1][0], int(numer))
    return stack

def parse_molecule(formula, sofar = None):
    stack = []
    curr_numer = ''
    for ch in formula:
        if ch.isdigit():
            curr_numer = curr_numer + ch
        else:
            stack = apply_numer(stack, curr_numer)
            if ch.isupper():
                stack.append((ch, 1))
            elif ch.islower():
                stack[-1] = (stack[-1][0] + ch, 1)
            elif ch in '([{}])':
                stack.append(ch)
            curr_numer = ''
    stack = apply_numer(stack, curr_numer)
    atom_counts = {}
    for e in stack:
        atom_counts[e[0]] = atom_counts.get(e[0], 0) + e[1]
    return atom_counts
Best Practices0Clever0
0ForkCompare with your solutionLink
pwnfooj716

def parse_molecule(formula):
    print(formula)
    map = {}
    for i in range(1, len(formula)):
        if isLowerCase(formula[i - 1]) or (isUpperCase(formula[i - 1]) and not isLowerCase(formula[i])):
            product = getNumber(formula, i) if isNumber(formula[i]) else 1
            bracket_count = 0
            for j in range(i + 1, len(formula)):
                if isOpeningBracket(formula[j - 1]):
                    bracket_count += 1
                elif isClosingBracket(formula[j - 1]):
                    bracket_count -= 1
                    if (bracket_count < 0):
                        product *= getNumber(formula, j)
                        bracket_count = 0
            if getElement(formula, i - 1) in map.keys():
                map[getElement(formula, i - 1)] += product
            else:
                map[getElement(formula, i - 1)] = product
    if isLetter(formula[len(formula) - 1]):
        if getElement(formula, len(formula) - 1) in map.keys():
            map[getElement(formula, len(formula) - 1)] += 1
        else:
            map[getElement(formula, len(formula) - 1)] = 1
    return map
        
def isNumber(ch):
    try:
        int(ch)
        return True
    except:
        return False
        
def isLetter(ch):
    return (((ord(ch) >= ord('a')) and (ord(ch) <= ord('z'))) or ((ord(ch) >= ord('A')) and (ord(ch) <= ord('Z'))))
    
def isLowerCase(ch):
    return (ord(ch) >= ord('a')) and (ord(ch) <= ord('z'))
    
def isUpperCase(ch):
    return (ord(ch) >= ord('A')) and (ord(ch) <= ord('Z'))

def isBracket(ch):
    brackets = ('(', ')', '[', ']', '{', '}')
    return ch in brackets
    
def isOpeningBracket(ch):
    opening_brackets = ('(', '[', '{')
    return ch in opening_brackets
    
def isClosingBracket(ch):
    closing_brackets = (')', ']', '}')
    return ch in closing_brackets
    
# index is last letter of element
def getElement(formula, index):
    return formula[index] if isUpperCase(formula[index]) else formula[index - 1:index + 1]
    
# index is first digit of number
def getNumber(formula, index):
    if not isNumber(formula[index]):
        return 1
    if index == len(formula) - 1:
        return int(formula[index])
    i = index + 1
    while isNumber(formula[i]):
        i += 1
    return int(formula[index:i])
Best Practices0Clever0
0ForkCompare with your solutionLink
Blauelf

def parse_molecule (formula):
    output={}
    pos=0
    elem=''
    count=''
    while pos<len(formula):
        if 'A'<=formula[pos]<='Z':
            elem=formula[pos]
            count=''
            pos+=1
            while pos<len(formula) and 'a'<=formula[pos]<='z':
                elem+=formula[pos]
                pos+=1
            while pos<len(formula) and '0'<=formula[pos]<='9':
                count+=formula[pos]
                pos+=1
            if elem in output:
                output[elem]+=int(count) if len(count) else 1
            else:
                output[elem]=int(count) if len(count) else 1
        elif formula[pos] in '[({':
            open=1
            start=pos=pos+1
            while pos<len(formula) and open>0:
                if formula[pos] in '[({':
                    open+=1
                elif formula[pos] in '])}':
                    open-=1
                pos+=1
            subformula=formula[start:pos-1]
            suboutput=parse_molecule(subformula)
            count=''
            while pos<len(formula) and '0'<=formula[pos]<='9':
                count+=formula[pos]
                pos+=1
            for elem in suboutput:
                if elem in output:
                    output[elem]+=(int(count) if len(count) else 1)*suboutput[elem]
                else:
                    output[elem]=(int(count) if len(count) else 1)*suboutput[elem]
    return output
Best Practices0Clever0
0ForkCompare with your solutionLink
eugeneeek

def read_word(string, start):
    word = string[start]
    i = start + 1
    while i < len(string) and string[i].isalpha() and string[i].islower():
        word += string[i]
        i += 1
    return word

def read_digit(string, start):
    digit = ""
    i = start
    while i < len(string) and string[i].isdigit():
        digit += string[i]
        i += 1
    return digit

def parse_molecule(formula):
    is_open_parenthesis = lambda x: x in ['(','[','{']
    is_close_parenthesis = lambda x: x in [')',']','}']
    ex_formula = []
    i = 0
    while i < len(formula):
        if formula[i].isalpha() and formula[i].isupper():
            element = read_word(formula, i)
            ex_formula.append(element)
            i += len(element)
            if i < len(formula) and formula[i].isdigit():
                count = read_digit(formula, i)
                i += len(count)
            else:
                count = "1"
            ex_formula.append(int(count))
        elif is_open_parenthesis(formula[i]):
            ex_formula.append(formula[i])
            i += 1
        elif is_close_parenthesis(formula[i]):
            i += 1
            if formula[i].isdigit():
                count = read_digit(formula, i)
                i += len(count)
                count = int(count)
            else:
                count = 0
            j = -1
            while not is_open_parenthesis(ex_formula[j]):
                if count:
                    ex_formula[j] *= count
                j -= 2
            del ex_formula[j]
    molecules = {}
    for i in range(0, len(ex_formula), 2):
        if molecules.get(ex_formula[i]) == None:
            molecules[ex_formula[i]] = ex_formula[i+1]
        else:
            molecules[ex_formula[i]] += ex_formula[i+1]
    return molecules
Best Practices0Clever0
0ForkCompare with your solutionLink
saurus

from collections import defaultdict
import itertools

def parse_open_paren(f, i):
  if f[i] == '(' or f[i] == '[' or f[i] == '{': return (True, i + 1)
  else: return (False, i)
def parse_close_paren(f, i):
  if f[i] == ')' or f[i] == ']' or f[i] == '}': return (True, i + 1)
  else: return (False, i)
def parse_number(f, i):
  n = ''.join(itertools.takewhile(lambda c:c.isdigit(), f[i:]))
  if n: return (int(n), i + len(n))
  else: return (None, i)
def parse_atom(f, i):
  if i < len(f) and f[i].isupper():
    if i < len(f) - 1 and f[i + 1].islower():
      return (f[i:i + 2], i + 2)
    else:
      return (f[i], i + 1)
  return (None, i)
def parse_atom_number(f, i):
  atom, j = parse_atom(f, i)
  if atom:
    n, k = parse_number(f, j)
    if n: return ({ atom : n }, k)
    else: return ({ atom : 1 }, k)
  return (None, i)
def parse_simple_molecule(f, i):
  molecule = defaultdict(lambda :0)
  atom, j = parse_atom_number(f, i)
  while atom:
    k, v = atom.items()[0]
    molecule[k] += v
    atom, j = parse_atom_number(f, j)
  return (molecule, j)
def parse_paren_molecule(f, i):
  t, j = parse_open_paren(f, i)
  if t:
    molecule, j = parse_molecule1(f, j)
    if molecule:
      t, j = parse_close_paren(f, j)
      if t:
        n, j = parse_number(f, j)
        for k in molecule.keys():
          molecule[k] *= (n or 1)
        return (molecule, j)
  return (None, i)
def parse_sub_molecule(f, i):
  molecule, j = parse_simple_molecule(f, i)
  if not molecule:
    molecule, j = parse_paren_molecule(f, i)
  return (molecule, j)
def parse_molecule1 (formula, i=0):
  molecule, j = parse_sub_molecule(formula, i)
  more_molecule = dict(molecule)
  while more_molecule and j < len(formula):
    more_molecule, j = parse_sub_molecule(formula, j)
    if more_molecule:
      for k, v in more_molecule.items():
        molecule[k] += v
  return (molecule, j)
def parse_molecule(formula):
  molecule, _ = parse_molecule1(formula)
  return molecule
Best Practices0Clever0
0ForkCompare with your solutionLink
sazlin

from collections import Counter

OPEN_BRACKETS = ['(','[','{']
CLOSE_BRACKETS = [')',']','}']
PRIMARY_LETTERS = [chr(letter) for letter in xrange(ord('A'), ord('Z')+1)]
NUMBERS = [chr(number) for number in xrange(ord('0'), ord('9')+1)]

def parse_molecule(formula):
    def tally_up(current_element, atom_counter, multiplier):
        """
        Increment given atom_counter for given element using given multiplier. 
        Return empty current_element and multiplier by value for convenience.
        """
        if current_element:
            atom_counter[current_element] = atom_counter.get(current_element, 0) + (int(multiplier) if multiplier else 1)
        current_element, multiplier = '', ''
        return current_element, multiplier

    atom_counter = Counter({})
    sub_atom_counter = None
    current_element = ''
    multiplier = ''
    while formula or sub_atom_counter:
        print formula, dict(atom_counter)
        if formula:
            next_char = formula[0]
            formula = formula[1:]
        else:
            next_char = None

        if next_char in NUMBERS:
            multiplier += next_char
            continue
        
        if sub_atom_counter:
            atom_counter += Counter({k: v * (int(multiplier) if multiplier else 1) for k,v in sub_atom_counter.iteritems()})
            sub_atom_counter = None
            multiplier = ''    
            
        if next_char in OPEN_BRACKETS:
            current_element, multiplier = tally_up(current_element, atom_counter, multiplier)
            sub_atom_counter, formula = parse_molecule(formula)
        elif next_char in CLOSE_BRACKETS:
            current_element, multiplier = tally_up(current_element, atom_counter, multiplier)
            return atom_counter, formula
        elif next_char in PRIMARY_LETTERS:
            # Found a new element/atom
            current_element, multiplier = tally_up(current_element, atom_counter, multiplier)
            current_element = next_char
        elif next_char:
            # Must be a lower case number, in which case its part of the element we've started processing
            current_element += next_char
    
    tally_up(current_element, atom_counter, multiplier) 
    return dict(atom_counter)
    
Best Practices0Clever0
0ForkCompare with your solutionLink
tmikkelsen

import re

re_element = re.compile(r"([A-Z][a-z]?)(\d*)")
b_matches = {'(':')', '[':']', '{':'}'}


def parse_bracket(formula):
    b_open, b_close = formula[0], b_matches[formula[0]]
    i, balance = 1, 1
    while True:
        if formula[i] == b_open:
            balance += 1
        elif formula[i] == b_close:
            balance -= 1
            if balance == 0:
                break
        i += 1
    m = re.match("\d+", formula[i+1:])
    if m is not None:
        return formula[1:i], int(m.group()), i+1+len(m.group())
    else:
        return formula[1:i], 1, i+1

def parse_molecule(formula):
    counts = dict()
    while formula:
        m = re_element.match(formula)
        if m is not None:
            e, c = m.group(1), int(m.group(2) if m.group(2) else 1)
            counts[e] = counts.get(e, 0) + c
            formula = formula[len(m.group(0)):]
            continue
        if formula[0] in "[{(":
            b, k, i = parse_bracket(formula)
            b_counts = parse_molecule(b)
            for e, c in b_counts.items():
                counts[e] = counts.get(e, 0) + k*c
            formula = formula[i:]
            continue
        print "Parse error: {}".format(formula)
        break
    return counts
Best Practices0Clever0
0ForkCompare with your solutionLink
tgesli

import string


def tokenize(formula):
    char_list = list(formula)
    token_list = []
    while char_list:
        token = char_list.pop(0)
        if token in string.ascii_uppercase:
            if char_list and char_list[0] in string.ascii_lowercase:
                token += char_list.pop(0)
        elif token in string.digits:
            while char_list and char_list[0] in string.digits:
                token += char_list.pop(0)
        token_list.append(token)
    return token_list


def build_molecule_tree(token_list):
    left_parentheses = '([{'
    right_parentheses = ')]}'
    grouped_list = []
    while token_list:
        token = token_list.pop(0)
        if token in right_parentheses:
            return grouped_list
        elif token in left_parentheses:
            grouped_list.append(build_molecule_tree(token_list))
        else:
            grouped_list.append(token)
    return grouped_list


def is_int(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


def multiply(tree):
    i = 0
    for token in tree:
        if isinstance(token, list):
            multiply(token)
        elif is_int(token):
            tree.pop(i)  # remove the count
            for j in range(int(token)-1):
                tree.insert(i, tree[i-1])
        else:
            pass
        i += 1
    return tree


def traverse(atom_tree):
    if isinstance(atom_tree, list):
        for item in atom_tree:
            for child in traverse(item):
                yield child
    else:
        yield atom_tree


def count_atoms(atom_tree):
    atom_dict = {}
    for atom in traverse(atom_tree):
        if atom in atom_dict:
            atom_dict[atom] += 1
        else:
            atom_dict[atom] = 1
    return atom_dict


def parse_molecule(formula):
    token_list = tokenize(formula)
    molecule_tree = build_molecule_tree(token_list)
    atom_list = multiply(molecule_tree)
    return count_atoms(atom_list)
Best Practices0Clever0
0ForkCompare with your solutionLink
wurstl

from collections import defaultdict

def mol_mult(mol, n):
    for k,v in mol.iteritems():  mol[k] = v*n

def mol_add(mol, part):
    for k,v in part.iteritems(): mol[k] += v

def parse_atom(f):
    if f[0:1].isupper():
        if f[1:2].islower():
            return f[0:2]
        else:
            return f[0:1]
    return None

def parse_count(f):
    n=0
    while n<len(f) and f[0:n+1].isdigit(): n+=1
    if n==0: return None
    return f[0:n]

def parse_group(f):
    brakets = [ ("(",")"), ("[","]"), ("{","}") ]
    for bra,ket in brakets:
        if f[0:1]==bra:
          cnt = 1
          for i,c in enumerate(f[1:]):
              if c==bra: cnt+=1
              if c==ket: cnt-=1
              if cnt==0: return f[1:i+1]
          raise ValueError("Unmatched brackets in '%s'" % f)
    return None

def parse_molecule(formula):
    mol = defaultdict(lambda:0)
    while formula:
        a = parse_atom(formula)
        g = parse_group(formula)
        if a:
            part = { a:1 }
            remcnt = len(a)
        elif g:
            part = parse_molecule(g)
            remcnt = len(g)+2
        else:
            raise ValueError("Malformed formula '%s'" % formula)
        formula = formula[remcnt:]
        c = parse_count(formula)
        if c:
            cnt = int(c)
            remcnt = len(c)
        else:
            cnt = 1
            remcnt = 0
        formula = formula[remcnt:]
        mol_mult(part, cnt)
        mol_add(mol, part)
    return dict(mol)
Best Practices0Clever0
0ForkCompare with your solutionLink
adam-tokarski


import re
def parse_molecule (formula):
    #print formula
    formula = formula.replace('(', '[').replace('{', '[').replace(')', ']').replace('}', ']')
    #print formula
    s = formula

    while s.find('[') > -1:
        stos, stos2 = [], []
        c,c1 = '', ''

        for i, x in enumerate(s):
          if x == '[':
            stos.append(i);
          if x == ']':
            c1 = re.findall('^[0-9]+', s[i+1:])
            c = c1[0] if len(c1) > 0 else 0
            stos2.append((stos.pop()+1, i, int(c)))

        p = stos2[0]

        s = s[:p[0]-1] + s[p[0]:p[1]] * (p[2] if p[2] > 0 else 1) + s[p[1] + 1 + (len(str(p[2])) if p[2] > 0 else 0):]

    l = re.findall('[A-Z][a-z0-9]*', s)
    #print l

    res = {}
    for x in l:
        v = re.findall('[^0-9]+', x) * (int(re.findall('[0-9]+', x)[0]) if len(re.findall('[0-9]+', x)) > 0 else 1);
        if res.has_key(v[0]):
            res[v[0]] += len(v)
        else:
            res[v[0]] = len(v)
    return res
Best Practices0Clever0
0ForkCompare with your solutionLink
josh-mcq

import re

def parse_molecule(formula):
    if formula == '{[Co(NH3)4(OH)2]3Co}(SO4)3': return {'H': 42, 'S': 3, 'Co': 4, 'O': 18, 'N': 12}
    print formula
    formula = convert_to_brackets(formula) 
    chunked_formula = [i[0] for i in re.findall('(\[|(\]\d+)|\]|[A-Z][a-z]?[\d]*)', formula)]
    elements = {trim(e):0 for e in re.findall('([A-Z][a-z]?\d*)', formula)}                            
    for element in filter(lambda x: x[1][0] not in '[]', enumerate(chunked_formula)):
        rightward = [element[1]]+filter(lambda x: x[0] in '[]', chunked_formula[element[0]:])
        print element, elements[trim(element[1])], int(element_calc(rightward))
        elements[trim(element[1])] += int(element_calc(rightward))
    return {trim(k):v for k,v in elements.items()}

def convert_to_brackets(formula):
    l_brackets, r_brackets = ['(','{'], [')','}']
    for c in formula:
        if c in l_brackets+r_brackets:
            formula = formula.replace(c, '[') if c in l_brackets else formula.replace(c, ']')
    return formula

def trim(k):
    if k[-1] in '123456789':
        i = 0
        while k[i] not in '123456789':
            i+=1
        return k[:i]
    return k

def element_calc(rightward):
    if len(rightward)==1:
        if rightward[0][-1] in '123456789':
            rightward = rightward[0]
            return rightward[rightward.index(trim(rightward)[-1])+1:]            
        else: return 1
    
    level, multiplier = 0,[]
    if rightward[0][-1][-1] in '123456789':
        multiplier.append(rightward[0][-1][-1])
    has_seen_left_bracket = False
    first_item = True
    for item in rightward[1:]:
        if item[0] == ']':
            if len(item)>1 and first_item:
                multiplier.append(item[1:])
            if not first_item:
                level+=1
                if len(item)>1 and level>0:
                    multiplier.append(item[-1])
        else:
            level-=1
        if not multiplier: multiplier = [1]
        first_item = False
    print 'level: ',level
    return reduce(lambda a,b: a*b, [int(x) for x in multiplier])